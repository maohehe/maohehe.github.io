<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm内存分配及垃圾收集]]></title>
    <url>%2F2019%2F02%2F20%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[一、垃圾收集概述回收区域： 栈：栈中的栈帧根据方法的开始和结束来执行入栈和出栈的操作，而每个栈帧要分配的内存在类结构确定下来就可以确定了。方法或线程结束，栈帧内存就回收。 堆和方法区：堆中一个接口的多个实现类需要的内存可能不同，方法区中一个方法的多个分支需要的内存也不一样，程序运行期才知道创建哪些对象，所以堆和方法区的内存分配不是开始就确定的(动态的)，回收也是动态的。 二、判断对象是否存活​ 堆中几乎存放着java所有对象，垃圾收集器在回收前要先判断对象是否存活。 1. 引用计数算法 给对象添加一个引用计数器，每当有一个地方引用该对象，计数器加 1，解除引用，计数器减 1。任一时刻，只要计数器为 0 ，则认为该对象不再存活。 带来的问题： 对象之间循环引用问题。 例如， 123456789101112131415161718public class Test&#123; public Object instance = null; public static void main(String[] args)&#123; //通过new在堆中创建一个对象，暂且称为实例1,test1引用了实例1对象，则实例1的引用加 1。 Test test1 = new Test(); //又通过new在堆中创建一个对象，称为实例2,test2引用了实例2对象，则实例2的引用加 1。 Test test2 = new Test(); //test1的instance属性引用了test2，实际上引用的是test2指向的堆中的实例2对象，实例2的引用又加 1，此时实例2引用数为 2. test1.instance = test2; //test2的instance属性引用了test1，实际上引用的是test1指向的堆中的实例1对象，实例1的引用又加 1，此时实例1引用数为 2. test2.instance = test1; //test1引用置为空，即不指向实例1，实例1引用数减1，为 1. test1 = null; //test2同test1. test2 = null; &#125;&#125;//最终实例1 和实例2 的引用数都为1(instance属性对其的引用)，所以这两个实例对象都不会被回收。 2. 根搜索算法 通过一系列的名为”GC Roots”的对象作为起始点，从这些节点向下搜索，经过的路径称为引用链，若一个对象到GC Roots没有引用链(即从GC Roots开始无法到达该对象)，则对象不可用。 可作为GC Roots的对象： 虚拟机栈中引用的对象。 方法区中类静态属性(static)引用的对象。 方法区中常量(final)引用的对象。 本地方法栈(native方法)中引用的对象。 3. 引用的分类： 强引用：可理解为直接引用，Object obj = new Object();，对于这类引用，垃圾收集器永远不会回收new Object()创造出的实例对象。 软引用：描述一些还有用，但不是必须要的对象。如果系统将要发生内存溢出，这些被软引用关联的对象就会被列进回收范围等待被回收，如果回收之后还是内存溢出，就抛出异常。 弱引用：也是描述非必须要的对象，比软引用更弱。弱引用关联的对象只能生存到下一次垃圾收集之前，下次垃圾收集开始时，内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：没啥实际引用意义。虚引用唯一目的就是关联对象被垃圾收集之前能收到个”报信”。 4. 根搜索算法判定对象存活处死一个对象的过程： 两次标记 一次标记：从GC Roots节点无法到达该对象。进行第一次标记和一次筛选，筛选是通过该对象是否有必要执行finalize()方法进行筛选。如果对象没有finalize方法或finalize方法之前被jvm调用过了，则没必要执行finalize方法，对象GG。 二次标记：如果对象有必要执行finalize方法，则该对象就会被放在F-Queue队列（押往刑场的牢笼）中，jvm会建立一个Finalizer线程来执行对象的finalize方法。Finalizer线程执行而不是对象自己执行finalize方法的目的是：防止对象以各种借口延缓被执行死刑（死循环），而Finalizer线程不会等待对象finalize方法结束。在这短短的finalize方法执行期间，如果对象成功收买法官（将该对象自身this赋值给GC Roots引用链上的对象），则该对象就逃出牢笼，完成自救。 注意： 待处死的对象完成自救后，如果继续犯事被押赴刑场，那就必须被处决了，因为它无法在finalize方法中再次收买法官（任何一个对象的finalize方法都只会被执行一次）。 示例： 12345678910111213141516171819202122232425262728293031323334353637package jvmTest01;public class KillObject &#123; public static KillObject SAVE_HIMSELF = null; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("死刑对象被押赴刑场..."); //收买法官，完成自救(和GC Roots引用链上的对象绑定) KillObject.SAVE_HIMSELF = this; &#125; public static void main(String[] args) throws Throwable&#123; //new实例化的KillObject对象在 GC Roots引用链中 SAVE_HIMSELF = new KillObject(); //KillObject对象犯事，不在引用链中，要被处死 SAVE_HIMSELF = null; //gc方法执行包含对象标记的过程，也包含对象的finalize方法执行 System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; //KillObject对象屡教不改，再次犯事 SAVE_HIMSELF = null; System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; &#125;&#125; 运行结果： 123456D:\java\jdk\bin\java.exe 死刑对象被押赴刑场...死刑对象完成自救死刑对象被处死(被回收)Process finished with exit code 0 结果表明： 对象再次犯事，没有完成自救被回收。因为他无法再次通过执行finalize方法收买法官（finalize方法一个对象只能执行一次）。 三、垃圾收集算法1. 标记 - 清除算法​ 最基本的垃圾收集算法。 算法思想： 标记：标记出要回收的对象。就是标记出上一节中那些最终押赴刑场执行处死的对象。 清除：统一回收掉被标记对象。对要处死对象统一枪毙。 问题： 标记 - 清除效率低下。 清除后的对象产生小碎片，如果要分配大对象，还需要再次进行垃圾收集整合小碎片为大空间。 2. 复制算法​ 将可用内存划分为容量相等的两块，每次使用一块，使用的这块用完了，进行垃圾回收时，就将这块上的存活对象复制到另一块保留区域上，再将这块内存区域一次清理变成保留区域。 ​ 代价就是内存缩小为原来的一半。 回收新生代采用复制算法，并做了改进： ​ 新生代的对象 98% 都是短命鬼，由于回收时存活对象很少，所以划分区域时，就不用按照1:1划分了，划分一小块区域暂存存活对象即可。 ​ 新生代划分对象是划分为一块大空间（Eden）和两块小空间（Survivor），每次使用Eden和一块Survivor空间。进行回收，只需要把Eden和Survivor空间上的存活对象复制到另一块Survivor空间，最后清理掉Eden和Survivor空间。默认Eden:Survivor:Survivor=8:1:1。所以浪费的空间只有 10%。 ​ 如果进行回收时，存活对象比Survivor空间大，复制过去装不下，则就需要向其他内存（例如老年代）进行暂借空间，这种机制称为分配担保（后续讲解）。 3. 标记 - 整理算法算法思想： 标记：标记出要回收的对象。标记方法同标记 - 清除算法。 整理：让所有存活对象向内存区域的一端移动，聚一堆。然后将这一堆以外的其他空间直接清理，腾出空间。 4. 分代收集算法​ 根据对象存活周期的差异将内存划为几块。一般堆划分为新生代和老年代，根据年代特点选择不同的收集算法。 例如， 新生代：对象比较短命，存活的少，采用 8:1:1 的复制算法。 老年代：对象比较能活（老不死），采用标记 - 清理或者标记 - 整理算法。 四、垃圾收集器 说明： 图片上部Young generation表示新生代，Tenured generation表示老年代，收集器之间的连线表示两者可以配套使用。 1. Serial收集器（新生代、单线程）收集算法：复制算法。 ​ 单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在进行收集时，必须暂停其他所有的工作线程（包括用户正常的工作线程），直到收集完成。 应用： 目前是jvm运行在Client模式下的默认的新生代收集器，单线程没有线程交互，专心收垃圾，效率很高。 2. ParNew收集器（新生代，多线程）收集算法：复制算法。 ​ 可认为是Serial的多线程版本，除了增加了垃圾回收线程外，其他与Serial基本一致。 ​ 随着CPU数量增加，ParNew对于系统资源的利用越来越强。默认开启的GC线程数与CPU数量相同，可以使用 -XX:ParallelGCThreads 参数来限制GC线程数量。 3. Parallel Scavenge收集器（新生代、多线程）收集算法：复制算法。 与其他收集器如CMS收集器尽量缩短垃圾收集时用户线程的停顿时间不同，Parallel Scavenge收集器目标是达到一个可控制的吞吐量，吞吐量就是CPU运行用户代码时间占CPU运行总时间（包含垃圾收集时间）的比重。 停顿时间和吞吐量： ​ 首先应明确吞吐量是用户代码执行时间占总时间比例，总时间中垃圾收集并不是一次执行，而是许多次垃圾收集时间总和，用户代码和垃圾收集交替。而停顿时间是表示每次垃圾收集占有的时间，缩短停顿时间可能会导致垃圾收集次数变多。 停顿时间：停顿时间短，响应时间就快，适合与用户交互的程序。 吞吐量：吞吐量大，CPU执行用户代码时间长，程序的运算效率高，适合后台运算任务。 4. Serial Old收集器（老年代、单线程）收集算法：标记 - 整理算法。 ​ Serial收集器老年代版本。单线程收集器。 5. Parallel Old收集器（老年代、多线程）收集算法：标记 - 整理。 ​ Parallel Scavenge收集器老年代版本。多线程收集器。Parallel Scavenge + Parallel Old收集器组成纯 “吞吐量” 优先收集器。 6. CMS收集器（老年代、多线程）收集算法：标记 - 清除算法。 CMS收集器是一种为了获取最短停顿时间的收集器。 CMS运行过程： 初始标记：标记一下GC Roots直接关联的对象，速度快。需要暂停其他线程。 并发标记：从上阶段标记的直接关联对象触发，标记所有从GC Roots可达的对象（GC Roots间接关联的对象），该阶段是和用户线程并发执行的。该阶段耗时最长。 重新标记：为了修正并发标记阶段，因用户程序运行导致标记变动的对象的标记记录。速度比初始标记慢一点，但仍然很快。需要暂停其他线程。 并发清除：垃圾清除的过程。和用户线程并发执行。耗时较长。 扫尾：因为CMS运行有四个过程，其中有单线程（初始标记、重新标记），有多线程（并发标记、并发清除），而单线程耗时极短，大部分时间都消耗在多线程的并发阶段，所以可以认为是多线程的。 缺点： CMS收集器对资源敏感。并发执行，垃圾收集线程会占用部分CPU资源，默认GC线程数是（CPU数量+3）/4，当CPU数量小于 4时（例如 2个），就会分出 50%的资源用来GC。 增量式并发收集器：用来解决CPU数量小于 4的情况。做法就是在并发阶段（并发标记、并发清理），让GC线程和用户线程交互执行（并行），减少GC线程占用资源时间。 无法处理浮动垃圾。因为清除阶段是和用户线程并发执行的，所以清除阶段还可能产生新的垃圾而无法被清除，只能等下一次Full GC清除。也正因为用户线程还在运行，所以要留取一部分空间给用户线程，默认老年代使用 68%就会激活CMS进行回收。 -XX:CMSInitiatingOccupancyFraction参数设置可以来提高触发GC的百分比。 但如果CMS运行时预留给用户线程的内存不够，会出现一次 “Concurrent Mode Failure” 失败，导致CMS失效，使用预备的Serial Old收集器重新进行Full GC（老年代垃圾回收），停顿时间大大增加。 所以提高百分比有风险，设置需谨慎。 收集结束会产生大量空间碎片。CMS基于标记 - 清除算法，产生小碎片后，下次分配大对象会塞不进去，从而又触发一次Full GC。 -XX:+UseCMSCompactAtFullCollection 参数设置CMS收集结束后自动进行碎片整理（会暂停用户线程），不过停顿时间会延长。 -XX:CMSFullGCsBeforeCompaction 参数设置执行 n 次不压缩的Full GC后就执行一次压缩碎片的Full GC。 7. G1收集器（全堆、多线程）收集算法：标记 - 整理。 G1特点： 并行与并发：利用多CPU的优势，使用多个CPU来尽可能缩短停顿时间，来达到原本需要暂停用户线程的操作现在不暂停的效果。 分代收集：G1中仍然将内存空间进行分代。G1能够以不同的方式处理各种对象（新对象、存活一段时间对象、讲过几次GC仍存活的对象），来独立管理整个堆（包括新生代和老年代）。 空间整合：基于标记 - 整理算法，不产生内存碎片，收集后的空间连续、完整，可保存大对象。 可预测的停顿：除了降低停顿时间，G1还可以建立可预测的停顿时间模型。可以让使用者指定一个时间段，GC消耗的时间不能超过指定的时间。 管理整个堆内存： ​ G 1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 建立可预测的时间模型： ​ G1对整个堆进行垃圾收集是有计划的，其内部有一个回收优先级列表，列表中的待回收的Region顺序是根据每个Region回收性价比进行排序（回收的空间越大，时间越短，性价比越高），每次回收优先回收性价比高的Region，这样在一定的收集时间内收集效率就很高。 避免全堆扫描对象： ​ G1将堆分为多个Region，逻辑上相互独立，实际上Region中的对象可能与其他任意一个Region中的对象有引用关系。使用全堆扫描，才能保证GC的准确性，但GC效率会大大下降。 ​ 解决办法：G1为每个Region维护一个Remembered Set，如果程序对引用类型数据进行写操作，虚拟机会产生一个Write Barrier中断写操作，然后检查引用的对象是否是其他Region中的，如果是，就将引用信息写到被引用对象所在的Region的Remembered Set表中。进行内存回收时，GC Roots枚举范围也参照Remembered Set表内容来扫描对象，可以实现不全堆扫描也能保证准确。 G1运行流程： 初始标记：同CMS收集器。 并发标记：同CMS收集器。 最终标记：类似CMS的重新标记，也是为了找到并发标记情况下因程序运行收到变动的对象，然后将变化记录到线程的Remembered Set Logs中，之后再将Logs中的数据合并到Remembered Set中。 筛选回收：先根据回收性价比在优先级列表中排序，根据用户指定的停顿时间制定回收计划。制定停顿时间内根据优先级堆Region进行回收。 五、内存分配与回收 对象在堆中分配内存，主要分配在新生代的Eden去榆中，如果启动了TLAB，将按线程优先在TLAB上分配，少数情况直接分配在老年代。具体分配要参照收集器组合和设置的参数。 1. 对象优先在Eden分配​ 多数情况下，对象在Eden区分配，E的呢空间不够，则进行一次Minor GC（新生代GC），如果空间仍然不够，则根据分配担保机制，将Eden区中占空对象提前转移到老年代。 2. 大对象直接进入老年代​ 大对象需要占用大量的连续空间（如长字符串、数组等），虚拟机提供了一个参数用来指定大对象 -XX:PretenureSizeThreshold ，大于参数值的大对象直接扔进老年代。 ​ 注意：只有Serial和ParNew能识别该参数。可以考虑使用ParNew+CMS收集器组合来实现该参数相同的功能。 3. 长期存活的对象将进入老年代​ 虚拟机有分代收集思想，所以会识别对象是属于哪个年代。 ​ 识别对象年代方式：每个对象都有Age计数器代表年龄，对象从Eden出生并且度过了第一次Minor GC并能被Survivor容纳且成功转移到Survivor中，该对象Age为 1。以后对象每经过一次Minor GC且每被回收，Age就 +1，直到对象成年（默认Age为15）后，就晋升到老年代。对象成年Age值可通过 -XX:MaxTenuringThreshold 设置。 4. 对象成年Age动态判定​ 并不是一定到达参数指定Age才可扔到老年代。如果Survivor中相同Age所有对象大小总和大于Survivor空间的 50%，则Survivor中Age大于等于该Age的对象都可以直接进入老年代，而不用等到参数要求的Age。 ​ 例如，Survivor中有20MB空间，有一个4MB的对象Age为6，有六个2MB的对象Age为3，剩下四个1MB的对象Age为2，由于六个Age为3 的对象总空间12MB大于Survivor的 50%，所以此时Age为6和3的 7 个对象可以直接进入老年代。 5. 空间分配担保​ 新生代采用复制算法，GC时如果Survivor空间暂时不够保存存活的对象，就需要老年代进行分配担保，让Survivor无法容纳的对象进入老年代。但是老年代的剩余空间还得保证能够容纳这些对象，由于这次回收进入老年代的对象需要的空间是未知的，所以需要参考以往需要的容量的平均大小，来看是否能够容纳。如果不能容纳，即担保失败，就需要进行一次老年代的Full GC。 ​ 通过查看HandlePromotionFailure设置值是否支持担保失败，如果允许担保失败，则只进行Minor GC即可，如果不允许失败，也需要进行一次Full GC。]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F02%2F18%2FStartMyBlog%2F</url>
    <content type="text"><![CDATA[GitPages Hexo搭建GitHub博客1、下载安装node.jsNode.js官网下载注意： 可以选择自定义安装位置。 2、安装 Sublime text 3Sublime Text 3下载地址下载速度较慢，不过安装包较小。安装位置可自己选择。 3、注册GitHub账号 GitHub注册地址 注册用户名 邮箱 密码 添加新的仓库(new repository)： Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、安装GitGit下载地址下载安装Git，安装位置可自由选择。 5、配置GitHubSSH6、初始化配置Hexo简介： Hexo详细说明参考Hexo官网，Hexo就是一个用Node.js编写的静态网站生成器(所以需要安装Node.js)，可以用来做博客框架，恰好它还可以将静态网站部署到GitHub，所以你编写的博客通过Hexo生成静态页面，然后在部署到GitHub中，通过访问GitHub中的页面也都是静态页面。 在写博客的地方创建文件夹例如，我在D盘创建Hexo文件夹。 在D:/Hexo文件夹按住shift点击鼠标右键选择在此处打开Powershell窗口 输入npm install hexo-cli -g命令，等待 等待完成后输入 hexo -v查看是否安装。 打开D:/hexo文件夹，鼠标右键选择git bash here,输入hexo init blog命令来初始化blog目录，该目录用来存放博客相关。 git bash窗口中输入以下命令： cd blog npm install hexo s 浏览器输入 localhost:4000,看能否打开Hexo默认主题。 至此，博客系统搭建完成，需要手动配置博客主题(为了好看)。 7、Next主题使用在Hexo官网 上方有主题栏，可供选择。这里采用使用比较多的主题：NexT主题。 仓库下载地址：NexT仓库，可选择git clone或下载压缩包形式下载。 解压缩压缩包，并将文件夹更名为next，移动到blog/themes目录中。 修改Hexo配置文件_config.yml 修改配置文件详情即接下来的步骤，请参考NexT文档 或者博客末尾的第二个视频，文档和视频都非常详细。 参考视频教程(B站)：GitHub+hexo搭建博客使用Next主题优化博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
