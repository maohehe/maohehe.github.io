<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[联合索引的最左前缀匹配原则]]></title>
    <url>%2F2019%2F02%2F28%2FDBIndexLeft%2F</url>
    <content type="text"><![CDATA[表结构： 12345678CREATE TABLE `abcd` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`a`), KEY `inx_b_c_d` (`b`,`c`,`d`),) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 该表有 4 列，其中有一个联合索引由b,c,d三列联合。 一、联合索引索引可以是一个列(a)，而由多个列组成的索引(b,c,d)就称为联合索引（复合索引）。 联合索引的排序是由做到右排序的，首先根据b排序，之后对于b值相同的记录，再根据c排序，以此类推，所以c的顺序是建立在b等值的基础上的。 对于c来说，如果不考虑b的话，c 本身仍然是无序的。如下，对于相等的 b 来说，c 是有序的。 b c d 1 2 4 1 3 3 2 1 5 3 4 1 4 3 3 4 5 6 4 6 4 6 2 7 7 1 8 二、什么是最左前缀匹配 首先明确，最左前缀匹配原则是发生在联合索引上的。 最左前缀匹配就是根据建立的联合索引的顺序来匹配查询语句的条件。 对于一个联合索引，可以看做是多个索引的组合，例如前面的根据(b,c,d)建立的索引，就具有(b)、(b,c)、(b,c,d)这三个索引的作用。所以对于任何一个查询语句来说，只要有 b 条件就会使用索引查询，之后在看有没有 c ，d 而已。 对于上表的联合索引顺序(b,c,d) 当执行了一条查询语句时，查询的条件是根据 b,c,d 作为条件的，例如SELECT * FROM abcd WHERE b=2 and c=5 and d=1;这条语句会使用联合索引inx_b_c_d进行查询。 当执行了一条查询语句时，查询的条件是根据 b,c 作为条件的，如SELECT * FROM abcd WHERE b=2 and c=5;这条语句也会使用联合索引inx_b_c_d进行查询。 而对于以 c,d 作为查询条件是无法使用联合索引inx_b_c_d进行查询的，因为它不是以 b 开始的，上面说了，脱离了 b ，c 就是无序的，既然无序，索引页没有意义了，总不能对无序的数据列使用二分查找吧。 那如果查询条件是 b,d 呢？当然也会使用联合索引的，但是索引只匹配到了(b)，d 是无法使用索引查询的。 所以说，最左匹配就是从索引的左边开始匹配给定的条件项。如果没有最左边的那一列，那后面都是无序的了，也就不能使用索引了。 那如果查询条件和索引顺序不一致呢？ 即查询语句如果是 SELECT * FROM abcd WHERE c=5 and d=1 b=2 and; 呢？对于这个查询语句，最后执行的时候，条件的顺序会被mysql查询优化器转换成 b,c,d 的顺序的。 查询优化器会自动判断这条语句以什么形式执行起来效率会更高，最后将语句纠正为效率最高的形式。例如对于上面的语句来说，如果不纠正，就无法使用联合索引，就需要一个个记录的来查询搜索，效率肯定地，而如果调换查询条件顺序为 b,c,d 顺序的话，就可以使用联合索引了，效率会更高（拙见，不知道可不可以这么理解）。 当然最左匹配对于查询条件还是有要求的： 最左匹配向右依次匹配，如果遇到范围查询条件(&gt;、&lt;、between、like)就会停止匹配。例如b = 2 and c &gt; 3 and d = 4如果建立(b,c,d)顺序的索引，d是用不到索引的。 查询条件中 = 和 in 可以乱序，比如b = 1 and c = 2 and d = 3建立(b,c,d)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式。]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂设计模式（简单工厂、工厂方法、抽象工厂）]]></title>
    <url>%2F2019%2F02%2F28%2FjavaFactory%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式概述 简单工厂模式又叫做静态工厂方法（Static Factory Method）模式，但不属于GOF23种设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 举例来说，有一个汽车工厂，用来生产各种汽车（奔驰、奥迪、大众等等），当你需要什么车就告诉工厂我要什么品牌的车，工厂就会生产出对应品牌的车供你使用。 对应于代码中，工厂就是一个Factory对象，各种汽车就是一个Car接口，各种品牌的车就是Car的具体实现类，工厂生产车就是CreateCar(String Paizi)方法，通过用户指定的品牌作为参数，来生产对应的车，返回一个车对象Car c = new Audi(); 实例代码：123456789101112131415161718192021/** * 定义要生产的东西 *///汽车接口interface Car&#123; void run();&#125;//Car实现类Audi车class Audi implements Car&#123; public void run()&#123; System.out.println("奥迪在飞驰。"); &#125;&#125;//Car实现类QQ车public class QQ implements Car &#123; @Override public void run() &#123; System.out.println("奇瑞QQ在飞驰！"); &#125;&#125; 1234567891011//汽车工厂public class SimpleFactory &#123; public static Car createCar(String type)&#123; if ("奥迪".equals(type)) return new Audi(); else if("QQ".equals(type)) return new QQ(); else return null; &#125;&#125; 123456789//用户提车public class TestSimpleFactory&#123; public static void main(String[] args)&#123; //用户喜提奇瑞QQ车 Car c1 = SimpleFactory.createCar("QQ"); //用户喜提奥迪车 Car c2 = SimpleFactory.createCar("奥迪"); &#125;&#125; 总结 优点：简单工厂模式可以根据外界给定的信息，创建出对应的类的实例，明确区分了各自的职责。 缺点：如果工厂升级，可以创建更多牌子的车，那必须要在工厂的源码中进行添加修改的操作，就违反了“面向对象设计原则的开闭原则：对扩展开放，对修改关闭”。 二、工厂方法模式概述 工厂方法模式又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。工厂方法模式属于GOF23种设计模式。 举例来说，还是上面的车厂，随着车厂的规模越来越大，一个工厂显然不够用，于是就要有分厂，和平时的分厂不一样，他们的分厂是按照生产的车的品牌分的，而总厂是用来指导分厂应该有什么工作的，比如生产车、修车等。 对应于代码中，总厂就是一个Factory接口，分厂就是具体的工厂接口的实现类AudiFactory、QQFactory等类，是根据生产车的品牌划分。每种分厂只能生产一种品牌的车子。工厂的作用（生产车、修车等）也是根据总厂的指示实现对应的createCar()等方法。 实例代码1234567891011121314151617181920/** * 要生产的汽车同上面的代码（Car、Audi、QQ） *///汽车总厂interface CarFactory&#123; Car createCar();&#125;//奥迪分厂class AudiFactory implements CarFactory&#123; public Car createCar()&#123; return new Audi(); &#125;&#125;//奇瑞QQ分厂class QQFactory implements CarFactory&#123; public Car createCar()&#123; return new QQ(); &#125;&#125; 123456789//用户提车public class FactoryTest &#123; public static void main(String[] args) &#123; //用户喜提奇瑞QQ Car qq = new QQFactory().createCar(); //用户喜提Audi车 Car audi = new AudiFactory().createCar(); &#125;&#125; 总结优点： 完全符合开闭原则。如果工厂开拓业务，需要增加生产奔驰车，则只需要开设一个奔驰分厂（BenchiFactory implements CarFactory），而其他的代码不需要修改，实现了对扩展开放。 缺点： 实现起来比简单工厂复杂。比如结构较复杂（工厂较多，简单工厂只有一个工厂），代码较复杂，客户端编程复杂等。 理论上，工厂方法模式较好，但实际上，简单工厂使用的还是多一点。 三、抽象工厂模式概述 抽象工厂模式用来生产不同产品族的全部产品。（无法新增某个产品族的单个产品，只能增加产品族）。 抽象工厂模式是工厂方法模式的升级，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种很好的模式。 什么是产品族？举例来说，汽车由很多部件组成，例如发动机、轮胎、座椅等。而这些部件不同的工厂生产的又不一样，所以这三个部件对应一个产品族，不同的部件组合就是不同的产品族。 对于代码中，总厂（CarFactory）来指示分厂生产不同的产品族（高端汽车NBCarFactory、低端汽车LBCarFactory），而分厂又调用不同配件厂的高低端配件（高端发动机NBEngine、低端发动机LBEngine等等）来生产对应的产品族汽车。 实例代码123456789101112131415161718192021222324252627282930313233343536//发动机接口public interface Engine &#123; void info();&#125;//高端发动机实现类class NBEngine implements Engine &#123; @Override public void info() &#123; System.out.println("配备高端引擎"); &#125;&#125;//低端发动机实现类class LBEngine implements Engine &#123; @Override public void info() &#123; System.out.println("配备低端引擎"); &#125;&#125;//轮胎接口interface Luntai&#123; void info();&#125;//高端轮胎实现类class NBLuntai implements Luntai&#123; @Override public void info() &#123; System.out.println("配备高端轮胎"); &#125;&#125;//低端轮胎实现类class LBLunTai implements LunTai &#123; @Override public void info() &#123; System.out.println("配备低端轮胎"); &#125;&#125; 12345678910111213141516171819202122232425262728293031/** * CarFactory总工厂接口，可以有不同的分厂来生产不同的产品族 */public interface CarFactory &#123; Engine createEngine(); LunTai createLunTai();&#125;//高端汽车工厂实现类（高端分厂）class NBCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new NBEngine(); &#125; @Override public LunTai createLunTai() &#123; return new NBLunTai(); &#125;&#125;//低端汽车工厂实现类（低端分厂）public class LBCarFactory implements CarFactory&#123; @Override public Engine createEngine() &#123; return new LBEngine(); &#125; @Override public LunTai createLunTai() &#123; return new LBLunTai(); &#125;&#125; 123456789public class TestAbstractFactory&#123; public static void main(String[] args)&#123; //创建高端产品工厂 CarFactory NBFactory = new NBCarFactory(); //获得高端产品族组件 Engine NBengine = NBFactory.createEngine(); Luntai NBLuntai = NBFactory.createLuntai(); &#125;&#125; 总结对于抽象工厂模式来说，添加工厂只能添加一个整的产品族，比如增加中端工厂（高端发动机+低端轮胎），无法增加单个产品。 四、工厂模式应用场景 JDBC中Connection对象的获取 Mybatis中SessionFactory创建Session对象 Spring的IoC容器中创建管理 bean 反射中 Class 对象的newInstance()]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F02%2F28%2FjavaSingleton%2F</url>
    <content type="text"><![CDATA[作用在应用程序中保证最多只有一个实例对象。 应用场景 Spring 中，管理的每个Bean默认都是单例的。 Servlet 中，每个Servlet也都是单例的。 SpringMVC 中，控制器对象也都是单例的。 数据库连接池也是单例的，因为数据库资源只有一份，没必要每次都由新的对象加载。 项目中读取配置文件的类也是单例的，只有一个对象。配置文件只有一份，也没必要每次由新对象读取。 优点 单例模式只生成一个实例对象，效率较高。挡生成一个对象需要比较多的资源时（读取配置、产生其他依赖对象），就可以通过产生单例对象解决，然后该对象永久留在内存中。 单例模式可以在系统设置全局访问点，优化对共享资源的访问。例如设计一个单例类，负责所有数据表的映射。 实现方式1. 饿汉式 因为创建实例是在类初始化就创建的，不管是否使用它都会占用那一块内存，所以就没有了延时加载的优势。 实例代码： 12345678910111213141516package com.GOF.Singleton;public class SingletonDemo01 &#123; /** * 虚拟机加载类时，会立即加载该static变量，创建一个对象 * 因为类加载过程执行&lt;clinit&gt;()方法是加锁的，所以该例没有线程安全问题 */ private static SingletonDemo01 instance = new SingletonDemo01(); private SingletonDemo01() &#123; &#125; public static SingletonDemo01 getInstance() &#123; return instance; &#125;&#125; 2. 懒汉式 懒汉式采用延迟加载模式，每次需要使用时才去加载，不必在类初始化就创建对象，对资源利用率较高。 对于getInstance()方法由于每次调用都上锁，之后再进行判断是否已经有实例化对象，所以调用效率较低。 实例代码： 12345678910111213141516171819202122package com.GOF.Singleton;/** * 实现方式一：方法基础上的同步，调用效率低下 */public class SingletonDemo02 &#123; /** * 类初始化时，并没有初始化该对象，而是等到使用时才加载 */ private static SingletonDemo02 instance; private SingletonDemo02() &#123; &#125; /** * 方法进行同步，保证线程安全 */ public synchronized static SingletonDemo02 getInstance() &#123; if (instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 123456789101112131415161718192021222324252627282930package com.GOF.Singleton;/** * 实现方式二：双重检查锁改进 */public class SingletonDemo02 &#123; /** * 类初始化时，并没有初始化该对象，而是等到使用时才加载 * 如果不加volitale关键字，多线程环境下会出问题 */ private volitale static SingletonDemo02 instance; private SingletonDemo02() &#123; &#125; /** * 同步代码块实现同步，保证线程安全 */ public static SingletonDemo02 getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo02.class) &#123; if (instance == null) &#123; instance = new SingletonDemo02(); &#125; &#125; &#125; return instance; &#125;&#125;//在方法内部使用同步代码块，当已经创建实例对象时，多线程访问时，就不必再上锁，可以直接返回，调用效率自然也就高了。//同步代码块将第一次创建对象进行同步，来保证只会实例化一个对象。 两次null判断解释： 第一次null判断是同步代码块外的，用来判断是否已经有了实例对象。 第二次null判断是同步代码块中的。假若线程 A 第一次判断 null 成功，即将进行对象的实例化，此时CPU将其挂起，线程 B 进来了，此时判断也为空，也进行实例化，而线程 B 成功实例化了，退出了。之后线程 A 又被调度，开始从同步代码块执行（上锁），因为之前 B 已经实例化了一个对象，如果代码块中不进行 null 判断的话，线程 A 又会实例化一个新对象，就不符合单例模式了。 双重检查锁方法的问题（多线程环境）： 先上双重检查锁相关代码： 12345678910public static SingletonDemo02 getInstance() &#123; if (instance == null) &#123; //(1) synchronized (SingletonDemo02.class) &#123; if (instance == null) &#123; //(2) instance = new SingletonDemo02();//(3) &#125; &#125; &#125; return instance;&#125; 对于(3)处的代码，虽然源码中只有一句，但是对应的字节码文件中的字节码指令却有三条，分别是： 为对象分配内存空间 在内存空间中初始化对象 将引用instance指向对象在内存中的地址 对于上面的三条指令，其顺序并不是想象的那样是固定的，而是有可能发生重排序，即1-&gt;3-&gt;2的顺序，这样的后果是 instance 确实指向了给对象分配的地址，但是对象这时候还没有初始化啊，也就是还没有执行对象的构造方法，这样的对象是不完整的，对象中的变量值啊什么的都不是我们期望的值。 再比如，线程 A 执行到(3)指令重排序了，就发生了上面的结果，此时线程 B 在执行(1)时，判断的是 instance 非空（指向了一块内存地址），就返回了这个 instance，但是返回的这个对象还没有被初始化，是不完整的，就带来了一些列问题。 注意：刚开始看这个问题的时候，就很疑惑，明明线程 A 已经通过synchronized关键字加锁了，就算内部指令重排序了，其他线程也进不来，为什么其他线程还会访问到这个不完整的对象？ 后来发现原来是我的切入点错了，线程 A 对instance的修改是实时的，修改的过程中，其他线程在(1)处的判断也是可以访问到instance的。 解决办法： 可以使用 volatile 关键字来实现禁止指令重排序。这样顺序就会保证对象在内存中初始化之后，instance才会指向对象在内存中的地址，这样，其他线程判断instance仍然是null。 private static volatile SingletonDemo02 instance; 3. 静态内部类实现单例 由于外部类没有static变量和static{}代码块，所以不会立即加载对象（延迟加载）。 只有调用了getInstance()方法才会加载静态内部类，来实例化static变量（类加载机制&lt;clinit&gt;()方法只加载一次）。保证了线程安全。 调用效率也高，并且是延迟加载的。 实例代码： 1234567891011121314package com.GOF.Singleton;public class SingletonDemo03 &#123; private SingletonDemo03() &#123; &#125; //内部类被加载时，才会实例化static instance对象 private static class SingletonClassInstance &#123; private static SingletonDemo03 instance = new SingletonDemo03(); &#125; //该方法被调用时才会去加载内部类 private static SingletonDemo03 getInstance() &#123; return SingletonClassInstance.instance; &#125;&#125; 4. 枚举实现单例 枚举本身就是单例模式，基于jvm底层实现，可以避免通过反射和反序列化的漏洞。 实现过程相对简单。 由于枚举类一加载就会实例化单例对象，所以这种方式没有延迟加载。 实例代码： 123456789101112131415package com.GOF.Singleton;public enum SingletonDemo04 &#123; /** * 定义一个枚举元素，该元素就代表了SingletonDemo4的一个实例 */ INSTANCE; /** * 其他操作 */ public void singletonOperation() &#123; //功能处理 &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 类加载机制]]></title>
    <url>%2F2019%2F02%2F26%2FjvmClassLoad%2F</url>
    <content type="text"><![CDATA[一、概述​ 类的完整生命周期：加载、验证、准备、解析、初始化、使用、卸载。 ​ 类加载的周期：加载、连接（验证、准备、解析）、初始化。 ​ 其中加载、验证、准备、初始化、卸载这5个阶段的开始顺序是确定的，也就是，准备阶段不能再验证开始前开始，但是只是规定了开始有顺序，运行的过程却是可以交叉运行，即验证阶段开始后，还没验证结束，准备阶段就开始了，期间他们可以交叉运行。 ​ 而解析阶段的开始时间却是不确定的，一些情况下解析阶段可以在初始化之后才开始。 二、类加载过程1. 加载​ 对于一个类，什么时候开始加载？虚拟机并没有明确的规定一个类要在什么时候加载，虚拟机会在需要的时候自动进行加载，我们不用操心。 ​ 虽然不知道类会在什么时候加载，但是它确实会有这个阶段。虚拟机在类的加载阶段会有如下3个过程： 通过类的全限定名来获取定义此类的二进制字节流（例如找到类的class文件）。了解：对于获取二进制字节流来说，并不只有找到class文件这一种，还有从ZIP压缩文件中（jar,war）、从网络获取、运行时计算生成（动态代理）、其他文件生成（Jsp）、数据库读取等。 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。 在内存（方法区）中生成这个类对应的Class对象，作为方法区中这个类的各种数据的访问入口。 ​ 而通过类的全限定名获取二进制字节流是通过 “类加载器” 实现的，类加载器是用户可以编写的程序，也就是说，用户通过实现类加载器可以自己决定到哪去获得这个二进制流。关于类加载器在后面会讲。 ​ 对于非数组的类，可以使用类加载器（虚拟机自带或用户定义）进行加载来控制从哪如何获取二进制流。但是对于数组类来说，数组类不通过类加载器创建，是由虚拟机直接创建的，但是数组类中的元素类型还是由类加载器创建。 数组类创建过程： 若数组的组件类型是引用类型（组件类型就是数组去掉一个维度的类型），就递归采用“加载、验证、准备、解析、初始化”的过程加载组件类型。 若数组的组件类型不是引用类型（基础类型 int[]等），虚拟机将会把数组标记为与 “引导类加载器” 关联。 数组类可见性同其组件类型的可见类型，若组件是基本类型，默认可见类型为public。 加载阶段结束后，二进制字节流中的内容就会存到方法区中。然后在方法区中实例化一个Class类对象，作为方法区中数据访问的入口。 2. 验证 验证的目的是为了确保Class文件的字节流中的信息是否合法，要保证它的内容不会危害虚拟机。 ​ 但是编译阶段就会筛选信息是否正确，错误的信息直接编译失败，那为什么还有不合法的信息危害虚拟机呢？那是因为Class文件并不仅仅是java源文件编译来的，因为它是二进制字节流，我们自己甚至都可以编写它（如果你够牛P的话），所以，通过其他过程获得的字节流可能是不合法滴。 验证阶段大致分为下面 4 个检验动作： 1. 文件格式验证 该阶段要验证字节流是否符合Class文件格式的规范，是否能被虚拟机理解。 可验证的地方： 是否以魔数 0xCAFEBABE 开头？ 主次版本号是否有误？ 常量池中的常量是否是那些规定里面的常量类型（tag不对）？ 指向常量的索引是否有问题（瞎鸡儿指个错的）？ CONSTANT_utf8_info型的常量是否不符合UTF8编码数据？ Class文件是否被修改过（恶意添加、删除信息）？ 经过这个阶段验证过，字节流才会进入内存方法区存储，后面的 3 验证阶段都是对方法区中存储的数据进行验证，不会再操作字节流了。 2. 元数据验证 对字节码描述的信息进行语义分析。 可验证的地方： 这个类是否有父类？ 这个类父类是否继承了不可被继承的类？（如继承了String类） 如果该类不是抽象类，是否实现了父类（如抽象类）或接口中要求实现的方法？ 类中字段、方法是否合理？（例如覆盖了父类的final字段，方法重载有问题等都不合理） 3. 字节码验证 该阶段是对类中的方法体字节码进行分析，主要是通过数据流和控制流分析，来确定语义是否合法和逻辑。 可验证的地方： 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作，例如不能出现int数据入栈，最后写入到本地变量表中却变成long类型。 保证跳转指令不会瞎鸡儿跳，例如不能调到方法体外去了。 保证方法体中类型转换有效（显式或隐式），例如不能出现Dog d = new Cat()这种。 4. 符号引用验证 该阶段发生在虚拟机将符号引用转化为直接引用时，这个验证阶段在解析阶段之后发生。符号引用验证可以看做是对类自身以外的信息进行匹配性检验。 可校验的地方： 符号引用中通过字符串描述的全限定名是否能找到对应类。 指定类中是否存在符合方法的字段描述符以及简单名称描述的方法和字段。就是描述符和简单名称能否和指定类中的方法或字段对应上。 符号引用中的类、字段、方法的访问性是否可被当前类访问。例如访问了private修饰的类或字段或方法等就是不行的。 符号验证阶段目的是为了保证解析动作正常执行。 3. 准备​ 准备阶段是为类变量（static变量）分配内存并设置初始值的阶段，这些static变量的内存都将分配在方法区。 ​ 对static变量设置的初始值一般是数据类型的零值，例如int类型零值0，boolean类型零值为false，引用类型零值为null等。 ​ 而对于 final 修饰的常量，在编译时期，就会将常量值保存在字段对应的字段属性表的ConstantValue属性中，在准备阶段，变量就会被初始化为ConstantValue属性指定的值，而不是零值。举例，public static final int value = 123;在编译阶段，123 被保存在value的字段属性表的ConstantValue属性中，准备阶段，会根据ConstantValue属性设置value的值为 123。 4. 解析 解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用与直接引用： 符号引用： 啥是符号引用？书上的原话就不贴了。当我们的java源文件编译之后，会生成一个Class文件，文件中有常量池一块，里面就是保存的字面量和符号引用。常量池中的符号引用最终就是引用的字面量的内容。 编译后的Class文件中还有方法表，方法表中有Code属性用来保存方法体对应的字节码指令，这些都是编译期生成的，如果方法体重要引用另一个类的方法，这个类还没有被加载哎，那该怎么表示呢？ 所以符号引用就是用来表示这些的。例如字节码指令中需要调用另一个类的方法，而这个类还没有加载，就找不到具体的方法在哪里，但是我可以使用“字符串描述”先表示一下我要调用这个方法。这个表示方式就是使用符号引用。 直接引用：直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有直接引用，那引用的目标必须已经在内存中存在。 ​ 同样，虚拟机并没有说确定在哪一个时间对符号引用进行解析，但是在遇到anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic指令之前，会先对他们使用的符号引用进行解析。 ​ 对于上面的除invokedynamic之外的15个指令，虚拟机会对第一次解析结果进行缓存，后面再一个实体中，后续的引用解析请求就使用缓存的结果，成功或失败。 ​ 解析的动作主要针对 类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfactMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandler_info、CONSTANT_InvokeDynamicinfo 7 种常量类型。 1、类或接口解析 假如类 A 中有符号引用 N 需要解析为类 B 的直接引用，则具体解析步骤为： 类 B 不是数组类型，虚拟机就会把代表 N 的全限定名传给 D 的类加载器去加载 B。 类 B 是数组类型，那么它的描述符就是[Ljava/lang/Object形式，虚拟机就会按 1. 的方式去加载 B 的元素类型，接着虚拟机就会生成一个代表此数组维度和元素的数组对象。 如果上面解析成功，B在虚拟机中实际就已经是有效的了，解析结束之前，还需要进行上面验证阶段的符号引用验证，验证 A 是否对 B 有访问权限（如果B是private就没有访问权限）。 2、字段解析 要解析一个字段，首先解析它属于哪个类或接口（解析字段表中class_index对应的CONSTANT_Class_info常量字段），解析类或接口成功后，会进行如下步骤的解析： 如果所属类本身包含与之匹配的字段，就返回这个字段，查找结束。 如果类不包含该字段，但是所属类实现了一些接口，就按照实现顺序先去接口中查找是否有匹配的字段，如果有，就返回匹配的字段的直接引用，查找结束。 如果没有实现接口，但继承父类，就按照继承关系从上往下搜索父类是否有匹配字段，有则返回该字段的直接引用，查找结束。 以上都不符合的话，就找不到对应字段，抛出异常。 总结下来就是：先找自己类的，自己类没有，再找实现接口的，没有就继续找父类的，没有就真的没有了。 查找结束后，还需要进行权限验证，避免引用了不能引用的字段。 3、类方法解析 要解析一个类方法，首先也解析它属于哪个类（解析方法表中class_index对应的CONSTANT_Class_info常量字段），解析类或接口成功后，会进行如下步骤的解析： 如果解析class_index的结果是一个类，就直接抛出异常。 如果没有异常，则在方法所属类中查找是否有对应的方法，有则返回直接引用，查找结束。 如果类中没有对应方法，就在父类中查找是否有对应方法，有则返回直接引用，查找结束。 如果父类中也没有，就去父类实现的接口中查找是否有对应方法，如果有则说明该方法所属类是抽象类（接口方法都是抽象方法），查找结束，抛出异常。 如果都没有对应方法，那就真的没有对应方法了，抛出NoSuchMethodError异常。 如果查找到了对应方法，进行权限验证，避免出现引用了不能引用的方法。 4、接口方法解析 要解析一个接口方法，首先也解析它属于哪个接口（解析接口方法表中class_index对应的CONSTANT_Class_info常量字段），解析接口成功后，会进行如下步骤的解析： 如果发现解析class_index是一个类，就直接抛出异常。 如果没有异常，则在方法所属接口中查找是否有对应的方法，有则返回直接引用，查找结束。 如果接口中没有对应方法，就在父接口中查找是否有对应方法，直到连Object类都查找完了，有则返回直接引用，查找结束。 如果都没有对应方法，那就真的没有对应方法了，抛出NoSuchMethodError异常。 接口中方法都是 public 的，所以不需要权限验证，找到了就可以直接用了。 5. 初始化 在准备阶段，变量已经复制过一次初始值（零值），而在初始化阶段，就是根据程序员的设置去初始化类变量或其他资源的值了。 ​ 对于一个类的初始化阶段，虚拟机会在下面 5 种情况下立即初始化，当然在初始化之前，加载、验证、准备等阶段已经开始过了。 5 种情况： 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时，会立即对该类初始化，当然前提是该类还没被初始化过。这四条指令对应源代码中的场景如下：new实例化对象、获取static变量、设置static变量、调用static方法。 使用java.lang.reflect包下的方法对类进行反射调用时，如果累没初始化，就先对其初始化，才能进行反射调用。例如反射中的 forName方法 获取类的Class对象。 初始化一个类时，如果父类还没被初始化，就先初始化其父类。所以Object是最先初始化的类。 虚拟机启动时，会先初始化用户指定的主类，即包含main方法的那个类。 当时用JDK1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则要对其进行初始化。 上面这 5 种情况都是对一个类进行主动引用，除这 5 种场景以外的其他引用（被动引用）都不会触发类的初始化。 被动引用举例： 实例一：通过子类引用父类的static字段，不会触发子类初始化 12345678910111213141516171819202122232425262728/** * 对于子类subClass来说，对其的引用是被动引用（不属于上述5种情况） */class superClass &#123; static &#123; System.out.println("SuperClass init..."); &#125; public static int value = 123;&#125;class subClass extends superClass &#123; static &#123; System.out.println("SubClass init..."); &#125;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(subClass.value); &#125;&#125;//实验结果SuperClass init...123 /** * 解释说明：对于static字段的调用，只有直接定义该static字段的类才会触发初始化。 * 子类调用父类的static字段，只会触发父类的初始化而不会触发子类初始化。 */ 实例二：通过数组定义来引用类，不会触发此类的初始化 12345678910111213141516171819202122package com.test;class superClass &#123; static &#123; System.out.println("SuperClass init..."); &#125; public static int value = 123;&#125;class subClass extends superClass &#123; static &#123; System.out.println("SubClass init..."); &#125;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; superClass[] sca = new superClass[10]; &#125;&#125;//实验结果为空，什么都没输出。/** * 解释说明：对数组的定义引用类，没有触发superClass类的初始化，但是触发了另一个类[com/test/superClass类的初始化，这个类是虚拟机自动生成的，直接继承自Object类，该类的创建是由newarray字节码指令触发的。 */ 实例三：引用类中定义的常量时，是不会触发定义该常量的类的初始化的。 1234567891011121314151617class ConstClass &#123; static &#123; System.out.println("ConstClass init..."); &#125; public static final String HELLOCONST = "Hello const";&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLOCONST); &#125;&#125;//实验结果：Hello const/** * 解释说明：常量在编译阶段会存入调用类的常量池中，本例中，常量HELLOCONST在编译时期就已经存到test类的常量池中，test类中对HELLOCONST常量的引用，实际上都是对本类常量池中的常量引用。所以是不会触发ConstClass类的初始化的。 */ 初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是编译期自动收集类中所有 static变量 和 static{}代码块组合而成的方法，收集顺序和源码中顺序一致，所以static{}中只能访问之前定义的static变量，对于static{}之后定义的变量，虽然可以赋值，但是不能访问。 类构造器&lt;clinit&gt;()方法与 实例构造器&lt;init&gt;()方法不同，它不会显示调用父类的类构造器，也就是可以保证在当前类的&lt;clinit&gt;()方法执行之前，其父类的&lt;clinit&gt;()方法已经执行过了。 因为父类的&lt;clinit&gt;()方法先执行，所以父类的static{}块中代码先执行，父类static变量也会先进行赋值操作。 如果一个类没有static变量和static{}代码块，那么这个类可以没有&lt;clinit&gt;()方法。 接口中没有static{}块，但仍然有变量初始化的赋值操作，所以接口中也有&lt;clinit&gt;()方法，但是接口执行&lt;clinit&gt;()方法并不要首先去执行父接口的&lt;clinit&gt;()方法。只有父接口中的变量使用时，父接口才会调用&lt;clinit&gt;()方法初始化。接口实现类初始化时也不会先执行接口的&lt;clinit&gt;()方法。 一个类的&lt;clinit&gt;()方法会在多线程环境中进行同步，也就是如果多个线程都需要初始化该类，那么只会有一个线程执行该&lt;clinit&gt;()方法，其余线程阻塞等待，知道&lt;clinit&gt;()方法执行完毕。 三、类加载器1. 类加载器概述 类加载器只用于实现类的加载动作。 对于任意一个类，它的唯一性就是由这个类和加载它的类加载器确认的，每一个类加载器都有一个独立的类名称空间。比如对于同一个Class类文件，由两个不同的类加载器加载出来的两个类，就不是相等的，由一个类实例化出的对象，是不属于另一个类的。 对于两个类的“相等”比较，可以通过Class对象的equals()、isAssignableFrom()、isInstance()方法来比较，同样instanceof关键字也可以判定。 举例说明不同类加载器加载同一个类文件是不同的(instanceof方式)： 123456789101112131415161718192021222324252627282930313233package jvmTest01;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception &#123; //自定义加载类myLoader，通过覆写loadClass方法 ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; //使用自定义类加载器加载类并实例化对象 Object object = myLoader.loadClass("jvmTest01.ClassLoaderTest").newInstance(); System.out.println(object.getClass()); //将实例化对象判断是否属于系统默认的应用程序加载器加载的类 System.out.println(object instanceof ClassLoaderTest); &#125;&#125; 实验结果： 1234D:\java\jdk\bin\java.exe ...class jvmTest01.ClassLoaderTestfalseProcess finished with exit code 0 2. 双亲委派模型对虚拟机来说，只有两种类加载器： 启动类加载器：C++语言实现，是虚拟机的一部分。 其他类加载器：java语言实现，都继承自java.lang.ClassLoader类。 对程序员来说，有 4 种类加载器，其中有 3 中系统提供的： 启动类加载器（Bootstrap ClassLoader）：也叫引导类加载器。该类加载器负责将&lt;JAVA_HOME&gt;\lib目录或被-Xbootclasspath参数指定的路径中的类库加载到虚拟机内存。开发者不能直接使用启动类加载器，自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：该类加载器负责加载&lt;JAVA_HOME&gt;\lib\ext目录或者被java.ext.dirs变量指定的路径的类库。开发者可直接使用扩展类加载器。 应用程序类加载器（Application Classloader）：一般也成为系统类加载器。负责加载用户类路径（ClassPath）上指定类库，开发者可直接使用该类加载器。该加载器是默认的类加载器。 自定义类加载器（UserClassLoader）：该类加载器是由用户自定义的。 上面的层次关系又成为双亲委派模型。双亲委派模型要求除了最顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器，然而这里的父类子类关系不是用继承实现的，而是用组合关系来复用父加载器的代码。 双亲委派模型工作过程： 如果一个类加载器收到了一个类加载请求，它暂时不会自己处理，而是先去委派给父类加载器处理，父类加载器也是这样委派给它的父类加载器…，这样到最后，这个请求会交由启动类加载器处理，因为他是顶层，没有父类加载器了。 如果父类加载器处理不了这个请求，子类加载器才会尝试自己处理这个请求去加载类。 为什么要这样工作呢？ 这种关系可以保证系统的稳定，并且一个类和它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object存放在rt.jar中，是由启动类加载器加载的。如果用户也编写了一个java.lang.Object，并放在程序 ClassPath 中，那么系统将会有多个不同的Object类，这样调用 Object 就不是最基础的那个 Object 类了。 而使用双亲委派机制，可以保证每个程序加载的 Object 都是启动类加载的那个。 双亲委派模型的实现： 先检查类是否已被加载，如果没有，则调用父类加载器的 loadClass()方法，如果父类加载器为空，则默认使用启动类记载器作为父类加载器。 如果父类加载失败，抛出ClassNotFoundException异常后，子类加载器再调用自己的findClass()方法加载。]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之TreeMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaTreeMap%2F</url>
    <content type="text"><![CDATA[一、TreeMap概述 因为TreeMap的通过多重继承 SortedMap 接口，所以有序 底层数据结构：红黑树。查询时间复杂度 log(n)。 TreeMap是 线程不安全 的。 TreeMap有两种方式对key进行比较，从而实现排序效果： 自然排序：通过key 实现Comparable接口，覆写compareTo方法进行比较。 比较器排序：通过Comparator对象来进行排序。 注意： 如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，使用key实现了Comparable接口的compareTo(T o)方法来比较。 如果使用的是compareTo(Object o)方法来比较，key一定是不能为null(空指针异常)，并且key得实现了Comparable接口的。 即使是传入了Comparator对象，不用compareTo(T o)方法来比较，key也是不能为null的。 TreeMap内部节点类： 1234567891011121314151617181920212223/** * 实现的Map的Entry接口 */static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; &#125; 二、TreeMap的属性12345678910111213141516171819/*** comparator变量决定使用什么排序方式，为null表示自然排序*/private final Comparator&lt;? super K&gt; comparator;/*** 红黑树的根节点root*/private transient Entry&lt;K,V&gt; root;/*** TreeMap元素个数*/private transient int size = 0;/*** 结构性修改次数，用于快速失败机制。*/private transient int modCount = 0; 三、构造方法1234567891011121314151617181920212223242526272829303132/*** 无参构造方法，设置排序方式为自然排序*/public TreeMap() &#123; comparator = null;&#125;/*** 指定排序方式的构造方法*/public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125;/*** 指定Map作为参数的构造方式，默认自然排序。putAll方法将参数Map中所有元素添加到TreeMap中*/public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;/*** 指定SortedMap作为参数的构造方式。*/public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; //使用SortedMap的比较方式 comparator = m.comparator(); try &#123; //该方法将SortedMap中元素添加到TreeMap中 buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125;catch (ClassNotFoundException cannotHappen) &#123;&#125;&#125; 四、常用方法1、put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 向TreeMap中添加元素*/public V put(K key, V value) &#123; //如果红黑树为空，就创建红黑树 Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); //检查key合法性（如key是否为空） //树为空，添将加的key作为根节点root root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; //临时父节点 Comparator&lt;? super K&gt; cpr = comparator; //比较器排序方式 if (cpr != null) &#123; //循环判断待插入节点key与当前遍历节点key大小，并选择左子树还是右子树 do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); //自然排序方式 &#125;else &#123; //判断key不能为null if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") //自然排序方式待排序的对象必须已经实现过Cpmparable接口 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //循环判断待插入节点key与当前遍历节点key大小，并选择左子树还是右子树 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; //调整红黑树，使其平衡 fixAfterInsertion(e); size++; modCount++; return null;&#125; 2、get方法12345678910111213141516171819202122232425262728293031/*** 根据key获取value，调用getEntry方法具体实现*/public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125;/*** 具体实现的get方法，来获取key对应的节点*/final Entry&lt;K,V&gt; getEntry(Object key) &#123; //比较器排序调用的是getEntryUsingComparator方法 if (comparator != null) return getEntryUsingComparator(key); //自然排序，获取key对应的Entry节点，如果没有，则返回null。 if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之LinkedHashMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaLinkedHashMap%2F</url>
    <content type="text"><![CDATA[一、LinkedHashMap概述底层数据结构：哈希表 + 双向链表 双向链表作用： 记录HashMap数据的顺序。而顺序又有两种： 维护插入顺序。 维护访问顺序。 注意： LinkedHashMap继承了HashMap类，所以它的大多数方法都使用的HashMap的方法，或者在其上进行拓展。 LinkedHashMap的多数方法都是需要增加额外的对双向链表的操作，如新增、删除等。 就连LinkedHashMap的内部节点类也是继承的HashMap.Node类。 节点内部类结构： 1234567891011121314/** * 继承父类HashMap的内部子类Node * 在Node基础上并添加了before，after两个节点，分别指向前一个节点和后一个节点 */static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;/** * LinkedHashMap给每个节点都设置了before指针和after指针 * 每次添加一个元素，除了将它添加进HashMap表中，还额外将它按照accessOrder指定的顺序添加进双向链表的表尾。 */ 上图： 解释：如果去掉了绿线和黄线，正好就是HashMap的结构了。而那些绿线和黄线就连接了节点，组成了双向链表。其中维护了一个头结点（右上角）。 二、LinkedHashMap属性12345678910111213//这里只列出了新添加的属性。此外还有很多从HashMap继承来的属性（loadFactory、threshold等）/** * 表示双向链表头节点元素 */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * 表示双向链表尾节点元素 */transient LinkedHashMap.Entry&lt;K,V&gt; tail;/** * 表示顺序标识，为true按照访问顺序迭代，为false按照插入顺序迭代，默认为false */final boolean accessOrder; 三、构造方法12345678/** * 共有5种构造方法，其中有四种和HashMap一样，而accessOrder使用的是默认false * 第 5种构造方法是指定accessOrder的构造方法 */public LinkedHashMap(int initicalCapacity,float loadFactor,boolean accessOrder)&#123; super(initicalCapacity,loadFactor); this.accessOrder = accessOrder;&#125; 注意：与HashMap一样，initicalCapacity和loadFactor两个属性都对LinkedHashMap有很大的影响。 四、常用方法1. reinitialize初始化方法1234567/*** 初始化LinkedHashMap，调用HashMap的该方法，初始化头结点尾节点*/void reinitialize() &#123; super.reinitialize(); head = tail = null;&#125; 2. newNode方法123456789/*** 添加新节点，为Entry节点。该方法覆写了HashMap中的newNode方法，并在其中添加了双向链表操作*/Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); //将新建的Entry插入到链表尾部 linkNodeLast(p); return p;&#125; 注意： LinkedHashMap的put方法是继承HashMap的方法，但是其中调用的newNode方法是新覆写的方法。所以在LinkedHashMap直接通过newNode中的操作来实现对双向链表顺序的操作，并不需要再在put方法中做其他修改。 3. get方法123456789101112131415161718192021222324252627282930313233343536373839404142/*** 根据key值的hashCode来获取节点，调用HashMap的getNode方法*/public V get(Object key) &#123; Node&lt;K,V&gt; e; //如果没有找到key对应节点，返回null if ((e = getNode(hash(key), key)) == null)&#123; return null; &#125; //如果是accessOrder是访问顺序，把节点插入到链表尾部 if (accessOrder)&#123; afterNodeAccess(e); &#125; return e.value;&#125;/*** 由于添加进哈希表后还需要维护进双向链表中，所以要将节点放到指定的顺序的尾部*/void afterNodeAccess(Node&lt;K,V&gt; e) &#123; Entry&lt;K,V&gt; last; //如果维护的顺序是访问顺序，并且双向链表的尾节点不是e,就将e添加到链表尾部 if (accessOrder &amp;&amp; (last = tail) != e) &#123; Entry&lt;K,V&gt; p = (Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else&#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之HashMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaHashMap%2F</url>
    <content type="text"><![CDATA[HashMap特点： 元素无序 key不允许重复，key只可以存在一个为null（因为不允许重复，所以不允许存在多个key为null） HashMap底层数据结构： 哈希表（链地址法的哈希表，数组 + 链表），jdk1.8增加了红黑树。 HashMap内部节点类：用来存储key-value对 123456789101112131415161718192021222324252627//实现的Map中的Entry接口static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 一、HashMap属性12345678910111213141516171819202122232425262728293031323334353637383940414243/*** HashMap的默认初始容量，16*/static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //移位操作效率高/*** HashMap的最大容量 2^30*/static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/*** 默认负载因子 0.75，用来判断何时对map进行扩容*/static final float DEFAULT_LOAD_FACTOR = 0.75f;/*** 标识添加元素时链表长度超过 8 就可以转换为红黑树*/static final int TREEIFY_THRESHOLD = 8;/*** 标识移除元素时，红黑树元素少于 6 就转换为链表（前提是红黑树）*/static final int UNTREEIFY_THRESHOLD = 6;/*** Map中的 key-value 对的个数*/transient int size;/*** HashMap的阈值，当table为空时，该阈值为初始容量16，当table被填充后，阈值变为 capacity * loadFactor（16 * 0.75），HashMap进行扩容时会参考阈值的值。当size超过阈值，容量就扩容为原来的2倍。*/int threshold;/*** 负载因子*/final float loadFactor;/*** 标识只有表元素个数大于该值64时，才符合转变为红黑树的条件*/static final int MIN_TREEIFY_CAPACITY = 64; 二、构造方法1234567891011121314151617181920212223242526272829303132/*** 指定初始化容量和负载因子的构造方法*/public HashMap(int initialCapacity, float loadFactor) &#123; /*验证参数是否合法的代码...(省略)*/ this.loadFactor = loadFactor; //tableSizeFor返回的是大于参数initialCapacity且是2的整数次幂的值，此处将threshold赋值为2的整数次幂。这是一次初始化，创建哈希表会重新对threshold进行赋值。 this.threshold = tableSizeFor(initialCapacity);&#125;/*** 指定初始化容量的构造方法，负载因子为默认*/public HashMap(int initialCapacity) &#123; //调用的第一个构造方法，传入的负载因子是默认的0.75 this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/*** 无参构造方法，默认初始容量16和负载因子0.75*/public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;/*** 以另一个Map作为参数的构造方法，默认的负载因子0.75，初始化容量为参数Map容量*/public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 注意：上面的构造方法中，对哈希表进行初始化时，实际上并没有为哈希表分配内存空间，在这里只是表示一下需要多少空间而已。而且内部节点数组暂时也只是为空。实际上在put方法第一次执行时，才会为哈希表分配内存空间。 三、常用方法1、put方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*** 添加key-value键值对到HashMap中*/public V put(K key, V value) &#123; //实际put的具体操作是在putVal方法中 return putVal(hash(key), key, value, false, true);&#125;/*** 根据传入的key计算key的hash值*/static final int hash(Object key) &#123; int h; //如果key为null，则返回的hash值为 0 //key不为null时，计算hash值时将key的hashCode低16位与高16位做异或运算，增加了hash值得随机性，减少哈希碰撞，散列更加均匀（让32位的hashcode的所有位都参与运算） return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/*** 实际将key-value键值对插入map中的方法*/final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; //临时表 Node&lt;K,V&gt; p; //临时节点 int n, i; //临时变量 //如果插入前哈希表为空，则调用resize方法初始化哈希表 if ((tab = table) == null || (n = tab.length) == 0)&#123; n = (tab = resize()).length; &#125; //通过hash值计算出来的数组下标位置元素为空，表示没有发生碰撞，就将该key-value插入到该位置 //计算下标位置是通过key的hash值和哈希表数组长度与运算得出（(n-1)&amp;hash） if ((p = tab[i = (n - 1) &amp; hash]) == null) &#123; tab[i] = newNode(hash, key, value, null); &#125; else &#123; //要插入的位置已有元素，发生了哈希碰撞 Node&lt;K,V&gt; e; K k; //先判断数组上的元素与待插元素的关系，如果待插元素和数组上该位置元素的hash值和key相等，就表示应该对该位置的元素进行更新 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; //这里只是暂时获取该元素，实际的更新操作在后面 no.61 行 e = p; &#125; //如果该位置上是红黑树结构，调用红黑树的插入元素方法 else if (p instanceof TreeNode)&#123; e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125; //该位置是链表结构 else &#123; //遍历链表，检查链表是否已存在该key for (int binCount = 0; ; ++binCount) &#123; //如果p.next==null则到达了尾部，进行插入操作，如果链表过长就转换为红黑树 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; //如果p.next!=null则对比该位置的key和待插key，如果相同就更新该位置的value if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; break; &#125; p = e; &#125; &#125; //如果表中已存在该key，则就将key的value进行更新为新值。并返回原来的value值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //如果表中元素个数超过阈值，就调用resize方法进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 2、resize方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * map的扩容方法。在map初始化的时候需要调用resize方法，元素个数超过阈值也需要调用resize方法。 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//原容量 int oldThr = threshold;//原阈值 int newCap, newThr = 0; //如果原表不为空，即oldCaoacity &gt; 0 if (oldCap &gt; 0) &#123; //判断原容量是否合法 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //没有扩容后的容量合法，并且原容量超过了默认容量16，则容量扩充为原来的2倍，阈值也扩充为原来的2倍 else if((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123; newThr = oldThr &lt;&lt; 1; &#125; //如果原表为空，但原表阈值不为0，将容量设置为旧阈值的值（产生这种现象原因可能是将元素全部删除了） &#125;else if (oldThr &gt; 0)&#123; newCap = oldThr; &#125; //如果原表为空，且阈值为0，就表示这是新创建的表，就将容量和阈值都设置为默认值 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新阈值，并判断值是否合理 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //压制警告 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//创建容量为新容量的新表 table = newTab; //将旧表元素复制到新表中 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null)&#123; //计算下标位置，并插入元素 newTab[e.hash &amp; (newCap - 1)] = e; &#125; //红黑树 else if (e instanceof TreeNode) &#123; ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); &#125; //链表，由于表的容量扩大 2倍，所以(capaticy-1)&amp;hash 获得的下标值就可能发生改变，注意这里只是可能发生改变。对于元素位置如果在新表位置和旧表位置相同就直接插入，否则进行重哈希。 //由于容量扩大为 2倍，所以(capacity-1)就多了一位，例如原来capacity为16时，就计算4位&amp;（1111），现在扩容后capacity为32，就要计算5位&amp;（11111），就根据key的hash值多一位的那一位来判断其下标有没有改变，若为0，位置就不变，若为1，就进行重哈希。 else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //元素插入到新表原位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //元素插入到新表的：原位置+oldCapacity if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 3、get方法123456789101112131415161718192021222324252627282930313233343536/*** 根据key查找map是否包含该键值对，包含则返回value，不包含则返回null*/public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/*** 获取key对应的node,没有返回null*/final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //通过key计算hash值来确定key对应的数组下标，判断该位置的链表头结点是否符合 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return first; &#125; if ((e = first.next) != null) &#123; //如果是红黑树结构，通过红黑树来查找 if (first instanceof TreeNode)&#123; return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); &#125; //否则是链表结构，遍历链表，找出符合目标的key-value do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return e; &#125; &#125; while ((e = e.next) != null); &#125; &#125; //如果链表中没有对应的key-value对，最终返回null return null;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之LinkedList]]></title>
    <url>%2F2019%2F02%2F25%2FjavaLinkedList%2F</url>
    <content type="text"><![CDATA[注意：LinkedList底层数据结构是双向链表，还实现了Deque接口，可作为Queue和Stack使用。 12345678910111213/*** 内部节点类，作为双向链表的节点。*/private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 一、LinkedList属性123456789101112/*** 链表中元素节点的个数。*/transient int size = 0;/*** 双向链表的头节点*/transient Node&lt;E&gt; first;/*** 双向链表的尾节点*/transient Node&lt;E&gt; last; 二、LinkedList构造方法123456789101112/*** 无参构造方法，啥也没有*/public LinkedList() &#123;&#125;/*** 集合作为参数的构造方法*/public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 三、常用方法1. add方法1234567891011121314151617181920public boolean add(E e)&#123; linkLast(e); return true;&#125;/** * 操作双向链表，将元素插入到双向链表尾部 */void linkLast(E e)&#123; final Node&lt;E&gt; l = last; //构造新节点，值为e,上一个节点指向链表 last final Node&lt;E&gt; newNode = new Node&lt;&gt;(l,e,null); last = newNode; //如果链表为空，将这个节点作为链表头 fitst if(l == null) &#123; first = newNode; //链表不为空，设置链表的尾节点的next为插入的节点e &#125; esle &#123; l.next = newNode; &#125;&#125; 2、remove方法12345678910111213141516171819202122/** * remove:删除指定的节点方法 */public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; //即双向链表删除节点操作的具体实现。 unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 3、set方法1234567891011121314151617181920212223242526272829/** * 修改指定的下标index元素值，并返回该index的原来的元素值 */public E set(int index, E element) &#123; //检查index下标是否正确 checkElementIndex(index); //该node方法会返回index对应的节点。不过其内部会自动进行选择从表头遍历还是从表尾遍历的方式，实际就是判断index靠近表头还是靠近表尾。 Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;/*** node:返回index下标对应的节点*/Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之ArrayList]]></title>
    <url>%2F2019%2F02%2F25%2FjavaArrayList%2F</url>
    <content type="text"><![CDATA[一、ArrayList属性1234567891011121314151617181920/*** 默认初始容量为 10，不过初始化的时候实际容量仍然为0。*/private static final int DEFAULT_CAPACITY = 10;/*** 标识一个空数组。ArrayList的底层数据结构就是数组。*/private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 标识一个默认容量10的数组（根据对象名可知），但初始化时仍然是空数组。*/private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** 该数组就是底层用来存放数据的数组。*/transient Object[] elementData; /*** 标识该集合中实际存储的元素个数，注意和容量区分开来*/private int size; 二、ArrayList的三种构造方法12345678910111213141516171819202122232425262728293031/*** 第一种指定容量的构造方法。数组初始化为指定的容量。如果初始化参数&gt;0，就初始化容量为initialCapacity的数组，如果初始化参数=0，就将数组初始化为空数组。如果容量 &lt; 0，就抛出异常。*/public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity); &#125;&#125;/*** 无指定容量的构造方法，默认是代表容量为10的空数组。但是ArrayList初始化时并非直接初始化为容量为10的数组，而是用一个空数组标记容量为10的数组。实际上初始化为容量10的数组是在列表天机第一个元素才开始的。*/public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/*** 指定集合作为元素的构造方法。将指定集合的元素添加进ArrayList中。*/public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; //如果指定集合为空，就将数组初始化为空数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 三、常用方法1. add方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** add:向集合中添加元素。注意，如果采用的无参构造方法，那么实际初始化是从这里开始的。*/public boolean add(E e) &#123; //确保添加一个元素后元素个数没有（数组容量是否能容纳元素，是否需要扩容）。 ensureCapacityInternal(size + 1); elementData[size++] = e;//添加元素，并将元素个数 加1 return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //如果数组elementData还是空数组，就表示第一次添加元素，需要取默认容量10和传入参数(添加元素后的容量)之间的较大值作为初始化容量。比如，第一次添加元素，传入的minCapacity为1，DEFAULT_CAPACITY为10，所以就将容量设为10。 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //判断是否需要扩容 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //如果初始化容量大于当前数组长度(即最大容量)，就需要进行扩容。比如，上面是第11次添加元素，传入的11和10比较，minCapacity设为11，此时元素个数大于容量，需要扩容之后才能装得下元素。 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/*** grow:扩容方法*/private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //新容量扩容为原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果扩容后的1.5倍容量仍然小于添加元素后的容量，则最终容量定为添加元素后的容量。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果扩容后的容量超过了数组限定的最大值，那就是用最大的容量（hugeCapacity源码就不分析了） if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制原数组的内容到扩容后的新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/*** 向集合中指定位置添加元素*/public void add(int index, E element) &#123; rangeCheckForAdd(index); //找到下标index ensureCapacityInternal(size + 1); //验证元素个数是否超过容量 System.arraycopy(elementData, index, elementData, index + 1,size - index); //下标后的元素后移 elementData[index] = element; //指定下标插入元素 size++;&#125; 2、get方法12345public E get(int index) &#123; rangeCheck(index); //检查下标是否符合要求 checkForComodification(); return ArrayList.this.elementData(offset + index); //返回对应下标的元素&#125; 四、注意 ArrayList是基于动态数组实现的，在增删时候（指定下标增删），需要对数组进行复制移动arrayCopy（下标元素后移前移等）。 ArrayList的默认初始化容量是10，每次扩容时先扩容为原容量的1.5倍。 删除元素时不会减少容量（只删除元素），若同时需要减少容量则调用trimToSize()。 ArrayList不是线程安全的。比如遍历元素时不能进行添加操作。 ArrayList可以存放null值。 五、ArrayList与Vector的区别 Vector线程安全，方法都是用synchronized修饰。ArrayList实现同步可使用Collections类的List list = Collections.synchronizedList(new ArrayList(...));方法。 ArrayList底层数组扩容一般为原容量的1.5倍，Vector扩容为原容量的2倍。]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm Class类文件结构]]></title>
    <url>%2F2019%2F02%2F23%2FjvmClassFile%2F</url>
    <content type="text"><![CDATA[一、概述 Class文件存储的都是二进制流(0和1)，每8 位为一组，每个数据项严格按照顺序进行排列，数据项之间没有添加任何分隔符，所以整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。通俗来讲，Class文件中有哪些东西，哪个位置存放哪些东西，以及数据项的顺序都是规定好的。 Class文件数据类型：无符号数和表。 无符号数：是基本的数据类型，无符号数用 u 表示：u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节长度的无符号数。这些无符号数数可以用来描述数字、索引引用、数量值或按照UTF-8编码构成的字符串值（注意这个）。 表：由多个无符号数或其他表作为数据项构成的复合数据类型，一般以”_info”结尾。整个class文件就是一张表，里面由无符号数+其他表组成 类型 名称 数量 u4 magic 魔数 1 u2 minor_version 小版本 1 u2 major_version 大版本 1 u2 constant_pool_count 常量池长度 1 cp_info constant_pool 常量池 constant_pool_count-1 常量个数 u2 access_flag 访问标志 1 u2 this_class 类索引 1 u2 super_class 父类索引 1 u2 interfaces_count 接口表长度 1 u2 interfaces 接口索引集合 interfaces_count 接口个数 u2 fields_count 字段表长度 1 field_info fields 字段表集合 fields_count 字段个数 u2 methods_count 方法表长度 1 method_info methods 方法表集合 methods_count 方法个数 u2 attributes_count 属性表长度 1 attribute_info attributes 属性表集合 attributes_count 属性个数 由以上可知，Class文件结构包含的内容就有：魔数、版本、常量池、访问标志、类索引、父类索引、接口索引集合、字段表、方法表、属性表，且顺序是固定的（暂且这么说）。 二、具体结构1. magic 魔数 Class文件的最初的 4 字节是魔数（值为0xCAFEBABE），唯一作用是来指明这个文件可以被 jvm 识别，换句话说，jvm只认识开头 4 字节为上述魔数的文件。 java 使用魔数识别文件，不使用文件扩展名(.class)识别文件。 2. xx_version 版本 紧接着魔数的 4 个字节表示class文件的版本号，5,6 字节表示次版本号，7,8 字节表示主版本号。 例如，主版本是从45 开始，JDK1.0对应 Class文件的主版本号为 45，JDK1.7主版本号为51。 注意： 高版本JDK可向上兼容低版本的Class文件，但不支持高版本的Class文件。如，一个class文件的版本号为50，则该文件只能被JDK1.6以上的虚拟机加载。 3. constant_pool 常量池（重要） 因为每个程序中常量池中的常量数量都是不固定的，所以有必要用一个无符号数来表示常量池中常量的个数，这个无符号数就是constant_pool_count（u2），在这个数之后的就是常量池。 常量池中的常量索引从 1 开始，例如，constant_pool_count值换算为十进制为 24 ，这表示常量池有 23 个常量，常量索引为 1~23。因为索引 0 来表示”不引用任何一个常量池项目”。 注意：常量池中的常量是在编译期就生成的，编译期根据源码生成的各种字面量和符号引用就保存在常量池中。 常量池中的内容：字面量 与 符号引用。 字面量：可认为 java 中的常量，如字符串常量、final声明的常量等。 符号引用：主要有以下三种 类和接口的全限定名：就是将源码中全限定名中的 . 改成了 / ,例如java.lang.Object在class文件中全限定名就是 java/lang/Object 字段名称和描述符（后文字段表有讲） 方法的名称和描述符（后文方法表有讲） 常量池中每一个常量都是表的结构，常量类型一共有 11 中，列表如下： 类型 标志 tag 描述 CONSTANT_Utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整型字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的部分符号引用 因为 11 中常量都是表类型，所以各自的结构也都不同。下面简单介绍几种常量的具体结构（其余的请自行Google吧）， CONSTANT_Utf8_info 项目 类型 描述 tag u1 标志位 length u2 表示utf-8字符串的长度多少字节 bytes u1 表示长度为length字节的数据就是实际的字串 CONSTANT_Integer_info（字面量） 项目 类型 描述 tag u1 标志位 bytes u4 表示接下来的4字节长度表示的就是int值 CONSTANT_CLASS_info（符号引用） 项目 类型 描述 tag u1 标志位 index u2 表示接下来2字节表示的值就是指向该池中的第index个常量 CONSTANT_Methodref_info（符号引用） 项目 类型 描述 tag u1 标志位 u2 指向方法属于的类常量的索引（指向CONSTANT_Class_info） index u2 指向方法的名称和类型描述符（指向CONSTANT_NameAndType_info） CONSTANT_Fieldref_info 项目 类型 描述 tag u1 标志位 index u2 指向字段属于的类常量的索引（指向CONSTANT_Class_info） index u2 指向字段的名称和类型描述符（指向CONSTANT_NameAndType_info） 举例分析，现有一个class文件如下，其中4个连续为 2字节。 12345678910111213//cafe babe 魔数，0000 0034 为版本号（0000次+0034主）//001f (u2)表示constant_pool_count，十进制为31，表示常量池中有30个常量。接下来的就是常量池，因为每个常量都是以tag开头，后面再加常量信息。//0a 十进制为 10,tag为10，属于CONSTANT_Methodref_info类型常量,接下来的u2 0006 十进制 6,表示指向常量池中的第6个常量（表示方法属于的类），再接下来的u2 0011 十进制17，表示指向常量池中的第17个常量（表示方法的名称和类型）。至此，第一个常量分析完毕。cafe babe 0000 0034 001f 0a00 0600 11 09//09 十进制为 9,tag为9，属于CONSTANT_Fieldref_info类型常量,接下来的u2 0012 十进制18,表示指向常量池第18个常量（表示字段属于的类），再接下来的u2 0013 十进制19,表示指向常量池第19个常量（表示字段的名称和类型）。至此第二个常量分析完毕。0012 0013 0a00 1400 150a 0005 0016 07001707 0018 0100 063c 696e 6974 3e01 00032829 5601 0004 436f 6465 0100 0f4c 696e654e 756d 6265 7254 6162 6c65 0100 03616464 0100 0528 4949 2949 0100 046d 61696e01 0016 285b 4c6a 6176 612f 6c61 6e672f53 7472 696e 673b 2956 0100 0a53 6f75//按上面的方法分析，最后分析出来全部的30个常量（我萎了）,要么表示具体的字串，要么表示指向其他常量的索引。 使用javap -v Hello可以得出Hello.class的字节码常量池内容，如下 1234567891011121314151617181920212223242526272829303132333435public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#17 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #18.#19 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #20.#21 // java/io/PrintStream.print:(J)V #4 = Methodref #5.#22 // Hello.add:(II)I #5 = Class #23 // Hello #6 = Class #24 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 add #12 = Utf8 (II)I #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 SourceFile #16 = Utf8 Hello.java #17 = NameAndType #7:#8 // "&lt;init&gt;":()V #18 = Class #25 // java/lang/System #19 = NameAndType #26:#27 // out:Ljava/io/PrintStream; #20 = Class #28 // java/io/PrintStream #21 = NameAndType #29:#30 // print:(J)V #22 = NameAndType #11:#12 // add:(II)I #23 = Utf8 Hello #24 = Utf8 java/lang/Object #25 = Utf8 java/lang/System #26 = Utf8 out #27 = Utf8 Ljava/io/PrintStream; #28 = Utf8 java/io/PrintStream #29 = Utf8 print #30 = Utf8 (J)V 对比我刚刚分析的1、2号常量看下： #1：分析得出CONSTANT_Methodref_info类型常量，有两个引用，分别是第 6 和第 17个常量。 javap 结果：#1 = Methodref #6.#17 #2：分析得出CONSTANT_Fieldref_info类型变量，有凉个引用，分别是第 18和第 19个常量。 javap 结果：#2 = Fieldref #18.#19 分析成功！ 4. 访问标志 常量池所有的常量分析完毕之后，接下来的 2 字节（u2）代表访问标志，用来识别一些类或接口层次的访问信息，包括：该Class是类还是接口、是否是public、是否是abstract、是否是final类等，具体如下： 标志名称 标志值(16进制) 含义 ACC_PUBLIC 0001 是否public类型 ACC_FINAL 0010 是否final类型（只表示类，接口没有） ACC_SUPER 0020 是否允许invokespecital字节码指令，默认为true ACC_INTERFACE 0200 标识是接口 ACC_ABSTRACT 0400 是否abstract类型，如果该值为true，则其他都为false，因为不共存 ACC_SYNTHETIC 1000 标识该类不是用户代码产生 ACC_ANNOTATION 2000 标识是注释 ACC_ENUM 4000 标识是枚举 例如，一个class文件的访问标志是0x0021,则表示它是public类型的类 0020 | 0001 = 0021。 5. this_class 类索引 类索引 用于确定类的全限定名。 类索引 是 u2 类型，引用的是常量池中的 CONSTANT_Class_info 类型常量。然后根据Class_info 常量中的NameAndTye的索引值，可以获得 CONSTANT_Utf8_info 变量表示的类全限定名。 6. super_class 父类索引 父类索引 用于确定父类的全限定名，由于单继承限制，所以父类索引只有一个（不像接口，有个集合），除了Object类外，每个java类都有父类（如果类没直接extends某个类的话，则其父类就是Object），所以出Object外，每个类的类索引都不为 0。 父类索引和类索引一样，也是 u2 类型，也是引用的常量池中的 CONSTANT_Class_info 类型常量。 7. interfaces 接口索引集合 接口索引集合 用来描述该类 implements 了哪些接口，这些接口在集合中的顺序与 implements顺序相同。 对于接口集合，入口的第一个 u2 数据（十进制）表示接口的个数，如果没接口，则该项 u2 为0000，索引表就为空，表示在Class表中没有接口集合。 接口索引集合中的每个接口都是 u2 类型的数据，都表示指向常量池中CONSTANT_Class_info 类型常量。 8. 字段表集合 接口索引集合之后，紧接着的 u2 类型数据表示类中字段的个数，之后就是具体的字段表。一个字段表集合中的每个字段都是一张表。 字段表 用于描述接口或类中声明的变量，包括static变量和实例变量，不包括方法中声明的局部变量。 字段表中的每个字段都包含有很多信息，例如字段访问修饰符(public,private等)，字段是否static，字段是否final，字段类型，字段名、字段是否有初始化等。前面的修饰符要么为true要么为false，可以使用访问标志来修饰，而字段类型、字段名都不是固定的，因此只能引用常量池中的常量描述。 字段表结构（每个字段都是这结构）： 类型 名称 数量 u2 access_flags 字段修饰符 u2 name_index 字段简单名称 u2 description_index 1 u2 attributes_count 1 attribute_info attributes attrubutes_count 个 access_flags：字段修饰符，就是字段的访问修饰符，public，private，static，final等等啥的。 标志名称 标志值（16进制） 描述 ACC_PUBLIC 0001 字段是否public ACC_PRIVATE 0002 字段是否private ACC_PROTECTED 0004 字段是否protected ACC_STATIC 0008 字段是否static ACC_FINAL 0010 字段是否final ACC_VOLATILE 0040 字段是否volatile ACC_TRANSIENT 0080 字段是否transient ACC_SYNTHETIC 1000 字段是否由编译期自动产生 ACC_ENUM 4000 字段是否enum name_index：对常量池的引用，代表字段的简单名称。 简单名称就是没有类型和参数修饰的方法或字段名称，例如字段int i;简单名称就是 i，方法int add(){}简单名称就是 add。 description_index：对常量池的引用，代表字段和方法的描述符 描述符是用来描述字段的数据类型、方法的参数列表（参数数量、类型、顺序）和方法返回值。 描述符规则（字段）： 八大基本类型和void类型：由一个大写字母表示。 | byte | char | double | float | int | long | short | boolen | void || —- | —- | —— | —– | —- | —- | —– | —— | —- || B | C | D | F | I | J | S | Z | V | 对象类型：用 L加对象全限定名表示。如 Ljava/lang/Object 数组类型：几维数组前面就加几个[，例如String[][],描述符就是[[Ljava/lang/String，int[]描述符就是[I 描述符规则（方法）：先参数列表后返回值的规则。 方法的参数列表由()表示，如果方法没有参数，参数描述符就只有一个()，如果方法有参数，参数描述符就是()里面包含参数类型。参数描述符后再加上返回类型描述符就是方法的全部描述符。 例如，方法Object index(char[] a,int b,int c,String[][] strs)的描述符为([cII[[Ljava/lang/String)Ljava/lang/Object。 attributes_count + attributes：字段的属性集合 并不是每个字段都有属性的，一般只进行声明的字段（未初始化），其属性表集合为空，如果进行初始化了，字段属性表就会有内容。 例如，final static int i = 123;字段其attributes_count 就为1，attributes就会有一个属性ConstantValue指向常量 123 。 注意：字段表中不包含从父类或接口中继承的字段。 9. 方法表集合 毋庸置疑，方法表集合包含了很多方法表，每个方法都是一张表。每个方法的表的结构都和字段表结构有很大的相似之处。 方法表结构（每个方法都是这结构）： 类型 名称 描述 u2 access_flags 方法修饰符 u2 name_index 方法简单名称 u2 description_index 字段和方法的描述符 u2 attributes_count 方法属性数量 attribute_info attributes 方法属性集合 access_flags：方法修饰符，这个与字段有一点点区别。 标志名称 标志值（16进制） 描述 ACC_PUBLIC 0001 方法是否public ACC_PRIVATE 0002 方法是否private ACC_PROTECTED 0004 方法是否protected ACC_STATIC 0008 方法是否static ACC_FINAL 0010 方法是否final ACC_SYNCHRONIZED 0020 方法是否synchronized ACC_BRIDGE 0040 方法是否是编译期产生的桥接方法 ACC_VARARGS 0080 方法是否接受不定参数 ACC_NATIVE 0100 方法是否是native方法 ACC_ABSTRACT 0400 方法是否为 abstract ACC_STRICT 0800 方法是否为 strictfp ACC_SYNTHETIC 1000 字段是否由编译期自动产生 name_index：对常量池的引用，代表方法的简单名称。（参照字段表） description_index：对常量池的引用，代表方法的描述符。（参照字段表） attributes_count + attributes：方法的属性集合 方法的方法体是由很多代码的，而这些代码都保存在attributes属性集中的Code属性中。 注意：方法表中不包含从父类继承的方法，对于父类方法，只会包含重写的父类方法。 10. 属性表集合 属性表示包含在字段或方法中(其他)的，单独拿出来讲，大概是因为它太大了… 因为属性不是单独存在的，需要有依附。且属性表的长度不同，不同属性结构也不一样 属性表结构： 类型 名称 u2 attribute_name_index 属性的名称索引 u2 attribute_length 该属性在文件中的长度 u1 info 属性的具体信息（不同属性该值不同） 虚拟机规范中定义了很多属性（不一一列举了），举一个 1. Code属性 java程序编译后，方法中的代码最终变为字节码指令存储在Code属性中。Code属性主要存在于方法表中的属性集合中（用来保存方法体中的代码），当然没有方法体的方法就没有Code属性了（接口方法、抽象方法）。 Code属性具体表结构： 类型 名称 描述 u2 attribute_name_index 属性名索引，指向常量池中常量 u4 attribute_length 属性长度 u2 max_stack 操作栈深度最大值 u2 max_locals 局部变量表所需空间 u4 code_length 字节码指令个数 u1 code 字节码指令 u2 exception_table_length 显示异常处理表长度 exception_info exception_table 显示异常处理表（可不存在） u2 attributes_count 属性个数 attribute_info attributes 属性表 参考： 《深入理解java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm内存区域]]></title>
    <url>%2F2019%2F02%2F22%2FjvmMemoryArea%2F</url>
    <content type="text"><![CDATA[一、运行时数据区概述： jvm执行程序时，会把它占有的内存分为一块块的区域，每个区域有不同的功能。就类似于国家分你一块地你用来造房子（我们从我们的16G 内存分几百MB给JVM），房子又分成了卧室（休息），客厅（..），洗手间（洗漱），厨房（做饭）等等区域。 而jvm内存区域具体分为： 线程独占区：每个线程都有各自的区域，区域的生命周期与线程相同 程序计数器 虚拟机栈 本地方法栈 线程共享区域：程序所有线程共享的一块区域 堆 方法区 1. 程序计数器 当前线程所执行的字节码的行号指示器。 ​ 啥是字节码？ jvm就是通过执行字节码指令来运行程序的（不知道可以这么理解吗），比如表示 + 的add指令，表示跳转的 goto 指令等。其中每个指令占一行，程序计数器就是指示运行的字节码指令的行号。比如 if语句，从15行跳转到19行，程序计数器就会从15变为19。 ​ 再试想，如果没有程序计数器记录字节码行号，一个CPU执行多线程程序，CPU对多个线程之间进行快速调度，如果当前线程执行到15行字节码，突然转换到另一个线程，等再次调度回来的时候，就接不上啦，GG。 作用： 字节码解释器通过改变程序计数器来依次读取指令，来实现代码的流程控制，如：顺序、选择、循环等。 在多线程下，程序计数器用于记录当前线程执行的位置，当线程被切换回来的时候能够知道上次运行的字节码位置。 注意： 如果执行的是 java 方法，程序计数器就指向字节码指令的地址。 如果执行的是 Native 方法，计数器为空（Undefined）。 程序计数器不会出现 OutOfMemoryError异常。 2. 虚拟机栈 虚拟机描述的是Java方法执行的内存模型。我们平常说的堆栈的栈就可以认为是虚拟机栈（中的局部变量表）。 ​ 每个方法被执行的时候都会创建一个栈帧，里面包含局部变量表、操作栈、动态链接、方法出口等。方法开始执行就对应栈帧入栈，执行完毕，对应栈帧出栈。 局部变量表： ​ 局部变量表存放了编译期可知的八种基本数据类型、对象引用和returnAddress类型（指向字节码指令的地址）。局部变量表的单位是slot(局部变量表空间)，除了 64位的 long和double会占用两个slot，其他类型都只占用一个slot。 注意： 局部变量表需要的空间在编译时期分配，不是运行期。运行期间不会改变局部变量表大小。 异常信息： StackOverflowError：线程请求栈深度大于虚拟机允许的深度。 OutOfMemoryError：虚拟机栈不够了，要申请额外内存，但是上头不分配了。 3. 本地方法栈 与虚拟机栈类似，不过本地方法栈是为 Native 方法服务的。也有栈帧啥的，也是栈帧入栈出栈。 4. 堆 最大的一块内存，在虚拟机启动时就创建好了堆，是所有线程共享的区域。仅用来存放对象实例，“几乎”所有的对象实例（包括数组对象）都在堆中创建。 ​ 由于堆用来存放对象实例的，如果对象死了，就要给它清理掉，释放堆中空间，所以堆还要经常进行GC（垃圾收集）。 ​ 又因为对象的生存时间不一样，有的死得快，有的老不死，所以有分为新生代（死得快）和老年代（老不死），分开来保存对象，这样GC时效率高一点，新生代需要经常GC，老年代偶尔GC，所以分代是为了更好地GC。 ​ 新生代又分为Eden 和两个Survivor区，空间大小比例 8:1:1，为什么需要这么划分请参考《jvm内存分配和垃圾收集》中的复制算法。为什么两个Survivor区请参考 新生代为什么分为一个Eden和两个Survivor 。 ​ java堆可以是物理上不连续的内存空间，但逻辑上要连续。java堆可动态扩展，通过 -Xmx和-Xms参数控制。 异常信息； OutOfMemoryError：堆中内存不够分配给对象，且堆的内存无法扩展增加时。 5. 方法区 方法区用于存储已被虚拟机加载的类信息、常量、static变量、即时编译期编译的代码等。 ​ 方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池： ​ 运行时常量池属于方法区。Class类文件结构中有一项常量池，用于存放编译期生成的各种字面量和符号引用，常量池的内容将在类加载后存放到方法区的运行时常量池中。 ​ 了解：Class文件中常量池还具有动态性，常量除了编译期产生外，还有可能在运行期间产生常量放入池中，例如String类的intern()方法。 异常信息： OutOfMemoryError：方法区内存不够，没法分配时。 二、直接内存（了解） 直接内存不属于上面说的运行时数据区，jvm规范中也没有对直接内存到底是哪块区域进行定义。 ​ NIO（New Input/Output）是一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接在堆外分配内存，java堆中有一个DirectByteBuffer对象引用了这块内存，所以可以通过该对象操作这块内存，可以避免在Java堆 和Native堆来回复制对象，提高效率。 ​ 因为也是内存，所以受本机总内存限制，如果仅仅设置了 -Xmx 参数来控制堆内存大小，而忽略了直接内存的设置，可能会导致直接内存+运行时数据区内存总和超过屋里内存限制，这样在动态扩展内存时因为超过物理内存限制发生 OutOfMemoryError 异常。 三、java堆中对象的创建、布局和访问1. 对象的创建创建对象的过程：类加载检查、分配内存、初始化零值、设置对象头、执行&lt;init&gt;方法 类加载检查：当我们用new关键字实例化对象时，最后到虚拟机执行的就变成 new 指令，虚拟机遇到一条 new 指令时，首先检查 new 指令的参数是否能在常量池中定位到这个类的符号引用，如果常量池中有符号引用，就检查这个符号引用的类是否已被加载、解析、初始化过。如果常量池没有该符号引用，那必须先将参数表示的类进行加载。 分配内存：对象需要的内存在经过类加载之后就可以确定，之后就在堆中划一块内存给这个对象，具体的划分内存的方式有两种： 指针碰撞：要求内存整齐，就是分配过对象的内存在一边，按照顺序分配。这样在最后一个对象尾部有一个指针，当要分配新对象时，就指针后移对象需要的距离分配给对象。 空闲列表：内存不是整齐的，使用过的和空闲的可能交错。虚拟机维护了一个”空闲列表”，列表上记录了空闲的内存区，当给对象分配内存，就从列表上找一块装得下该对象的内存给对象，同时将这块内存从列表中去掉。 思考：为什么有规整的和不规整的内存区域呢？因为和垃圾收集有关，有的内存经过垃圾收集之后内存是整齐的（复制算法、标记整理算法），有的收集之后就是不规整的（标记清除算法），详情参考我的《jvm内存分配与垃圾收集》一文。 （了解）如果涉及多线程分配内存呢？就是一个线程正在分配内存，指针还没开始移动，另一个线程就在原来的区域进行分配了，造成冲突。解决方式有两种： 同步处理：一个线程分配内存就上锁，别的线程不能同时分配。虚拟机采用CAS加失败重试方式更新。 TLAB(Thread Local Allocation Buffer)：本地线程分配缓冲。就是给每个线程在堆中先分配一块区域，线程在自己的内存区域给自己的对象分配内存。当有线程的TLAB用完了，继续向堆申请内存，就要采用同步的方式进行上锁了，不然其他的线程也要同时申请就又冲突了。 初始化零值：给对象分配内存后，jvm要将分配到的内存空间都初始化为零值，可以保证对象的实例字段在不赋初始值就直接使用，程序访问到的是这些字段的数据类型所对应的零值。（零值：如int是0，boolean是false，引用类型为null）。 设置对象头：之后要设置对象头，对象头包括对象是哪个类的实例、对象Hash值、对象GC的Age、类的元数据等。 执行&lt;init&gt;方法：经过以上步骤，对于虚拟机来说，一个新对象已经产生，但对java程序来说，对象创建才刚开始，因为所有字段还为零值，对象还没有根据程序员的意愿初始化。一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象初始化为程序员期望的值，这样一个真正可用的对象才算完全产生。 2. 对象的内存布局对象在内存中的布局分为三个区域：对象头、实例数据、对齐补充。 1. 对象头对象头包括两部分，第一部分是用于存储对象自身的运行时数据，另一部分是类型指针。 对象自身运行时数据：哈希吗、对象GC的Age、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。32bit/64bit（和虚拟机位数相同）。 类型指针：对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。32bit长度。 数组长度（可选）：如果对象是数组类型（String []），还需要32bit记录数组长度。 2. 实例数据 实例数据是对象真正存储的有效信息，即程序代码中定义的字段的实际值。 ​ 实例数据记录的数据包含父类继承下来的，自身定义的，子类定义的。而这几种数据的存储数据受虚拟机分配策略参数和字段在java源码中定义顺序影响。 3. 对齐补充 对齐补充没什么意义，只起占位符作用。 ​ 虚拟机要求对象的起始地址必须是8字节 的整数倍，即对象占的空间也得是8字节 的整数倍，因为对象头是8字节 的整数倍，实例数据大小不固定，所以需要对齐补充来补全实例数据为8字节的整数倍。 3. 对象的访问​ 我们知道具体对象是在堆中创建的，而我们的java程序是通过栈上的 reference 数据来引用具体对象。那么 reference 数据是怎么指向堆中的具体对象呢？ 访问对象的方式： 句柄访问：java堆中会划分出一块内存作为句柄池，句柄中保存的就是对象的实例数据（堆中）和类型数据（方法区中）具体地址。reference中存储的就是具体对象的句柄信息。 直接指针访问：直接指针方式就是reference中保存的就是对象在堆中的具体地址。而对象在方法区中的类型数据信息就由java堆去考虑。 两种方式比较： 使用句柄访问的话，对象被移动时（如垃圾收集中标记整理、复制算法对象的地址都会变动），只需要修改句柄中的地址，reference数据本身不需要变。 直接指针访问速度更快，不用先定位句柄，句柄在定位对象，节省一次定位时间。 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生代为何分为一个Eden区和两个Survivor区]]></title>
    <url>%2F2019%2F02%2F21%2FjvmYoungGenerationEdenAndDoubleSurvivor%2F</url>
    <content type="text"><![CDATA[问题：为什么新生代还要分为Eden区和两个Survivor区? 注意：新生代GC是对所有存放对象的区域进行垃圾收集，并不只是Eden区，因为Survivor区保留的存活对象 1、为什么要新生代要分区？ 新生代采用复制算法进行垃圾收集，复制算法是需要分区的，原本是 1:1 分，进行垃圾收集时，A区中的存活对象复制到B区中，并将A区格式化，下次存对象就存到B区，收集时也是从B区复制到A区，循环往复… 2、为什么分Eden区和Survivor区比例不同？ 新生代中的对象是比较多的，如果每次使用一半，空闲一半，浪费太严重，所以比例不同。 80% 的空间分给Eden区域，10%+10% 分别分给from Survivor和to Survivor区，Eden区用来给新对象分配空间，Survivor用来保留存活对象。 具体的 8:1:1 的比例是实验得出来的最优（当然不是我实验的）。 3、为什么不是一个Eden + 一个Survivor？ 如果只有Eden和一个Survivor空间的话，收集操作会产生碎片化。 举例：假设条件是Eden 80% + Survivor20%。新分配对象到Eden区，Eden满后，需要GC，将Eden区存活对象复制到Survivor，之后清理Eden区。接着又存对象到Eden区，再次满了需要GC，这次GC会将Eden区存活对象复制到Survivor区，但是Survivor也有死亡的对象需要回收，Survivor区存活的对象仍然保持原位置，Survivor中回收剩下的区域就变成碎片，因为复制算法不会自动整理空间。久而久之，内存碎片增多，造成资源浪费。 为什么每次GC完事不把Survivor区存活的对象再复制到Eden区？ 似乎挺有道理，但是一是再次复制效率比较低，二来就没法判断哪些对象什么时候可以晋升至老年代了。 4、一个80%的Eden加两个10%的Survivor试试？ 将新生代分为 Eden(80%) + From Survivor(10%) + To Survivor(10%)，注意：这里的From和To不是和某一块Survivor区绑定的，即这次From是第一块Survivor，下次From就变成了第二块Survivor了。 每次分配新对象还是分配到Eden区中，但是每次GC仍只使用Eden区和一块Survivor区。 第一次GC：首先分配内存给Eden区，Eden满后需要GC，将存活对象复制到一块Survivor中，然后清理Eden区域。 第二次GC：将Eden和上次使用的Survivor区中的存活对象复制到另一块空闲的Survivor区中，再统一清理Eden区和上次使用的Survivor区。咦，这次又变成一块空闲的Survivor区和一块正在使用的Survivor区了，似乎碎片的问题也解决了（因为复制的对象顺序排列） 第 3、4 … n 次GC：GC过程都和第二次一样。在Survivor中的对象每度过一次GC，对象的Age+1，等到了年龄阈值（默认15，可设置）就可晋升至老年代，当然还有其他方式晋升老年代（不阐述了，参考《jvm内存分配和垃圾收集》）。 问题似乎就这么不完美的讲通了…]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 内存分配与垃圾收集]]></title>
    <url>%2F2019%2F02%2F20%2FjvmGC%2F</url>
    <content type="text"><![CDATA[一、垃圾收集概述回收区域： 栈：栈中的栈帧根据方法的开始和结束来执行入栈和出栈的操作，而每个栈帧要分配的内存在类结构确定下来就可以确定了。方法或线程结束，栈帧内存就回收。 堆和方法区：堆中一个接口的多个实现类需要的内存可能不同，方法区中一个方法的多个分支需要的内存也不一样，程序运行期才知道创建哪些对象，所以堆和方法区的内存分配不是开始就确定的(动态的)，回收也是动态的。 二、判断对象是否存活 堆中几乎存放着java所有对象，垃圾收集器在回收前要先判断对象是否存活。 1. 引用计数算法 给对象添加一个引用计数器，每当有一个地方引用该对象，计数器加 1，解除引用，计数器减 1。任一时刻，只要计数器为 0 ，则认为该对象不再存活。 带来的问题： 对象之间循环引用问题。 例如， 123456789101112131415161718public class Test&#123; public Object instance = null; public static void main(String[] args)&#123; //通过new在堆中创建一个对象，暂且称为实例1,test1引用了实例1对象，则实例1的引用加 1。 Test test1 = new Test(); //又通过new在堆中创建一个对象，称为实例2,test2引用了实例2对象，则实例2的引用加 1。 Test test2 = new Test(); //test1的instance属性引用了test2，实际上引用的是test2指向的堆中的实例2对象，实例2的引用又加 1，此时实例2引用数为 2. test1.instance = test2; //test2的instance属性引用了test1，实际上引用的是test1指向的堆中的实例1对象，实例1的引用又加 1，此时实例1引用数为 2. test2.instance = test1; //test1引用置为空，即不指向实例1，实例1引用数减1，为 1. test1 = null; //test2同test1. test2 = null; &#125;&#125;//最终实例1 和实例2 的引用数都为1(instance属性对其的引用)，所以这两个实例对象都不会被回收。 2. 根搜索算法 通过一系列的名为”GC Roots”的对象作为起始点，从这些节点向下搜索，经过的路径称为引用链，若一个对象到GC Roots没有引用链(即从GC Roots开始无法到达该对象)，则对象不可用。 可作为GC Roots的对象： 虚拟机栈中引用的对象。 方法区中类静态属性(static)引用的对象。 方法区中常量(final)引用的对象。 本地方法栈(native方法)中引用的对象。 3. 引用的分类： 强引用：可理解为直接引用，Object obj = new Object();，对于这类引用，垃圾收集器永远不会回收new Object()创造出的实例对象。 软引用：描述一些还有用，但不是必须要的对象。如果系统将要发生内存溢出，这些被软引用关联的对象就会被列进回收范围等待被回收，如果回收之后还是内存溢出，就抛出异常。 弱引用：也是描述非必须要的对象，比软引用更弱。弱引用关联的对象只能生存到下一次垃圾收集之前，下次垃圾收集开始时，内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：没啥实际引用意义。虚引用唯一目的就是关联对象被垃圾收集之前能收到个”报信”。 4. 根搜索算法判定对象存活处死一个对象的过程： 两次标记 一次标记：从GC Roots节点无法到达该对象。进行第一次标记和一次筛选，筛选是通过该对象是否有必要执行finalize()方法进行筛选。如果对象没有finalize方法或finalize方法之前被jvm调用过了，则没必要执行finalize方法，对象GG。 二次标记：如果对象有必要执行finalize方法，则该对象就会被放在F-Queue队列（押往刑场的牢笼）中，jvm会建立一个Finalizer线程来执行对象的finalize方法。Finalizer线程执行而不是对象自己执行finalize方法的目的是：防止对象以各种借口延缓被执行死刑（死循环），而Finalizer线程不会等待对象finalize方法结束。在这短短的finalize方法执行期间，如果对象成功收买法官（将该对象自身this赋值给GC Roots引用链上的对象），则该对象就逃出牢笼，完成自救。 注意： 待处死的对象完成自救后，如果继续犯事被押赴刑场，那就必须被处决了，因为它无法在finalize方法中再次收买法官（任何一个对象的finalize方法都只会被执行一次）。 示例： 12345678910111213141516171819202122232425262728293031323334353637package jvmTest01;public class KillObject &#123; public static KillObject SAVE_HIMSELF = null; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("死刑对象被押赴刑场..."); //收买法官，完成自救(和GC Roots引用链上的对象绑定) KillObject.SAVE_HIMSELF = this; &#125; public static void main(String[] args) throws Throwable&#123; //new实例化的KillObject对象在 GC Roots引用链中 SAVE_HIMSELF = new KillObject(); //KillObject对象犯事，不在引用链中，要被处死 SAVE_HIMSELF = null; //gc方法执行包含对象标记的过程，也包含对象的finalize方法执行 System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; //KillObject对象屡教不改，再次犯事 SAVE_HIMSELF = null; System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; &#125;&#125; 运行结果： 123456D:\java\jdk\bin\java.exe 死刑对象被押赴刑场...死刑对象完成自救死刑对象被处死(被回收)Process finished with exit code 0 结果表明： 对象再次犯事，没有完成自救被回收。因为他无法再次通过执行finalize方法收买法官（finalize方法一个对象只能执行一次）。 三、垃圾收集算法1. 标记 - 清除算法 最基本的垃圾收集算法。 算法思想： 标记：标记出要回收的对象。就是标记出上一节中那些最终押赴刑场执行处死的对象。 清除：统一回收掉被标记对象。对要处死对象统一枪毙。 问题： 标记 - 清除效率低下。 清除后的对象产生小碎片，如果要分配大对象，还需要再次进行垃圾收集整合小碎片为大空间。 2. 复制算法 将可用内存划分为容量相等的两块，每次使用一块，使用的这块用完了，进行垃圾回收时，就将这块上的存活对象复制到另一块保留区域上，再将这块内存区域一次清理变成保留区域。 代价就是内存缩小为原来的一半。 回收新生代采用复制算法，并做了改进： 新生代的对象 98% 都是短命鬼，由于回收时存活对象很少，所以划分区域时，就不用按照1:1划分了，划分一小块区域暂存存活对象即可。 新生代划分对象是划分为一块大空间（Eden）和两块小空间（Survivor），每次使用Eden和一块Survivor空间。进行回收，只需要把Eden和Survivor空间上的存活对象复制到另一块Survivor空间，最后清理掉Eden和Survivor空间。默认Eden:Survivor:Survivor=8:1:1。所以浪费的空间只有 10%。 如果进行回收时，存活对象比Survivor空间大，复制过去装不下，则就需要向其他内存（例如老年代）进行暂借空间，这种机制称为分配担保（后续讲解）。 3. 标记 - 整理算法算法思想： 标记：标记出要回收的对象。标记方法同标记 - 清除算法。 整理：让所有存活对象向内存区域的一端移动，聚一堆。然后将这一堆以外的其他空间直接清理，腾出空间。 4. 分代收集算法 根据对象存活周期的差异将内存划为几块。一般堆划分为新生代和老年代，根据年代特点选择不同的收集算法。 例如， 新生代：对象比较短命，存活的少，采用 8:1:1 的复制算法。 老年代：对象比较能活（老不死），采用标记 - 清理或者标记 - 整理算法。 四、垃圾收集器 说明： 图片上部Young generation表示新生代，Tenured generation表示老年代，收集器之间的连线表示两者可以配套使用。 1. Serial收集器（新生代、单线程）收集算法：复制算法。 单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在进行收集时，必须暂停其他所有的工作线程（包括用户正常的工作线程），直到收集完成。 应用： 目前是jvm运行在Client模式下的默认的新生代收集器，单线程没有线程交互，专心收垃圾，效率很高。 2. ParNew收集器（新生代，多线程）收集算法：复制算法。 可认为是Serial的多线程版本，除了增加了垃圾回收线程外，其他与Serial基本一致。 随着CPU数量增加，ParNew对于系统资源的利用越来越强。默认开启的GC线程数与CPU数量相同，可以使用 -XX:ParallelGCThreads 参数来限制GC线程数量。 3. Parallel Scavenge收集器（新生代、多线程）收集算法：复制算法。 与其他收集器如CMS收集器尽量缩短垃圾收集时用户线程的停顿时间不同，Parallel Scavenge收集器目标是达到一个可控制的吞吐量，吞吐量就是CPU运行用户代码时间占CPU运行总时间（包含垃圾收集时间）的比重。 停顿时间和吞吐量： 首先应明确吞吐量是用户代码执行时间占总时间比例，总时间中垃圾收集并不是一次执行，而是许多次垃圾收集时间总和，用户代码和垃圾收集交替。而停顿时间是表示每次垃圾收集占有的时间，缩短停顿时间可能会导致垃圾收集次数变多。 停顿时间：停顿时间短，响应时间就快，适合与用户交互的程序。 吞吐量：吞吐量大，CPU执行用户代码时间长，程序的运算效率高，适合后台运算任务。 4. Serial Old收集器（老年代、单线程）收集算法：标记 - 整理算法。 Serial收集器老年代版本。单线程收集器。 5. Parallel Old收集器（老年代、多线程）收集算法：标记 - 整理。 Parallel Scavenge收集器老年代版本。多线程收集器。Parallel Scavenge + Parallel Old收集器组成纯 “吞吐量” 优先收集器。 6. CMS收集器（老年代、多线程）收集算法：标记 - 清除算法。 CMS收集器是一种为了获取最短停顿时间的收集器。 CMS运行过程： 初始标记：标记一下GC Roots直接关联的对象，速度快。需要暂停其他线程。 并发标记：从上阶段标记的直接关联对象触发，标记所有从GC Roots可达的对象（GC Roots间接关联的对象），该阶段是和用户线程并发执行的。该阶段耗时最长。 重新标记：为了修正并发标记阶段，因用户程序运行导致标记变动的对象的标记记录。速度比初始标记慢一点，但仍然很快。需要暂停其他线程。 并发清除：垃圾清除的过程。和用户线程并发执行。耗时较长。 扫尾：因为CMS运行有四个过程，其中有单线程（初始标记、重新标记），有多线程（并发标记、并发清除），而单线程耗时极短，大部分时间都消耗在多线程的并发阶段，所以可以认为是多线程的。 缺点： CMS收集器对资源敏感。并发执行，垃圾收集线程会占用部分CPU资源，默认GC线程数是（CPU数量+3）/4，当CPU数量小于 4时（例如 2个），就会分出 50%的资源用来GC。 增量式并发收集器：用来解决CPU数量小于 4的情况。做法就是在并发阶段（并发标记、并发清理），让GC线程和用户线程交互执行（并行），减少GC线程占用资源时间。 无法处理浮动垃圾。因为清除阶段是和用户线程并发执行的，所以清除阶段还可能产生新的垃圾而无法被清除，只能等下一次Full GC清除。也正因为用户线程还在运行，所以要留取一部分空间给用户线程，默认老年代使用 68%就会激活CMS进行回收。 -XX:CMSInitiatingOccupancyFraction参数设置可以来提高触发GC的百分比。 但如果CMS运行时预留给用户线程的内存不够，会出现一次 “Concurrent Mode Failure” 失败，导致CMS失效，使用预备的Serial Old收集器重新进行Full GC（老年代垃圾回收），停顿时间大大增加。 所以提高百分比有风险，设置需谨慎。 收集结束会产生大量空间碎片。CMS基于标记 - 清除算法，产生小碎片后，下次分配大对象会塞不进去，从而又触发一次Full GC。 -XX:+UseCMSCompactAtFullCollection 参数设置CMS收集结束后自动进行碎片整理（会暂停用户线程），不过停顿时间会延长。 -XX:CMSFullGCsBeforeCompaction 参数设置执行 n 次不压缩的Full GC后就执行一次压缩碎片的Full GC。 7. G1收集器（全堆、多线程）收集算法：标记 - 整理。 G1特点： 并行与并发：利用多CPU的优势，使用多个CPU来尽可能缩短停顿时间，来达到原本需要暂停用户线程的操作现在不暂停的效果。 分代收集：G1中仍然将内存空间进行分代。G1能够以不同的方式处理各种对象（新对象、存活一段时间对象、讲过几次GC仍存活的对象），来独立管理整个堆（包括新生代和老年代）。 空间整合：基于标记 - 整理算法，不产生内存碎片，收集后的空间连续、完整，可保存大对象。 可预测的停顿：除了降低停顿时间，G1还可以建立可预测的停顿时间模型。可以让使用者指定一个时间段，GC消耗的时间不能超过指定的时间。 管理整个堆内存： G 1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 建立可预测的时间模型： G1对整个堆进行垃圾收集是有计划的，其内部有一个回收优先级列表，列表中的待回收的Region顺序是根据每个Region回收性价比进行排序（回收的空间越大，时间越短，性价比越高），每次回收优先回收性价比高的Region，这样在一定的收集时间内收集效率就很高。 避免全堆扫描对象： G1将堆分为多个Region，逻辑上相互独立，实际上Region中的对象可能与其他任意一个Region中的对象有引用关系。使用全堆扫描，才能保证GC的准确性，但GC效率会大大下降。 解决办法：G1为每个Region维护一个Remembered Set，如果程序对引用类型数据进行写操作，虚拟机会产生一个Write Barrier中断写操作，然后检查引用的对象是否是其他Region中的，如果是，就将引用信息写到被引用对象所在的Region的Remembered Set表中。进行内存回收时，GC Roots枚举范围也参照Remembered Set表内容来扫描对象，可以实现不全堆扫描也能保证准确。 G1运行流程： 初始标记：同CMS收集器。 并发标记：同CMS收集器。 最终标记：类似CMS的重新标记，也是为了找到并发标记情况下因程序运行收到变动的对象，然后将变化记录到线程的Remembered Set Logs中，之后再将Logs中的数据合并到Remembered Set中。 筛选回收：先根据回收性价比在优先级列表中排序，根据用户指定的停顿时间制定回收计划。制定停顿时间内根据优先级堆Region进行回收。 五、内存分配与回收 对象在堆中分配内存，主要分配在新生代的Eden去榆中，如果启动了TLAB，将按线程优先在TLAB上分配，少数情况直接分配在老年代。具体分配要参照收集器组合和设置的参数。 1. 对象优先在Eden分配 多数情况下，对象在Eden区分配，E的呢空间不够，则进行一次Minor GC（新生代GC），如果空间仍然不够，则根据分配担保机制，将Eden区中占空对象提前转移到老年代。 2. 大对象直接进入老年代 大对象需要占用大量的连续空间（如长字符串、数组等），虚拟机提供了一个参数用来指定大对象 -XX:PretenureSizeThreshold ，大于参数值的大对象直接扔进老年代。 注意：只有Serial和ParNew能识别该参数。可以考虑使用ParNew+CMS收集器组合来实现该参数相同的功能。 3. 长期存活的对象将进入老年代 虚拟机有分代收集思想，所以会识别对象是属于哪个年代。 识别对象年代方式：每个对象都有Age计数器代表年龄，对象从Eden出生并且度过了第一次Minor GC并能被Survivor容纳且成功转移到Survivor中，该对象Age为 1。以后对象每经过一次Minor GC且每被回收，Age就 +1，直到对象成年（默认Age为15）后，就晋升到老年代。对象成年Age值可通过 -XX:MaxTenuringThreshold 设置。 4. 对象成年Age动态判定 并不是一定到达参数指定Age才可扔到老年代。如果Survivor中相同Age所有对象大小总和大于Survivor空间的 50%，则Survivor中Age大于等于该Age的对象都可以直接进入老年代，而不用等到参数要求的Age。 例如，Survivor中有20MB空间，有一个4MB的对象Age为6，有六个2MB的对象Age为3，剩下四个1MB的对象Age为2，由于六个Age为3 的对象总空间12MB大于Survivor的 50%，所以此时Age为6和3的 7 个对象可以直接进入老年代。 5. 空间分配担保 新生代采用复制算法，GC时如果Survivor空间暂时不够保存存活的对象，就需要老年代进行分配担保，让Survivor无法容纳的对象进入老年代。但是老年代的剩余空间还得保证能够容纳这些对象，由于这次回收进入老年代的对象需要的空间是未知的，所以需要参考以往需要的容量的平均大小，来看是否能够容纳。如果不能容纳，即担保失败，就需要进行一次老年代的Full GC。 通过查看HandlePromotionFailure设置值是否支持担保失败，如果允许担保失败，则只进行Minor GC即可，如果不允许失败，也需要进行一次Full GC。 六、常见面试题 GC的常见算法 CMS及G1的垃圾回收过程，CMS的各个阶段那两个是Stop The World（暂停其他线程）的？CMS会不会产生空间碎片？ G1的优势 标记清除和标记整理算法的理解及优缺点 Eden Survivor区的比例，为什么是这个比例，Eden Survivor的工作过程 JVM如何判断一个对象是否应该被GC？有哪些类型的对象可被作为GC Roots？ 强、软、弱、虚引用的区别，及GC对他们执行怎么样的操作？ 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F02%2F18%2FStartMyBlog%2F</url>
    <content type="text"><![CDATA[GitPages Hexo搭建GitHub博客1、下载安装node.jsNode.js官网下载注意： 可以选择自定义安装位置。 2、安装 Sublime text 3Sublime Text 3下载地址下载速度较慢，不过安装包较小。安装位置可自己选择。 3、注册GitHub账号 GitHub注册地址 注册用户名 邮箱 密码 添加新的仓库(new repository)： Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、安装GitGit下载地址下载安装Git，安装位置可自由选择。 5、配置GitHubSSH6、初始化配置Hexo简介： Hexo详细说明参考Hexo官网，Hexo就是一个用Node.js编写的静态网站生成器(所以需要安装Node.js)，可以用来做博客框架，恰好它还可以将静态网站部署到GitHub，所以你编写的博客通过Hexo生成静态页面，然后在部署到GitHub中，通过访问GitHub中的页面也都是静态页面。 在写博客的地方创建文件夹例如，我在D盘创建Hexo文件夹。 在D:/Hexo文件夹按住shift点击鼠标右键选择在此处打开Powershell窗口 输入npm install hexo-cli -g命令，等待 等待完成后输入 hexo -v查看是否安装。 打开D:/hexo文件夹，鼠标右键选择git bash here,输入hexo init blog命令来初始化blog目录，该目录用来存放博客相关。 git bash窗口中输入以下命令： cd blog npm install hexo s 浏览器输入 localhost:4000,看能否打开Hexo默认主题。 至此，博客系统搭建完成，需要手动配置博客主题(为了好看)。 7、Next主题使用在Hexo官网 上方有主题栏，可供选择。这里采用使用比较多的主题：NexT主题。 仓库下载地址：NexT仓库，可选择git clone或下载压缩包形式下载。 解压缩压缩包，并将文件夹更名为next，移动到blog/themes目录中。 修改Hexo配置文件_config.yml 修改配置文件详情即接下来的步骤，请参考NexT文档 或者博客末尾的第二个视频，文档和视频都非常详细。 参考视频教程(B站)：GitHub+hexo搭建博客使用Next主题优化博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
