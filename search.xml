<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm内存区域]]></title>
    <url>%2F2019%2F02%2F22%2FjvmMemoryArea%2F</url>
    <content type="text"><![CDATA[一、运行时数据区概述： jvm执行程序时，会把它占有的内存分为一块块的区域，每个区域有不同的功能。就类似于国家分你一块地你用来造房子（我们从我们的16G 内存分几百MB给JVM），房子又分成了卧室（休息），客厅（..），洗手间（洗漱），厨房（做饭）等等区域。 而jvm内存区域具体分为： 线程独占区：每个线程都有各自的区域，区域的生命周期与线程相同 程序计数器 虚拟机栈 本地方法栈 线程共享区域：程序所有线程共享的一块区域 堆 方法区 1. 程序计数器 当前线程所执行的字节码的行号指示器。 ​ 啥是字节码？ jvm就是通过执行字节码指令来运行程序的（不知道可以这么理解吗），比如表示 + 的add指令，表示跳转的 goto 指令等。其中每个指令占一行，程序计数器就是指示运行的字节码指令的行号。比如 if语句，从15行跳转到19行，程序计数器就会从15变为19。 ​ 再试想，如果没有程序计数器记录字节码行号，一个CPU执行多线程程序，CPU对多个线程之间进行快速调度，如果当前线程执行到15行字节码，突然转换到另一个线程，等再次调度回来的时候，就接不上啦，GG。 作用： 字节码解释器通过改变程序计数器来依次读取指令，来实现代码的流程控制，如：顺序、选择、循环等。 在多线程下，程序计数器用于记录当前线程执行的位置，当线程被切换回来的时候能够知道上次运行的字节码位置。 注意： 如果执行的是 java 方法，程序计数器就指向字节码指令的地址。 如果执行的是 Native 方法，计数器为空（Undefined）。 程序计数器不会出现 OutOfMemoryError异常。 2. 虚拟机栈 虚拟机描述的是Java方法执行的内存模型。我们平常说的堆栈的栈就可以认为是虚拟机栈（中的局部变量表）。 ​ 每个方法被执行的时候都会创建一个栈帧，里面包含局部变量表、操作栈、动态链接、方法出口等。方法开始执行就对应栈帧入栈，执行完毕，对应栈帧出栈 局部变量表： ​ 局部变量表存放了编译期可知的八种基本数据类型、对象引用和returnAddress类型（指向字节码指令的地址）。局部变量表的单位是slot(局部变量表空间)，除了 64位的 long和double会占用两个slot，其他类型都只占用一个slot。 注意： 局部变量表需要的空间在编译时期分配，不是运行期。运行期间不会改变局部变量表大小。 异常信息： StackOverflowError：线程请求栈深度大于虚拟机允许的深度。 OutOfMemoryError：虚拟机栈不够了，要申请额外内存，但是上头不分配了。 3. 本地方法栈 与虚拟机栈类似，不过本地方法栈是为 Native 方法服务的。也有栈帧啥的，也是栈帧入栈出栈。 4. 堆 最大的一块内存，在虚拟机启动时就创建好了堆，是所有线程共享的区域。仅用来存放对象实例，“几乎”所有的对象实例（包括数组对象）都在堆中创建。 ​ 由于堆用来存放对象实例的，如果对象死了，就要给它清理掉，释放堆中空间，所以堆还要经常进行GC（垃圾收集）。 ​ 又因为对象的生存时间不一样，有的死得快，有的老不死，所以有分为新生代（死得快）和老年代（老不死），分开来保存对象，这样GC时效率高一点，新生代需要经常GC，老年代偶尔GC，所以分代是为了更好地GC。 ​ 新生代又分为Eden 和两个Survivor区，空间大小比例 8:1:1，为什么需要这么划分请参考《jvm内存分配和垃圾收集》中的复制算法。为什么两个Survivor区请参考 新生代为什么分为一个Eden和两个Survivor 。 ​ java堆可以是物理上不连续的内存空间，但逻辑上要连续。java堆可动态扩展，通过 -Xmx和-Xms参数控制。 异常信息； OutOfMemoryError：堆中内存不够分配给对象，且堆的内存无法扩展增加时。 5. 方法区 方法区用于存储已被虚拟机加载的类信息、常量、static变量、即时编译期编译的代码等。 ​ 方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池： ​ 运行时常量池属于方法区。Class类文件结构中有一项常量池，用于存放编译期生成的各种字面量和符号引用，常量池的内容将在类加载后存放到方法区的运行时常量池中。 ​ 了解：Class文件中常量池还具有动态性，常量除了编译期产生外，还有可能在运行期间产生常量放入池中，例如String类的intern()方法。 异常信息： OutOfMemoryError：方法区内存不够，没法分配时。 二、直接内存（了解） 直接内存不属于上面说的运行时数据区，jvm规范中也没有对直接内存到底是哪块区域进行定义。 ​ NIO（New Input/Output）是一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接在堆外分配内存，java堆中有一个DirectByteBuffer对象引用了这块内存，所以可以通过该对象操作这块内存，可以避免在Java堆 和Native堆来回复制对象，提高效率。 ​ 因为也是内存，所以受本机总内存限制，如果仅仅设置了 -Xmx 参数来控制堆内存大小，而忽略了直接内存的设置，可能会导致直接内存+运行时数据区内存总和超过屋里内存限制，这样在动态扩展内存时因为超过物理内存限制发生 OutOfMemoryError 异常。 三、java堆中对象的创建、布局和访问1. 对象的创建创建对象的过程：类加载检查、分配内存、初始化零值、设置对象头、执行&lt;init&gt;方法 类加载检查：当我们用new关键字实例化对象时，最后到虚拟机执行的就变成 new 指令，虚拟机遇到一条 new 指令时，首先检查 new 指令的参数是否能在常量池中定位到这个类的符号引用，如果常量池中有符号引用，就检查这个符号引用的类是否已被加载、解析、初始化过。如果常量池没有该符号引用，那必须先将参数表示的类进行加载。 分配内存：对象需要的内存在经过类加载之后就可以确定，之后就在堆中划一块内存给这个对象，具体的划分内存的方式有两种： 指针碰撞：要求内存整齐，就是分配过对象的内存在一边，按照顺序分配。这样在最后一个对象尾部有一个指针，当要分配新对象时，就指针后移对象需要的距离分配给对象。 空闲列表：内存不是整齐的，使用过的和空闲的可能交错。虚拟机维护了一个”空闲列表”，列表上记录了空闲的内存区，当给对象分配内存，就从列表上找一块装得下该对象的内存给对象，同时将这块内存从列表中去掉。 思考：为什么有规整的和不规整的内存区域呢？因为和垃圾收集有关，有的内存经过垃圾收集之后内存是整齐的（复制算法、标记整理算法），有的收集之后就是不规整的（标记清除算法），详情参考我的《jvm内存分配与垃圾收集》一文。 （了解）如果涉及多线程分配内存呢？就是一个线程正在分配内存，指针还没开始移动，另一个线程就在原来的区域进行分配了，造成冲突。解决方式有两种： 同步处理：一个线程分配内存就上锁，别的线程不能同时分配。虚拟机采用CAS加失败重试方式更新。 TLAB(Thread Local Allocation Buffer)：本地线程分配缓冲。就是给每个线程在堆中先分配一块区域，线程在自己的内存区域给自己的对象分配内存。当有线程的TLAB用完了，继续向堆申请内存，就要采用同步的方式进行上锁了，不然其他的线程也要同时申请就又冲突了。 初始化零值：给对象分配内存后，jvm要将分配到的内存空间都初始化为零值，可以保证对象的实例字段在不赋初始值就直接使用，程序访问到的是这些字段的数据类型所对应的零值。（零值：如int是0，boolean是false，引用类型为null）。 设置对象头：之后要设置对象头，对象头包括对象是哪个类的实例、对象Hash值、对象GC的Age、类的元数据等。 执行&lt;init&gt;方法：经过以上步骤，对于虚拟机来说，一个新对象已经产生，但对java程序来说，对象创建才刚开始，因为所有字段还为零值，对象还没有根据程序员的意愿初始化。一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象初始化为程序员期望的值，这样一个真正可用的对象才算完全产生。 2. 对象的内存布局对象在内存中的布局分为三个区域：对象头、实例数据、对齐补充。 1. 对象头对象头包括两部分，第一部分是用于存储对象自身的运行时数据，另一部分是类型指针。 对象自身运行时数据：哈希吗、对象GC的Age、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。32bit/64bit（和虚拟机位数相同）。 类型指针：对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。32bit长度。 数组长度（可选）：如果对象是数组类型（String []），还需要32bit记录数组长度。 2. 实例数据 实例数据是对象真正存储的有效信息，即程序代码中定义的字段的实际值。 ​ 实例数据记录的数据包含父类继承下来的，自身定义的，子类定义的。而这几种数据的存储数据受虚拟机分配策略参数和字段在java源码中定义顺序影响。 3. 对齐补充 对齐补充没什么意义，只起占位符作用。 ​ 虚拟机要求对象的起始地址必须是8字节 的整数倍，即对象占的空间也得是8字节 的整数倍，因为对象头是8字节 的整数倍，实例数据大小不固定，所以需要对齐补充来补全实例数据为8字节的整数倍。 3. 对象的访问​ 我们知道具体对象是在堆中创建的，而我们的java程序是通过栈上的 reference 数据来引用具体对象。那么 reference 数据是怎么指向堆中的具体对象呢？ 访问对象的方式： 句柄访问：java堆中会划分出一块内存作为句柄池，句柄中保存的就是对象的实例数据（堆中）和类型数据（方法区中）具体地址。reference中存储的就是具体对象的句柄信息。 直接指针访问：直接指针方式就是reference中保存的就是对象在堆中的具体地址。而对象在方法区中的类型数据信息就由java堆去考虑。 两种方式比较： 使用句柄访问的话，对象被移动时（如垃圾收集中标记整理、复制算法对象的地址都会变动），只需要修改句柄中的地址，reference数据本身不需要变。 直接指针访问速度更快，不用先定位句柄，句柄在定位对象，节省一次定位时间。 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生代为何分为一个Eden区和两个Survivor区]]></title>
    <url>%2F2019%2F02%2F21%2FjvmYoungGenerationEdenAndDoubleSurvivor%2F</url>
    <content type="text"><![CDATA[问题：为什么新生代还要分为Eden区和两个Survivor区? 注意：新生代GC是对所有存放对象的区域进行垃圾收集，并不只是Eden区，因为Survivor区保留的存活对象 1、为什么要新生代要分区？ 新生代采用复制算法进行垃圾收集，复制算法是需要分区的，原本是 1:1 分，进行垃圾收集时，A区中的存活对象复制到B区中，并将A区格式化，下次存对象就存到B区，收集时也是从B区复制到A区，循环往复… 2、为什么分Eden区和Survivor区比例不同？ 新生代中的对象是比较多的，如果每次使用一半，空闲一半，浪费太严重，所以比例不同。 80% 的空间分给Eden区域，10%+10% 分别分给from Survivor和to Survivor区，Eden区用来给新对象分配空间，Survivor用来保留存活对象。 具体的 8:1:1 的比例是实验得出来的最优（当然不是我实验的）。 3、为什么不是一个Eden + 一个Survivor？ 如果只有Eden和一个Survivor空间的话，收集操作会产生碎片化。 举例：假设条件是Eden 80% + Survivor20%。新分配对象到Eden区，Eden满后，需要GC，将Eden区存活对象复制到Survivor，之后清理Eden区。接着又存对象到Eden区，再次满了需要GC，这次GC会将Eden区存活对象复制到Survivor区，但是Survivor也有死亡的对象需要回收，Survivor区存活的对象仍然保持原位置，Survivor中回收剩下的区域就变成碎片，因为复制算法不会自动整理空间。久而久之，内存碎片增多，造成资源浪费。 为什么每次GC完事不把Survivor区存活的对象再复制到Eden区？ 似乎挺有道理，但是一是再次复制效率比较低，二来就没法判断哪些对象什么时候可以晋升至老年代了。 4、一个80%的Eden加两个10%的Survivor试试？ 将新生代分为 Eden(80%) + From Survivor(10%) + To Survivor(10%)，注意：这里的From和To不是和某一块Survivor区绑定的，即这次From是第一块Survivor，下次From就变成了第二块Survivor了。 每次分配新对象还是分配到Eden区中，但是每次GC仍只使用Eden区和一块Survivor区。 第一次GC：首先分配内存给Eden区，Eden满后需要GC，将存活对象复制到一块Survivor中，然后清理Eden区域。 第二次GC：将Eden和上次使用的Survivor区中的存活对象复制到另一块空闲的Survivor区中，再统一清理Eden区和上次使用的Survivor区。咦，这次又变成一块空闲的Survivor区和一块正在使用的Survivor区了，似乎碎片的问题也解决了（因为复制的对象顺序排列） 第 3、4 … n 次GC：GC过程都和第二次一样。在Survivor中的对象每度过一次GC，对象的Age+1，等到了年龄阈值（默认15，可设置）就可晋升至老年代，当然还有其他方式晋升老年代（不阐述了，参考《jvm内存分配和垃圾收集》）。 问题似乎就这么不完美的讲通了…]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm内存分配及垃圾收集]]></title>
    <url>%2F2019%2F02%2F20%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[一、垃圾收集概述回收区域： 栈：栈中的栈帧根据方法的开始和结束来执行入栈和出栈的操作，而每个栈帧要分配的内存在类结构确定下来就可以确定了。方法或线程结束，栈帧内存就回收。 堆和方法区：堆中一个接口的多个实现类需要的内存可能不同，方法区中一个方法的多个分支需要的内存也不一样，程序运行期才知道创建哪些对象，所以堆和方法区的内存分配不是开始就确定的(动态的)，回收也是动态的。 二、判断对象是否存活 堆中几乎存放着java所有对象，垃圾收集器在回收前要先判断对象是否存活。 1. 引用计数算法 给对象添加一个引用计数器，每当有一个地方引用该对象，计数器加 1，解除引用，计数器减 1。任一时刻，只要计数器为 0 ，则认为该对象不再存活。 带来的问题： 对象之间循环引用问题。 例如， 123456789101112131415161718public class Test&#123; public Object instance = null; public static void main(String[] args)&#123; //通过new在堆中创建一个对象，暂且称为实例1,test1引用了实例1对象，则实例1的引用加 1。 Test test1 = new Test(); //又通过new在堆中创建一个对象，称为实例2,test2引用了实例2对象，则实例2的引用加 1。 Test test2 = new Test(); //test1的instance属性引用了test2，实际上引用的是test2指向的堆中的实例2对象，实例2的引用又加 1，此时实例2引用数为 2. test1.instance = test2; //test2的instance属性引用了test1，实际上引用的是test1指向的堆中的实例1对象，实例1的引用又加 1，此时实例1引用数为 2. test2.instance = test1; //test1引用置为空，即不指向实例1，实例1引用数减1，为 1. test1 = null; //test2同test1. test2 = null; &#125;&#125;//最终实例1 和实例2 的引用数都为1(instance属性对其的引用)，所以这两个实例对象都不会被回收。 2. 根搜索算法 通过一系列的名为”GC Roots”的对象作为起始点，从这些节点向下搜索，经过的路径称为引用链，若一个对象到GC Roots没有引用链(即从GC Roots开始无法到达该对象)，则对象不可用。 可作为GC Roots的对象： 虚拟机栈中引用的对象。 方法区中类静态属性(static)引用的对象。 方法区中常量(final)引用的对象。 本地方法栈(native方法)中引用的对象。 3. 引用的分类： 强引用：可理解为直接引用，Object obj = new Object();，对于这类引用，垃圾收集器永远不会回收new Object()创造出的实例对象。 软引用：描述一些还有用，但不是必须要的对象。如果系统将要发生内存溢出，这些被软引用关联的对象就会被列进回收范围等待被回收，如果回收之后还是内存溢出，就抛出异常。 弱引用：也是描述非必须要的对象，比软引用更弱。弱引用关联的对象只能生存到下一次垃圾收集之前，下次垃圾收集开始时，内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：没啥实际引用意义。虚引用唯一目的就是关联对象被垃圾收集之前能收到个”报信”。 4. 根搜索算法判定对象存活处死一个对象的过程： 两次标记 一次标记：从GC Roots节点无法到达该对象。进行第一次标记和一次筛选，筛选是通过该对象是否有必要执行finalize()方法进行筛选。如果对象没有finalize方法或finalize方法之前被jvm调用过了，则没必要执行finalize方法，对象GG。 二次标记：如果对象有必要执行finalize方法，则该对象就会被放在F-Queue队列（押往刑场的牢笼）中，jvm会建立一个Finalizer线程来执行对象的finalize方法。Finalizer线程执行而不是对象自己执行finalize方法的目的是：防止对象以各种借口延缓被执行死刑（死循环），而Finalizer线程不会等待对象finalize方法结束。在这短短的finalize方法执行期间，如果对象成功收买法官（将该对象自身this赋值给GC Roots引用链上的对象），则该对象就逃出牢笼，完成自救。 注意： 待处死的对象完成自救后，如果继续犯事被押赴刑场，那就必须被处决了，因为它无法在finalize方法中再次收买法官（任何一个对象的finalize方法都只会被执行一次）。 示例： 12345678910111213141516171819202122232425262728293031323334353637package jvmTest01;public class KillObject &#123; public static KillObject SAVE_HIMSELF = null; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("死刑对象被押赴刑场..."); //收买法官，完成自救(和GC Roots引用链上的对象绑定) KillObject.SAVE_HIMSELF = this; &#125; public static void main(String[] args) throws Throwable&#123; //new实例化的KillObject对象在 GC Roots引用链中 SAVE_HIMSELF = new KillObject(); //KillObject对象犯事，不在引用链中，要被处死 SAVE_HIMSELF = null; //gc方法执行包含对象标记的过程，也包含对象的finalize方法执行 System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; //KillObject对象屡教不改，再次犯事 SAVE_HIMSELF = null; System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; &#125;&#125; 运行结果： 123456D:\java\jdk\bin\java.exe 死刑对象被押赴刑场...死刑对象完成自救死刑对象被处死(被回收)Process finished with exit code 0 结果表明： 对象再次犯事，没有完成自救被回收。因为他无法再次通过执行finalize方法收买法官（finalize方法一个对象只能执行一次）。 三、垃圾收集算法1. 标记 - 清除算法 最基本的垃圾收集算法。 算法思想： 标记：标记出要回收的对象。就是标记出上一节中那些最终押赴刑场执行处死的对象。 清除：统一回收掉被标记对象。对要处死对象统一枪毙。 问题： 标记 - 清除效率低下。 清除后的对象产生小碎片，如果要分配大对象，还需要再次进行垃圾收集整合小碎片为大空间。 2. 复制算法 将可用内存划分为容量相等的两块，每次使用一块，使用的这块用完了，进行垃圾回收时，就将这块上的存活对象复制到另一块保留区域上，再将这块内存区域一次清理变成保留区域。 代价就是内存缩小为原来的一半。 回收新生代采用复制算法，并做了改进： 新生代的对象 98% 都是短命鬼，由于回收时存活对象很少，所以划分区域时，就不用按照1:1划分了，划分一小块区域暂存存活对象即可。 新生代划分对象是划分为一块大空间（Eden）和两块小空间（Survivor），每次使用Eden和一块Survivor空间。进行回收，只需要把Eden和Survivor空间上的存活对象复制到另一块Survivor空间，最后清理掉Eden和Survivor空间。默认Eden:Survivor:Survivor=8:1:1。所以浪费的空间只有 10%。 如果进行回收时，存活对象比Survivor空间大，复制过去装不下，则就需要向其他内存（例如老年代）进行暂借空间，这种机制称为分配担保（后续讲解）。 3. 标记 - 整理算法算法思想： 标记：标记出要回收的对象。标记方法同标记 - 清除算法。 整理：让所有存活对象向内存区域的一端移动，聚一堆。然后将这一堆以外的其他空间直接清理，腾出空间。 4. 分代收集算法 根据对象存活周期的差异将内存划为几块。一般堆划分为新生代和老年代，根据年代特点选择不同的收集算法。 例如， 新生代：对象比较短命，存活的少，采用 8:1:1 的复制算法。 老年代：对象比较能活（老不死），采用标记 - 清理或者标记 - 整理算法。 四、垃圾收集器 说明： 图片上部Young generation表示新生代，Tenured generation表示老年代，收集器之间的连线表示两者可以配套使用。 1. Serial收集器（新生代、单线程）收集算法：复制算法。 单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在进行收集时，必须暂停其他所有的工作线程（包括用户正常的工作线程），直到收集完成。 应用： 目前是jvm运行在Client模式下的默认的新生代收集器，单线程没有线程交互，专心收垃圾，效率很高。 2. ParNew收集器（新生代，多线程）收集算法：复制算法。 可认为是Serial的多线程版本，除了增加了垃圾回收线程外，其他与Serial基本一致。 随着CPU数量增加，ParNew对于系统资源的利用越来越强。默认开启的GC线程数与CPU数量相同，可以使用 -XX:ParallelGCThreads 参数来限制GC线程数量。 3. Parallel Scavenge收集器（新生代、多线程）收集算法：复制算法。 与其他收集器如CMS收集器尽量缩短垃圾收集时用户线程的停顿时间不同，Parallel Scavenge收集器目标是达到一个可控制的吞吐量，吞吐量就是CPU运行用户代码时间占CPU运行总时间（包含垃圾收集时间）的比重。 停顿时间和吞吐量： 首先应明确吞吐量是用户代码执行时间占总时间比例，总时间中垃圾收集并不是一次执行，而是许多次垃圾收集时间总和，用户代码和垃圾收集交替。而停顿时间是表示每次垃圾收集占有的时间，缩短停顿时间可能会导致垃圾收集次数变多。 停顿时间：停顿时间短，响应时间就快，适合与用户交互的程序。 吞吐量：吞吐量大，CPU执行用户代码时间长，程序的运算效率高，适合后台运算任务。 4. Serial Old收集器（老年代、单线程）收集算法：标记 - 整理算法。 Serial收集器老年代版本。单线程收集器。 5. Parallel Old收集器（老年代、多线程）收集算法：标记 - 整理。 Parallel Scavenge收集器老年代版本。多线程收集器。Parallel Scavenge + Parallel Old收集器组成纯 “吞吐量” 优先收集器。 6. CMS收集器（老年代、多线程）收集算法：标记 - 清除算法。 CMS收集器是一种为了获取最短停顿时间的收集器。 CMS运行过程： 初始标记：标记一下GC Roots直接关联的对象，速度快。需要暂停其他线程。 并发标记：从上阶段标记的直接关联对象触发，标记所有从GC Roots可达的对象（GC Roots间接关联的对象），该阶段是和用户线程并发执行的。该阶段耗时最长。 重新标记：为了修正并发标记阶段，因用户程序运行导致标记变动的对象的标记记录。速度比初始标记慢一点，但仍然很快。需要暂停其他线程。 并发清除：垃圾清除的过程。和用户线程并发执行。耗时较长。 扫尾：因为CMS运行有四个过程，其中有单线程（初始标记、重新标记），有多线程（并发标记、并发清除），而单线程耗时极短，大部分时间都消耗在多线程的并发阶段，所以可以认为是多线程的。 缺点： CMS收集器对资源敏感。并发执行，垃圾收集线程会占用部分CPU资源，默认GC线程数是（CPU数量+3）/4，当CPU数量小于 4时（例如 2个），就会分出 50%的资源用来GC。 增量式并发收集器：用来解决CPU数量小于 4的情况。做法就是在并发阶段（并发标记、并发清理），让GC线程和用户线程交互执行（并行），减少GC线程占用资源时间。 无法处理浮动垃圾。因为清除阶段是和用户线程并发执行的，所以清除阶段还可能产生新的垃圾而无法被清除，只能等下一次Full GC清除。也正因为用户线程还在运行，所以要留取一部分空间给用户线程，默认老年代使用 68%就会激活CMS进行回收。 -XX:CMSInitiatingOccupancyFraction参数设置可以来提高触发GC的百分比。 但如果CMS运行时预留给用户线程的内存不够，会出现一次 “Concurrent Mode Failure” 失败，导致CMS失效，使用预备的Serial Old收集器重新进行Full GC（老年代垃圾回收），停顿时间大大增加。 所以提高百分比有风险，设置需谨慎。 收集结束会产生大量空间碎片。CMS基于标记 - 清除算法，产生小碎片后，下次分配大对象会塞不进去，从而又触发一次Full GC。 -XX:+UseCMSCompactAtFullCollection 参数设置CMS收集结束后自动进行碎片整理（会暂停用户线程），不过停顿时间会延长。 -XX:CMSFullGCsBeforeCompaction 参数设置执行 n 次不压缩的Full GC后就执行一次压缩碎片的Full GC。 7. G1收集器（全堆、多线程）收集算法：标记 - 整理。 G1特点： 并行与并发：利用多CPU的优势，使用多个CPU来尽可能缩短停顿时间，来达到原本需要暂停用户线程的操作现在不暂停的效果。 分代收集：G1中仍然将内存空间进行分代。G1能够以不同的方式处理各种对象（新对象、存活一段时间对象、讲过几次GC仍存活的对象），来独立管理整个堆（包括新生代和老年代）。 空间整合：基于标记 - 整理算法，不产生内存碎片，收集后的空间连续、完整，可保存大对象。 可预测的停顿：除了降低停顿时间，G1还可以建立可预测的停顿时间模型。可以让使用者指定一个时间段，GC消耗的时间不能超过指定的时间。 管理整个堆内存： G 1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 建立可预测的时间模型： G1对整个堆进行垃圾收集是有计划的，其内部有一个回收优先级列表，列表中的待回收的Region顺序是根据每个Region回收性价比进行排序（回收的空间越大，时间越短，性价比越高），每次回收优先回收性价比高的Region，这样在一定的收集时间内收集效率就很高。 避免全堆扫描对象： G1将堆分为多个Region，逻辑上相互独立，实际上Region中的对象可能与其他任意一个Region中的对象有引用关系。使用全堆扫描，才能保证GC的准确性，但GC效率会大大下降。 解决办法：G1为每个Region维护一个Remembered Set，如果程序对引用类型数据进行写操作，虚拟机会产生一个Write Barrier中断写操作，然后检查引用的对象是否是其他Region中的，如果是，就将引用信息写到被引用对象所在的Region的Remembered Set表中。进行内存回收时，GC Roots枚举范围也参照Remembered Set表内容来扫描对象，可以实现不全堆扫描也能保证准确。 G1运行流程： 初始标记：同CMS收集器。 并发标记：同CMS收集器。 最终标记：类似CMS的重新标记，也是为了找到并发标记情况下因程序运行收到变动的对象，然后将变化记录到线程的Remembered Set Logs中，之后再将Logs中的数据合并到Remembered Set中。 筛选回收：先根据回收性价比在优先级列表中排序，根据用户指定的停顿时间制定回收计划。制定停顿时间内根据优先级堆Region进行回收。 五、内存分配与回收 对象在堆中分配内存，主要分配在新生代的Eden去榆中，如果启动了TLAB，将按线程优先在TLAB上分配，少数情况直接分配在老年代。具体分配要参照收集器组合和设置的参数。 1. 对象优先在Eden分配 多数情况下，对象在Eden区分配，E的呢空间不够，则进行一次Minor GC（新生代GC），如果空间仍然不够，则根据分配担保机制，将Eden区中占空对象提前转移到老年代。 2. 大对象直接进入老年代 大对象需要占用大量的连续空间（如长字符串、数组等），虚拟机提供了一个参数用来指定大对象 -XX:PretenureSizeThreshold ，大于参数值的大对象直接扔进老年代。 注意：只有Serial和ParNew能识别该参数。可以考虑使用ParNew+CMS收集器组合来实现该参数相同的功能。 3. 长期存活的对象将进入老年代 虚拟机有分代收集思想，所以会识别对象是属于哪个年代。 识别对象年代方式：每个对象都有Age计数器代表年龄，对象从Eden出生并且度过了第一次Minor GC并能被Survivor容纳且成功转移到Survivor中，该对象Age为 1。以后对象每经过一次Minor GC且每被回收，Age就 +1，直到对象成年（默认Age为15）后，就晋升到老年代。对象成年Age值可通过 -XX:MaxTenuringThreshold 设置。 4. 对象成年Age动态判定 并不是一定到达参数指定Age才可扔到老年代。如果Survivor中相同Age所有对象大小总和大于Survivor空间的 50%，则Survivor中Age大于等于该Age的对象都可以直接进入老年代，而不用等到参数要求的Age。 例如，Survivor中有20MB空间，有一个4MB的对象Age为6，有六个2MB的对象Age为3，剩下四个1MB的对象Age为2，由于六个Age为3 的对象总空间12MB大于Survivor的 50%，所以此时Age为6和3的 7 个对象可以直接进入老年代。 5. 空间分配担保 新生代采用复制算法，GC时如果Survivor空间暂时不够保存存活的对象，就需要老年代进行分配担保，让Survivor无法容纳的对象进入老年代。但是老年代的剩余空间还得保证能够容纳这些对象，由于这次回收进入老年代的对象需要的空间是未知的，所以需要参考以往需要的容量的平均大小，来看是否能够容纳。如果不能容纳，即担保失败，就需要进行一次老年代的Full GC。 通过查看HandlePromotionFailure设置值是否支持担保失败，如果允许担保失败，则只进行Minor GC即可，如果不允许失败，也需要进行一次Full GC。 六、常见面试题 GC的常见算法 CMS及G1的垃圾回收过程，CMS的各个阶段那两个是Stop The World（暂停其他线程）的？CMS会不会产生空间碎片？ G1的优势 标记清除和标记整理算法的理解及优缺点 Eden Survivor区的比例，为什么是这个比例，Eden Survivor的工作过程 JVM如何判断一个对象是否应该被GC？有哪些类型的对象可被作为GC Roots？ 强、软、弱、虚引用的区别，及GC对他们执行怎么样的操作？ 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F02%2F18%2FStartMyBlog%2F</url>
    <content type="text"><![CDATA[GitPages Hexo搭建GitHub博客1、下载安装node.jsNode.js官网下载注意： 可以选择自定义安装位置。 2、安装 Sublime text 3Sublime Text 3下载地址下载速度较慢，不过安装包较小。安装位置可自己选择。 3、注册GitHub账号 GitHub注册地址 注册用户名 邮箱 密码 添加新的仓库(new repository)： Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、安装GitGit下载地址下载安装Git，安装位置可自由选择。 5、配置GitHubSSH6、初始化配置Hexo简介： Hexo详细说明参考Hexo官网，Hexo就是一个用Node.js编写的静态网站生成器(所以需要安装Node.js)，可以用来做博客框架，恰好它还可以将静态网站部署到GitHub，所以你编写的博客通过Hexo生成静态页面，然后在部署到GitHub中，通过访问GitHub中的页面也都是静态页面。 在写博客的地方创建文件夹例如，我在D盘创建Hexo文件夹。 在D:/Hexo文件夹按住shift点击鼠标右键选择在此处打开Powershell窗口 输入npm install hexo-cli -g命令，等待 等待完成后输入 hexo -v查看是否安装。 打开D:/hexo文件夹，鼠标右键选择git bash here,输入hexo init blog命令来初始化blog目录，该目录用来存放博客相关。 git bash窗口中输入以下命令： cd blog npm install hexo s 浏览器输入 localhost:4000,看能否打开Hexo默认主题。 至此，博客系统搭建完成，需要手动配置博客主题(为了好看)。 7、Next主题使用在Hexo官网 上方有主题栏，可供选择。这里采用使用比较多的主题：NexT主题。 仓库下载地址：NexT仓库，可选择git clone或下载压缩包形式下载。 解压缩压缩包，并将文件夹更名为next，移动到blog/themes目录中。 修改Hexo配置文件_config.yml 修改配置文件详情即接下来的步骤，请参考NexT文档 或者博客末尾的第二个视频，文档和视频都非常详细。 参考视频教程(B站)：GitHub+hexo搭建博客使用Next主题优化博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
