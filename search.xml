<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java异常处理机制]]></title>
    <url>%2F2019%2F03%2F14%2FjavaThrowable%2F</url>
    <content type="text"><![CDATA[一、什么是异常？我们程序在编译或运行阶段，总会出现各种各样的错误，导致程序中断，无法继续运行。这些不被期望的事件，阻止了程序按照程序员的预期正常执行，就是异常。 当出现异常时，如果我们不管不问，那么他就会中断我们正在运行的程序。 例如， 12345678910111213141516171819202122public class test1 &#123; public static void main(String[] args) &#123; test(3,0); &#125; public static void test(int a,int b)&#123; System.out.println("运算开始："); int c = a / b; System.out.println("计算完毕"); System.out.println(c); int d = a + b; System.out.println(d); &#125;&#125;//运行结果D:\java\jdk\bin\java.exe ...运算开始：Exception in thread "main" java.lang.ArithmeticException: / by zero at com.mao.ThrowablePrac.test1.test(test1.java:7) at com.mao.ThrowablePrac.test1.main(test1.java:3)Process finished with exit code 1 程序运行到第七行，算术运算计算 （3 / 0），这显然是不被允许的，所以程序被该异常中断导致8行以后的代码无法被正常执行了。 二、如果发生异常也不想程序中断？如果发生了异常，但是也不想因为这个异常导致程序崩溃而无法处理下面的运算，那么我们就要对异常进行处理了。 异常处理机制：异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。 那怎么处理呢？ 例如， 1234567891011121314151617181920212223242526public class test1 &#123; public static void main(String[] args) &#123; test(3,0); &#125; public static void test(int a,int b)&#123; System.out.println("运算开始："); try &#123; int c = a / b; System.out.println(c); &#125; catch(ArithmeticException e) &#123; System.out.println("除数不能为 0 "+e.getMessage()); &#125; System.out.println("计算完毕"); int d = a + b; System.out.println(d); &#125;&#125;//计算结果D:\java\jdk\bin\java.exe ...运算开始：除数不能为 0 / by zero计算完毕3Process finished with exit code 0 可以看出，我们在try...catch中对要发生的异常进行了处理，当程序真的发生了上面的ArithmeticException异常，就会被处理到（当然上面的程序暂时只能处理这一种异常）。可以看出，处理完毕之后，程序也不会中断运行，而是继续向下运行，14行以后的代码都执行了。 三、异常分类我们已经知道导致程序运行的罪魁祸首之一就是异常，那异常到底是个什么东西？很多吗？有哪些？这些都还不了解。 首先，应该明确程序发生异常时，都会在发生异常的地方产生一个异常对象，如ArithmeticException e，也就是说，没发生一个异常，都产生了一个异常对象，当然是系统自动产生的，我们平常会看不到。 Java标准库中内建了一些通用异常类，这些异常类的顶级父类是Throwable类。如下， Error（错误）：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，一般这种我们也处理不了，所以不用过多关注这个。 Exception（异常）：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。而Exception又分为两种： 运行时异常（RuntimeException）：Error也属于运行时异常。运行时异常是一种设计或实现问题上出现的错误，大多数是程序设计有问题引发的。这类异常编译期无法发现，只能运行时才会发现。 检查型异常：这类异常仍然是发生在运行期，不过编译期编译时会进行检查，一旦编译发现某些地方可能会发生异常，就提示并强迫开发者立即处理，否则编译不通过，例如sleep()方法必须进行处理，不然无法编译通过。 四、异常处理对于异常，有以下几种处理方式： try catch fianlly：捕获异常(try)，并进行匹配处理(catch) throw：抛出异常 throws：声明异常 1. try / catch / finally在出现异常后，我们可以直接捕获并处理它，这种处理方式是通过try catch实现的。 语法结构： 12345678910try&#123; 语句1... 语句2...&#125; catch(异常类A 变量a)&#123; 语句3...&#125; catch(异常类B 变量b)&#123; 语句4...&#125; finally&#123; 语句5...&#125; try：try块中主要存放可能发生异常的代码。 如果块中没发生异常，则会紧接着执行finally快中的代码，最后执行finally块后剩余的代码。 如果块中发生异常，则尝试去匹配catch块。 catch：每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部调用者方法中去匹配异常处理器。当然该块后续的代码都不会被执行了。 如果try中没有发生异常，则所有的catch块将被忽略。 finally：该块是可选的，如果存在，则无论会不会发生异常，都保证该块一定会被执行。 注意： 这三个块不可以单独出现，必须成对的，可以是try / catch /finally、try / catch、try / finally这几种。 try块中的变量和catch块中的变量（包括异常变量），以及finally中的变量，他们之间不可共享使用。因为都是局部变量。 每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一次匹配的catch会得到执行，且匹配执行后，后续的catch块直接跳过，开始执行finally块。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 处理流程 首先try块中语句发生异常后，就跳出try块，去catch中寻求异常匹配。 如果catch中没有匹配到异常，就执行finally块，并将异常交由上层调用者处理，注意这里不会执行finally块后的代码了。如果catch中匹配到了异常，则进行处理，完事之后，就继续执行finally块及其之后的代码。 2. throwsthrows 声明异常时告诉Java编译器有一个异常出现了。在方法中，声明异常在方法头部，表示方法在运行的时候，很可能出现异常现象。 格式： 123public static void test() throws Exception,...&#123; ...&#125; 这种方式声明的异常，在本方法中不会进行处理，而是交由上级（调用方）进行处理。意思就相当于告诉上层调用方，我这方法里可能会有异常，我没时间精力去处理，你自己看着办吧。 3. throwthrow 抛出异常，就是将异常抛给异常处理器，暂时不去处理它。 当一个方法发生异常时，可以通过 throw 关键字将该异常抛出，交由上一级调用方处理，跑出的可以是异常引用（变量），也可以是异常对象（如 new Exception() ）。 格式： 1234//一种throw 异常对象名;//二种throw new 异常类(); 一条 throw 语句一旦被执行，程序立即转入响应的异常处理程序，他后面的语句就不仔执行了，而且它所在的方法也不再返回有意义的值。 在一个方法中，可以有多条 throw 语句，但每次最多只能执行其中的一条。 例如， 1234567891011121314public class CatchThrows &#123; static int x; public static void main(String[] args) &#123; double a = Math.random() * 10; if (x &gt; 0) &#123; System.out.println(a / x); &#125; else &#123; throw new Exception(); //抛出异常 &#125; &#125; public void setX(int x) &#123; this.x = x; &#125;&#125; 123456//编译结果$ javac CatchThrows.javaCatchThrows.java:11: 错误: 未报告的异常错误Exception; 必须对其进行捕获或声明以便抛出 throw new Exception(); ^1 个错误 对于上面的代码，编译是无法通过的，是因为一个方法中如果使用 throw 来抛出异常，要么自己捕获它并处理（catch），要么声明抛出了一个异常（throws），交由上层调用方处理。 五、异常的注意事项1、如果父类有方法 throws 声明了异常，子类重写了该方法，则子类重写的方法 throws 的异常必须和父类相同或者是父类声明异常的子类。 例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。 1234567891011121314151617class superClass&#123; public void test() throws IOException&#123; throw new IOException(); &#125;&#125;class subClass extends superClass&#123; public void test() throws Exception&#123; //编译出错 throw new Exception(); &#125;&#125;public class SuperAndSub &#123; public static void main(String[] args) &#123; superClass[] father = new superClass[2]; father[0] = new superClass(); father[1] = new subClass(); &#125;&#125; 因为子类的throws异常不是父类throws异常的子类，所以编译失败。 由于多态的存在，子类对象赋值给父类引用，这样在捕获处理父类方法中的异常也要保证能够处理子类覆写方法中的异常，所以父类方法中异常对象等级要比子类的高才行。 六、finally中的注意事项由于 finally 块中的代码是一定会被执行的，所以即便 try 或 catch 块中有 return 语句，finally 块中的代码也还是会被执行，并且 finally 中 return 的值会覆盖 try 或 catch 块中 return 的值。同样异常也会被抑制或覆盖。 例如， 12345678910111213141516171819202122232425262728public class finallyAndReturn &#123; public static void main(String[] args) &#123; System.out.println(new finallyAndReturn().test()); System.out.println(new finallyAndReturn().test1()); &#125; public int test()&#123; try &#123; return 1; &#125; finally &#123; return 2; //返回这个 &#125; &#125; public int test1()&#123; try &#123; int i = 4/0; &#125; catch (Exception e)&#123; return 1; &#125; finally &#123; return 2; //返回这个 &#125; &#125;&#125;//实验结果D:\java\jdk\bin\java.exe ...22Process finished with exit code 0 可见返回值都是finally块中return的值。 总结： 不要在 finally 中使用 return。 不要在 finally中抛出异常。 finally块仅仅用来释放资源是最合适的。 将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F03%2F08%2FjavaObserver%2F</url>
    <content type="text"><![CDATA[概述 观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新。 观察者可以理解为“发布-订阅模式”，有一个发布者发布消息（被观察者），一个订阅者（观察者）订阅发布者，发布者发布消息就会通知订阅者，订阅者可对消息进行查看或处理等，订阅者也可选择取消订阅发布者，这样就收不到发布者发布的消息。 观察者模式的角色 抽象被观察者角色（发布者接口）：是一个抽象接口，里面定义了发布者应该遵循的一些规则。可以在接口中定义如下几种方法： 增加订阅者：每当有订阅者订阅，就将该订阅者添加进集合。 删除订阅者：订阅者取消订阅，就将其从集合中删除。 发布消息：用来发布消息，并通知订阅者查看消息。 具体被观察者角色（发布者）：就是一个具体的发布者对象，实现了发布者接口并覆写其中的方法。每个发布者都包含一个集合，用于保存所有的订阅者对象引用，发布者对象可以具体的定义发布消息。 抽象观察者角色（订阅者接口）：是一个抽象接口，定义了订阅者应该遵循的一些规则。该接口包含一个通知方法，每当自己订阅的发布者发布消息后，该方法被调用用来通知自己。 具体观察者角色（订阅者）：具体的订阅者对象。 场景举例过年了，微信发红包功能开始活跃起来。大爷（发布者）想给家里的一群小孩发红包，就创建了一个群，小孩们（订阅者）申请加群（增加订阅者方法）。大爷趁孩子们不注意就发红包（发布消息），之后@全体成员提醒孩子抢红包（通知订阅者），不知道为什么这些孩子中混进了一个大人，原来是大娘，大娘一看，群里10个人，发了一块钱红包，太无聊了，就退群了（取消订阅，删除订阅者）。 实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*** 发布者接口*/interface Observerable &#123; void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObserver();&#125;/** * 发布者 */public class Uncle implements Observerable &#123; //集合用来保存订阅者对象引用 private List&lt;Observer&gt; list; //消息 private String message; public Uncle() &#123; list = new ArrayList&lt;Observer&gt;(); &#125; /** * 添加订阅者 */ public void registerObserver(Observer observer) &#123; list.add(observer); &#125; /** * 删除订阅者 */ public void removeObserver(Observer observer) &#123; if (!list.isEmpty()) &#123; list.remove(observer); &#125; &#125; /** * 通知订阅者，已经发布消息 */ public void notifyObserver() &#123; for (int i = 0; i &lt; list.size(); i++) &#123; Observer observer = list.get(i); observer.update(message); &#125; &#125; /** * 发消息，并通知订阅者 */ public void sendMoney(String message) &#123; this.message = message; System.out.println(message); notifyObserver(); &#125;&#125; 1234567891011121314151617181920212223242526/** * 订阅者接口 */public interface Observer &#123; void update(String message);&#125;/** * 订阅者 */public class Child implements Observer &#123; private String name; private String message; public Child(String name) &#123; this.name = name; &#125; //更新通知 public void update(String message) &#123; this.message = message; getMoney(); &#125; private void getMoney() &#123; System.out.println(name + "抢到了红包"); &#125;&#125; 1234567891011121314151617181920212223242526/** * 测试类 */public class TestObserver &#123; public static void main(String[] args) &#123; Uncle uncle = new Uncle(); Observer zhang = new Child("小张"); Observer li = new Child("小李"); Observer wang = new Child("小王"); Observer daNiang = new Child("大娘"); //添加订阅者 uncle.registerObserver(zhang); uncle.registerObserver(li); uncle.registerObserver(wang); uncle.registerObserver(daNiang); //发送消息 uncle.sendMoney("大爷发红包了"); System.out.println("============="); //订阅者取消订阅 uncle.removeObserver(daNiang); //再次发送消息，取消订阅的已经收不到消息 uncle.sendMoney("大爷又发红包了"); &#125;&#125; 1234567891011121314//实验结果D:\java\jdk\bin\java.exe ...大爷发红包了小张抢到了红包小李抢到了红包小王抢到了红包大娘抢到了红包=======================大爷又发红包了小张抢到了红包小李抢到了红包小王抢到了红包Process finished with exit code 0 总结 低耦合：可以看出，发布或订阅的一方发生改变都不会影响另一方。 jdk 也有自带的观察者模式，不过其被观察者是类不是接口，复用性降低。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm中对象的创建、布局和访问]]></title>
    <url>%2F2019%2F03%2F04%2FjvmObjectCreate%2F</url>
    <content type="text"><![CDATA[java堆中对象的创建、布局和访问1. 对象的创建创建对象的过程：类加载检查、分配内存、初始化零值、设置对象头、执行&lt;init&gt;方法 类加载检查：当我们用new关键字实例化对象时，最后到虚拟机执行的就变成 new 指令，虚拟机遇到一条 new 指令时，首先检查 new 指令的参数是否能在常量池中定位到这个类的符号引用，如果常量池中有符号引用，就检查这个符号引用的类是否已被加载、解析、初始化过。如果常量池没有该符号引用，那必须先将参数表示的类进行加载。 分配内存：对象需要的内存在经过类加载之后就可以确定，之后就在堆中划一块内存给这个对象，具体的划分内存的方式有两种： 指针碰撞：要求内存整齐，就是分配过对象的内存在一边，按照顺序分配。这样在最后一个对象尾部有一个指针，当要分配新对象时，就指针后移对象需要的距离分配给对象。 空闲列表：内存不是整齐的，使用过的和空闲的可能交错。虚拟机维护了一个”空闲列表”，列表上记录了空闲的内存区，当给对象分配内存，就从列表上找一块装得下该对象的内存给对象，同时将这块内存从列表中去掉。 思考：为什么有规整的和不规整的内存区域呢？因为和垃圾收集有关，有的内存经过垃圾收集之后内存是整齐的（复制算法、标记整理算法），有的收集之后就是不规整的（标记清除算法），详情参考我的《jvm内存分配与垃圾收集》一文。 （了解）如果涉及多线程分配内存呢？就是一个线程正在分配内存，指针还没开始移动，另一个线程就在原来的区域进行分配了，造成冲突。解决方式有两种： 同步处理：一个线程分配内存就上锁，别的线程不能同时分配。虚拟机采用CAS加失败重试方式更新。 TLAB(Thread Local Allocation Buffer)：本地线程分配缓冲。就是给每个线程在堆中先分配一块区域，线程在自己的内存区域给自己的对象分配内存。当有线程的TLAB用完了，继续向堆申请内存，就要采用同步的方式进行上锁了，不然其他的线程也要同时申请就又冲突了。 初始化零值：给对象分配内存后，jvm要将分配到的内存空间都初始化为零值，可以保证对象的实例字段在不赋初始值就直接使用，程序访问到的是这些字段的数据类型所对应的零值。（零值：如int是0，boolean是false，引用类型为null）。 设置对象头：之后要设置对象头，对象头包括对象是哪个类的实例、对象Hash值、对象GC的Age、类的元数据等。 执行&lt;init&gt;方法：经过以上步骤，对于虚拟机来说，一个新对象已经产生，但对java程序来说，对象创建才刚开始，因为所有字段还为零值，对象还没有根据程序员的意愿初始化。一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象初始化为程序员期望的值，这样一个真正可用的对象才算完全产生。 2. 对象的内存布局对象在内存中的布局分为三个区域：对象头、实例数据、对齐补充。 1. 对象头对象头包括两部分，第一部分是用于存储对象自身的运行时数据，另一部分是类型指针。 对象自身运行时数据：哈希吗、对象GC的Age、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。32bit/64bit（和虚拟机位数相同）。 类型指针：对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。32bit长度。 数组长度（可选）：如果对象是数组类型（String []），还需要32bit记录数组长度。 2. 实例数据 实例数据是对象真正存储的有效信息，即程序代码中定义的字段的实际值。 ​ 实例数据记录的数据包含父类继承下来的，自身定义的，子类定义的。而这几种数据的存储数据受虚拟机分配策略参数和字段在java源码中定义顺序影响。 3. 对齐补充 对齐补充没什么意义，只起占位符作用。 ​ 虚拟机要求对象的起始地址必须是8字节 的整数倍，即对象占的空间也得是8字节 的整数倍，因为对象头是8字节 的整数倍，实例数据大小不固定，所以需要对齐补充来补全实例数据为8字节的整数倍。 3. 对象的访问​ 我们知道具体对象是在堆中创建的，而我们的java程序是通过栈上的 reference 数据来引用具体对象。那么 reference 数据是怎么指向堆中的具体对象呢？ 访问对象的方式： 句柄访问：java堆中会划分出一块内存作为句柄池，句柄中保存的就是对象的实例数据（堆中）和类型数据（方法区中）具体地址。reference中存储的就是具体对象的句柄信息。 直接指针访问：直接指针方式就是reference中保存的就是对象在堆中的具体地址。而对象在方法区中的类型数据信息就由java堆去考虑。 两种方式比较： 使用句柄访问的话，对象被移动时（如垃圾收集中标记整理、复制算法对象的地址都会变动），只需要修改句柄中的地址，reference数据本身不需要变。 直接指针访问速度更快，不用先定位句柄，句柄在定位对象，节省一次定位时间。 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存雪崩 缓存穿透 缓存更新]]></title>
    <url>%2F2019%2F03%2F04%2FredisTopics%2F</url>
    <content type="text"><![CDATA[1. 缓存 提高性能：缓存查询速度比数据库查询速度快。 提高并发能力：缓存分担了部分请求，支持更高的并发。 2. 缓存雪崩概述 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端数据库系统带来很大压力。 如果缓存正常，那我们请求数据时，就会先走缓存，如果有的话，直接返回缓存里的数据，如果没有，就查询数据库，再返回结果。这样可以为数据库分担不小的压力。 因为Redis可以设置key的过期时间，在一定的时间之后，key就会过期，然后被自动删除。而如果现在缓存了一批数据，他们的key的过期时间都一样，一段时间后，这些数据全部被删除，如果此时有大量访问请求 Redis，而请求的数据刚好全被删除掉，那么这些请求就会全部访问数据库，导致数据库压力骤增。 总结： Redis 服务器系统挂掉，导致请求全部由数据库处理。 对缓存的数据设置相同的过期时间，导致某段时间缓存失效，请求也全由数据库处理。 如果发生缓存雪崩，那数据库很可能会崩溃，导致整个服务瘫痪。 缓存雪崩解决办法 Redis服务器宕机导致雪崩： 宕机前预防：实现 Redis 高可用。主从复制+哨兵机制。 宕机中补救：如果Redis挂掉，可以设置本地缓存，并且限制请求流量（限流），来保护数据库。 宕机后恢复：Redis 持久化机制。RDB/AOF机制来从磁盘加载，快速恢复缓存数据。 键过期时间导致雪崩： key不设置相同的过期时间就完事了。可以对过期时间设置一个随机值，减少过期时间相同的概率。 3. 缓存穿透概述 缓存穿透是指查询一个一定不存在的数据。由于数据肯定不存在，所以缓存中没有，该请求就会交由数据库处理，而数据库中也没有该数据，处于容错考虑，这个不存在的数据在数据库中的查询结果也不会写入缓存，这就会导致对这个不存在数据的每次请求都会走数据库去查询，这样缓存就没有意义了。 例如我的数据表有一些数据，ID是从1开始递增，没有负数。如果有一个闲人对我的数据库进行访问，每次访问的数据ID都是负数，这样我的Redis缓存中没有该数据，这些查询就会走数据库，数据库也没有对应数据，就会返回空对象，而且这个空对象也不会写到缓存中。如果这个闲人开始丧心病狂起来，疯狂访问我的数据库，这样我的数据库就会增加这些没必要的压力，早晚得完蛋。 总结： 请求的数据在缓存中大量都不命中，导致这些未命中的请求都走数据库。 缓存穿透解决办法 对于请求不合法的参数（请求不存在的数据），可以对其进行过滤（boomfilter或压缩filter），提前拦截。直接拒绝它，不让其走到数据库。编程复杂，不过比较省缓存空间。 对于合法的请求，但是数据库却找不到，我们也将这个空对象写到缓存，下次请求就可以从缓存中获取。不过这个空对象的存活时间一般会很短，很快就过期。编程简单，不过会占用缓存空间。 4. 缓存更新缓存流程一般缓存流程（读操作）： 对于一个请求，如果缓存中有请求的数据，就直接返回缓存中的数据。 如果缓存没有命中数据，就走数据库，之后将数据库查询的数据写入到缓存。 最后返回数据。 缓存与数据库双写一致如果对于写操作，我们要更新数据库，这时候没有更新缓存，导致缓存的数据和数据库的数据不一致。在没有发现缓存与数据库的数据不一致的这段时间内，如果有请求，走的是缓存，最后返回的数据就不是数据库中新更新的数据了。 幸运的是，Redis 中有键过期时间这一项，过期时间一到，缓存中的对应数据就会被删除，下次再请求就会走数据库，并将数据进行缓存，理论上可以保证缓存和数据库的数据一致。 如果在未过期的这段时间发生数据库更新，导致还是不一致呢？ 那就对缓存中的数据也进行更新吧… 更新操作可进行的更新操作： 先更新数据库，再更新缓存。 先更新缓存，再更新数据库。 对于上面两种操作，要么都成功，要么都失败，如果一个成功一个失败，那还是会有数据不一致的问题。 如果第一个更新操作（不论是先更新数据库还是先更新缓存）都失败了，那第二个更新也没必要了，直接抛出异常得了。 1. 操作缓存对数据没什么可操作的，更新就完事了，但是对于缓存可以有两种操作： 更新缓存 删除缓存 但是，如果在多线程高并发环境下，更新数据库和更新缓存容易导致线程安全问题，最后两者数据还是不一样。 再者，每次更新数据库还得附带上更新缓存，请求少还好，更新请求一旦多起来，性能上就会受影响，毕竟平白无故增加了额外的更新操作。 所以，一般都是采用删除缓存策略，直接删除，一了百了，简单又安全。一发生更新，就直接删除缓存里对应的数据，下次请求该数据直接请求数据库再缓存就完事了，数据还是一致的。 2. 先更新数据库，再删除缓存一般流程： 先更新数据库，成功 再删除缓存，成功 如果原子性被破坏，会发生什么呢？ 如果在更新数据库就失败了，就直接返回异常，缓存也不用删除了，这样两者数据还是旧数据，也是一致的。 更新数据库成功，删除缓存失败了，导致缓存里是旧数据，数据库里是新数据，导致数据不一致。 如果发生这种情况，就将要删除的key发送到消息队列，然后获取要删除的key，不断地进行删除，直到删除成功。 如果上面一般流程的操作都成功了，理论上是没问题的，但是在多线程并发环境下还是可能发生问题的，例如 缓存失效了，线程 A 查询数据，查询请求走数据库。 此时线程A的请求内容还没写进缓存，就被挂起了。 线程 B 更新数据，先更新数据库，完事又删除了缓存。 之后线程 A 又被调度了，将它查询数据库的旧数据写入缓存。 所以就又出现了缓存与数据库数据不一致的问题。 当然这种概率特别特别小，因为这是线程读写操作并发的条件下，写操作速度远慢于读操作，而且还要锁表，上述例子的条件必须要符合读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，这个条件概率又是特别小的。 3. 先删除缓存，再更新数据库一般流程： 先删除缓存，成功 再更新数据库，成功 如果原子性被破坏，会发生什么呢？ 如果删除缓存就失败了，就直接返回异常，也不用更新数据库了，这样两者的数据还是旧数据，也是一致的。 如果删除缓存成功，更新数据库失败了？那也没啥事，数据库没更新，缓存还删除了。下次请求数据库，数据再写入缓存，两者数据库还是一致的。 如果上面一般流程的操作都成功了，理论上是没问题的，但是在多线程并发环境下还是可能发生问题的，例如 线程 A 删除了缓存。 此时线程 A 的新数据还没更新到数据库，就被挂起了。 线程 B 被调度，查询操作，发现缓存没有命中，就去数据库查，然后在将旧数据写入到缓存。 线程 A 又被调度，接着执行上次未执行的操作，将讯数据更新到数据库。 所以，最后出现了两者数据不一致的问题。 解决办法： 将删除缓存、更新数据库、读取缓存等操作放到一个队列里，串行执行。 更新缓存的两种操作对比 先更新数据库，再删除缓存 高并发情况下比较好，极小的概率发生不一致问题，可认为不会发生。 原子性被破坏时，表现较差。 先删除缓存，再更新数据库 高并发环境下表现较差，容易发生不一致问题。 原子性被破坏时，表现较好，不会发生数据不一致问题。 参考 https://segmentfault.com/a/1190000017882763#articleHeader8]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、Redis五种基本数据类型]]></title>
    <url>%2F2019%2F03%2F03%2FredisValueOperation%2F</url>
    <content type="text"><![CDATA[一、Redis事务1、事务简介Redis中的事务是一组命令的集合，至少是两个或两个以上的命令，事务保证这些命令被执行时中间不会被任何其他操作打断。 2、事务操作的命令1. multi语法：multi作用：标记一个事务的开始。事务内的多条命令会按照先后顺序被放进一个队列中。在遇到exec之前，命令都不会执行。返回值：总是返回OK。 2、exec语法：exec作用：执行所有事务块内的命令返回值：事务内的所有执行语句内容，事务被打断返回nil。 3、discard语法：discard作用：取消事务，放弃执行事务块内的所有命令。返回值：总是返回ok。 4、watch语法：watch key [key…]作用：监视一个或多个key，如果事务执行之前这些key被其他命令改动，则事务被打断。。返回值：总是返回ok。 5、unwatch语法：watch key [key…]作用：取消watch命令对所有key的监视，如果在执行watch之后，exec或discard命令被执行了，那么就不需要再执行unwatch了。返回值：总是返回OK。 二、持久化1、持久化概述Redis的数据存储在内存中，内存是瞬时的，如果Linux宕机或重启，或者Redis崩溃或重启，所有的内存数据都会丢失，为了解决这个问题，Redis提供了两种机制对数据进行持久化存储，便于发生故障后能迅速恢复数据。 2、持久化方式1. RDB方式1. RDB介绍 Redis Database 内存快照，就是在指定的时间间隔内，将内存中的数据及快照写入到磁盘，数据恢复时将快照文件直接读到内存中。 RDB保存了某个时间点的数据集，存储在一个二进制文件中，默认是dump.rdb。RDB数据恢复时比AOF快。 默认启用RDB。 2. 配置RDBRDB是默认开启的持久化方式。 在redis.conf 文件中的SNAPSHOTTING模块中配置。 配置执行RDB生成快照文件的时间策略。格式：save seconds keychanges作用：只要满足在N秒内有M个key发生了变动这一策略，就生成快照，自动保存数据。save 900 1save 300 10save 60 10000 dbfilename：设置RDB的磁盘保存数据的文件名。 dir：指定RDB文件的存储位置，默认是 ./ 当前目录。 3. 总结优点： 由于存储的是数据快照文件，恢复数据比较快。缺点： 会丢失最后一次快照以后更改的数据。 由于需要经常操作磁盘，RDB会分出一个子进程，如果数据很大，子进程可能会占用比较多的时间。 2. AOF方式1. AOF介绍Append-only file，Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，不记录读操作），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。 2. AOF配置AOF默认是不开启的。 在redis.conf文件中修改： appendonly：默认是 no ，改成yes 即开启了AOF持久化。 appendfilename：指定AOF文件名，默认为 appendonly.aof。 dir：指定RDB和AOF文件存储位置，默认 ./ 当前目录。 appendfsync：配置项aof文件写命令数据的策略： no：不主动进行同步操作，完全由操作系统进行。速度快但不安全。 always：每次执行写入都会执行同步，慢但安全。 everysec：每秒执行一次同步操作，比较平衡。默认选项。 auto-aof-rewrite-min-size：允许重写的最小AOF文件大小，默认64M，当文件大于64M，开始整理AOF文件。去掉无用的操作命令，来缩小AOF文件。 三、主从复制1、主从复制-读写分离 通过RDB或AOF持久化，可以将内存数据保存在磁盘，数据不易丢失或丢失少量数据。如果磁盘损坏，仍然会丢失数据。 为避免单点故障，需要将数据复制多份，部署在多台不同的服务器上。可以保证即使偶一台服务器出现故障，其他服务器仍然可以提供服务。同时这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器，利用Redis的主从复制实现。 主Redis主要用于写操作，并将写后的操作同步到从Redis服务器上，从Redis服务器主要用于读操作，从而实现读写分离。 1. Redis主从复制的实现 修改配置文件，启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，从而构成主从复制关系。 主从测试：开启redis-server三次，三个进程代表三个服务器。主Redis的port为6380，两个从Redis的port为6382,6384。 新建三个Redis的配置文件 12345cp redis.conf redis6380.conf//将文件清空 &gt; redis6380.confcp redis6380.conf redis6382.confcp redis6380.conf redis6384.conf 编辑 主Redis 配置文件redis6380.conf 12345678include /usr/redis/redis.conf//设置为后台启动daemonize yesport 6380pidfile /var/run/redis_6380.pidlogfile 6380.log//指定RDB持久化文件dbfilename dump6380.rdb 编辑 从Redis 配置文件redis6382.conf,redis6384.conf 12345678include /usr/redis/redis.confdaemonize yesport 6382pidfile /var/run/redis_6382.pidlogfile 6382.logdbfilename dump6382.rdb//配置主Redis的 IP+Portslaveof 127.0.0.1 6380 2. 容灾处理 当Master服务出现故障，需手动将 Slave 中的一个提升为 Master，剩下的 Slave 挂至新的Master上（冷处理：机器故障，之后再处理） 命令： slaveof no one，将一台slave服务器提升为master。 slaverof 127.0.0.1 6381，将其他slave挂至新的master。 步骤： 将主Redis进程停掉，模拟主Redis故障。 将一个从Redis升级为主Redis。 1127.0.0.1:6382&gt;slaveof no one 将剩余的从Redis挂至新升级的主Redis上。 1127.0.0.1:6384&gt;slaveof 127.0.0.1 6382 原来的故障服务器修复后加入到现有的主从结构中 1127.0.0.1:6380&gt;slaveof 127.0.0.1 6382 2、高可用Sentinel哨兵1. Redis Sentinel（哨兵）简介 Sentinel哨兵是Redis官方提供的高可用方案，可以用它来监控多个Redis服务实例的运行情况。Redis Sentinel 是一个运行在特殊模式下的Redis服务器，Redis Sentinel是在多个Sentinel进程环境下互相协作的。 Sentinel系统主要任务： 监控：哨兵不间断地检查主Redis和从Redis是否按照预期正常工作。 提醒：被监控的Redis出现问题时，哨兵会通知管理员或其他应用程序。 自动故障转移：监控的主Redis不能正常工作，哨兵会考试进行故障迁移操作， Sentinel哨兵系统通过监控主Redis，就可以间接监控从Redis。每个哨兵都会通过向Redis发送Ping命令来验证Redis是否正常（心跳检测）。Sentinel哨兵系统采用少数服从多数的方式，来决定Redis服务器是否正常，所以哨兵数量得是奇数个（至少有3个）。 三个定时任务： 每10秒每个sentinel会对master和slave执行info命令，这个任务达到两个目的：发现slave节点；确认主从关系。 每2秒每个sentinel通过master节点的channel交换信息。 每1秒每个sentinel对其他sentinel和redis节点执行ping操作（相互监控），这个其实是一个心跳检测，是失败判定的依据。 2. 配置Redis Sentinel系统 Sentinel配置文件哨兵配置文件默认为 sentinel.conf。哨兵系统默认port为 26379。复制三份 sentinel.conf，为三个哨兵的配置文件。 修改复制的配置文件 修改哨兵端口号 port 修改监控的主Redis的信息。 格式：sentinel monitor &lt;投票数&gt; 示例：sentinel monitor myMaster 127.0.0.1 6379 2 启动Redis主从复制 启动哨兵通过加载对应的配置文件来启动哨兵。默认前台启动，查看日志信息。 123redis-sentinel /usr/redis/sentinel26380.confredis-sentinel /usr/redis/sentinel26382.confredis-sentinel /usr/redis/sentinel26384.conf 主Redis故障 主Redis发生故障后，哨兵系统会推选出一个从Redis作为主Redis，并自动将其他从Redis挂到新的主Redis上。 新的Redis加入到主从结构故障Redis修复后，重新加入到主从结构中，哨兵系统会监控并将其作为从Redis挂到主Redis下。 四、安全设置1、设置密码 简介: 访问Redis默认没有密码，不安全，需要设置需要密码登录访问Redis。在redis.conf文件中修改requirepass行来启用密码。 开启访问密码设置修改redis.conf，取消注释 requirepass 密码。 开启redis-server，并加载redis.conf文件 开启客户端 第一种：redis-cli -a passwd 第二种：redis-cli ，进去之后使用 auth passwd 方式来密码登录。 2、绑定IP 修改redis.conf文件，把# bind 127.0.0.1 前面的注释去掉，并将IP地址改为可以访问redis服务器的地址，表示只允许这些IP进行访问。多个IP地址使用空格分隔。 #bind 192.168.0.100 192.168.0.101 3、修改默认端口 修改redis的端口，不使用默认端口，将redis.conf文件中的port改为自定义端口，范围 1024-65535 。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、高级话题 - 事务，持久化，主从复制，安全设置]]></title>
    <url>%2F2019%2F03%2F03%2FredisOtherTopics%2F</url>
    <content type="text"><![CDATA[一、Redis事务1、事务简介Redis中的事务是一组命令的集合，至少是两个或两个以上的命令，事务保证这些命令被执行时中间不会被任何其他操作打断。 2、事务操作的命令1. multi语法：multi作用：标记一个事务的开始。事务内的多条命令会按照先后顺序被放进一个队列中。在遇到exec之前，命令都不会执行。返回值：总是返回OK。 2、exec语法：exec作用：执行所有事务块内的命令返回值：事务内的所有执行语句内容，事务被打断返回nil。 3、discard语法：discard作用：取消事务，放弃执行事务块内的所有命令。返回值：总是返回ok。 4、watch语法：watch key [key…]作用：监视一个或多个key，如果事务执行之前这些key被其他命令改动，则事务被打断。。返回值：总是返回ok。 5、unwatch语法：watch key [key…]作用：取消watch命令对所有key的监视，如果在执行watch之后，exec或discard命令被执行了，那么就不需要再执行unwatch了。返回值：总是返回OK。 二、持久化1、持久化概述Redis的数据存储在内存中，内存是瞬时的，如果Linux宕机或重启，或者Redis崩溃或重启，所有的内存数据都会丢失，为了解决这个问题，Redis提供了两种机制对数据进行持久化存储，便于发生故障后能迅速恢复数据。 2、持久化方式1. RDB方式1. RDB介绍 Redis Database 内存快照，就是在指定的时间间隔内，将内存中的数据及快照写入到磁盘，数据恢复时将快照文件直接读到内存中。 RDB保存了某个时间点的数据集，存储在一个二进制文件中，默认是dump.rdb。RDB数据恢复时比AOF快。 默认启用RDB。 2. 配置RDBRDB是默认开启的持久化方式。 在redis.conf 文件中的SNAPSHOTTING模块中配置。 配置执行RDB生成快照文件的时间策略。 格式：save seconds keychanges 作用：只要满足在N秒内有M个key发生了变动这一策略，就生成快照，自动保存数据。 save 900 1 save 300 10 save 60 10000 dbfilename：设置RDB的磁盘保存数据的文件名。 dir：指定RDB文件的存储位置，默认是 ./ 当前目录。 3. 总结优点： 由于存储的是数据快照文件，恢复数据比较快。缺点： 会丢失最后一次快照以后更改的数据。 由于需要经常操作磁盘，RDB会分出一个子进程，如果数据很大，子进程可能会占用比较多的时间。 2. AOF方式1. AOF介绍Append-only file，Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，不记录读操作），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。 2. AOF配置AOF默认是不开启的。 在redis.conf文件中修改： appendonly：默认是 no ，改成yes 即开启了AOF持久化。 appendfilename：指定AOF文件名，默认为 appendonly.aof。 dir：指定RDB和AOF文件存储位置，默认 ./ 当前目录。 appendfsync：配置项aof文件写命令数据的策略： no：不主动进行同步操作，完全由操作系统进行。速度快但不安全。 always：每次执行写入都会执行同步，慢但安全。 everysec：每秒执行一次同步操作，比较平衡。默认选项。 auto-aof-rewrite-min-size：允许重写的最小AOF文件大小，默认64M，当文件大于64M，开始整理AOF文件。去掉无用的操作命令，来缩小AOF文件。 三、主从复制1、主从复制-读写分离 通过RDB或AOF持久化，可以将内存数据保存在磁盘，数据不易丢失或丢失少量数据。如果磁盘损坏，仍然会丢失数据。 为避免单点故障，需要将数据复制多份，部署在多台不同的服务器上。可以保证即使偶一台服务器出现故障，其他服务器仍然可以提供服务。同时这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器，利用Redis的主从复制实现。 主Redis主要用于写操作，并将写后的操作同步到从Redis服务器上，从Redis服务器主要用于读操作，从而实现读写分离。 1. Redis主从复制的实现 修改配置文件，启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，从而构成主从复制关系。 主从测试：开启redis-server三次，三个进程代表三个服务器。主Redis的port为6380，两个从Redis的port为6382,6384。 新建三个Redis的配置文件 12345cp redis.conf redis6380.conf//将文件清空 &gt; redis6380.confcp redis6380.conf redis6382.confcp redis6380.conf redis6384.conf 编辑 主Redis 配置文件redis6380.conf 12345678include /usr/redis/redis.conf//设置为后台启动daemonize yesport 6380pidfile /var/run/redis_6380.pidlogfile 6380.log//指定RDB持久化文件dbfilename dump6380.rdb 编辑 从Redis 配置文件redis6382.conf,redis6384.conf 12345678include /usr/redis/redis.confdaemonize yesport 6382pidfile /var/run/redis_6382.pidlogfile 6382.logdbfilename dump6382.rdb//配置主Redis的 IP+Portslaveof 127.0.0.1 6380 2. 容灾处理 当Master服务出现故障，需手动将 Slave 中的一个提升为 Master，剩下的 Slave 挂至新的Master上（冷处理：机器故障，之后再处理） 命令： slaveof no one，将一台slave服务器提升为master。 slaverof 127.0.0.1 6381，将其他slave挂至新的master。 步骤： 将主Redis进程停掉，模拟主Redis故障。 将一个从Redis升级为主Redis。 1127.0.0.1:6382&gt;slaveof no one 将剩余的从Redis挂至新升级的主Redis上。 1127.0.0.1:6384&gt;slaveof 127.0.0.1 6382 原来的故障服务器修复后加入到现有的主从结构中 1127.0.0.1:6380&gt;slaveof 127.0.0.1 6382 2、高可用Sentinel哨兵1. Redis Sentinel（哨兵）简介 Sentinel哨兵是Redis官方提供的高可用方案，可以用它来监控多个Redis服务实例的运行情况。Redis Sentinel 是一个运行在特殊模式下的Redis服务器，Redis Sentinel是在多个Sentinel进程环境下互相协作的。 Sentinel系统主要任务： 监控：哨兵不间断地检查主Redis和从Redis是否按照预期正常工作。 提醒：被监控的Redis出现问题时，哨兵会通知管理员或其他应用程序。 自动故障转移：监控的主Redis不能正常工作，哨兵会考试进行故障迁移操作， Sentinel哨兵系统通过监控主Redis，就可以间接监控从Redis。每个哨兵都会通过向Redis发送Ping命令来验证Redis是否正常（心跳检测）。Sentinel哨兵系统采用少数服从多数的方式，来决定Redis服务器是否正常，所以哨兵数量得是奇数个（至少有3个）。 三个定时任务： 每10秒每个sentinel会对master和slave执行info命令，这个任务达到两个目的：发现slave节点；确认主从关系。 每2秒每个sentinel通过master节点的channel交换信息。 每1秒每个sentinel对其他sentinel和redis节点执行ping操作（相互监控），这个其实是一个心跳检测，是失败判定的依据。 2. 配置Redis Sentinel系统 Sentinel配置文件 哨兵配置文件默认为 sentinel.conf。哨兵系统默认port为 26379。 复制三份 sentinel.conf，为三个哨兵的配置文件。 修改复制的配置文件 修改哨兵端口号 port 修改监控的主Redis的信息。 格式：sentinel monitor &lt;投票数&gt; 示例：sentinel monitor myMaster 127.0.0.1 6379 2 启动Redis主从复制 启动哨兵 通过加载对应的配置文件来启动哨兵。默认前台启动，查看日志信息。 123redis-sentinel /usr/redis/sentinel26380.confredis-sentinel /usr/redis/sentinel26382.confredis-sentinel /usr/redis/sentinel26384.conf 主Redis故障 主Redis发生故障后，哨兵系统会推选出一个从Redis作为主Redis，并自动将其他从Redis挂到新的主Redis上。 新的Redis加入到主从结构 故障Redis修复后，重新加入到主从结构中，哨兵系统会监控并将其作为从Redis挂到主Redis下。 四、安全设置1、设置密码 简介: 访问Redis默认没有密码，不安全，需要设置需要密码登录访问Redis。在redis.conf文件中修改requirepass行来启用密码。 开启访问密码设置 修改redis.conf，取消注释 requirepass 密码。 开启redis-server，并加载redis.conf文件 开启客户端 第一种：redis-cli -a passwd 第二种：redis-cli ，进去之后使用 auth passwd 方式来密码登录。 2、绑定IP 修改redis.conf文件，把# bind 127.0.0.1 前面的注释去掉，并将IP地址改为可以访问redis服务器的地址，表示只允许这些IP进行访问。多个IP地址使用空格分隔。 #bind 192.168.0.100 192.168.0.101 3、修改默认端口 修改redis的端口，不使用默认端口，将redis.conf文件中的port改为自定义端口，范围 1024-65535 。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、Redis基本操作]]></title>
    <url>%2F2019%2F03%2F03%2FredisKeyOperation%2F</url>
    <content type="text"><![CDATA[一、redis基础命令1、查看状态是否正常1ping 如果返回 PONG，则表示redis工作正常 2、查看当前数据库key的个数1dbsize 默认使用的是第0个库。 3、redis默认有16个库redis默认有16个库，从db0-db15。在redis-conf配置文件中可以修改redis的库数量。databases 16 4、选择redis数据库12//选择db5select 5 选择指定索引的redis数据库。 5、删除当前库中的数据1flushdb 6、退出redis命令行客户端12exitquit 只是表示退出客户端，redis-server仍然在运行中。 二、redis的key的操作命令Redis命令中文手册 1、keys语法：keys pattern作用：查找当前库中所有符合pattern模式的key通配符： ：表示0-n个字符，例如 keys ：查询所有key ?：表示单个字符，例如keys wo?d ，表示查询word,wood等的key。 []：查询[]内的字符组合，例如keys h[ae]llo，表示查询hallo,hello两个key。 2、exists语法：exists key作用：检查key是否存在。存在返回1，不存在返回0。注意：可以同时查询多个key是否存在，返回存在的key的个数。例如exists k1 k2 k3 3、expire语法：expire key seconds作用：设置key的生存时间，过时自动删除key，单位秒。设置成功返回1，失败返回0 。 4、ttl语法：ttl key作用：查询key的剩余生存时间。返回值： -2：key不存在或已过期 -1：key永不过期 n：key的剩余生存时间为n。 5、type语法：type key作用：查询key存储的value类型。返回值： none（key不存在） string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) 6、del语法：del key作用：删除某个或某些key，如果key存在的话。返回值：返回被删除的key的数量，不存在的key会被忽略。例如，del k1 k2 k3 k4 7、rename语法：rename key newkey作用：为一个key改名，如果newkey已经存在，则newkey的值会被key值替代。返回值：返回被删除的key的数量，不存在的key会被忽略。例如，1234set hello helloset world worldrename hello worldget world 得到 hello 8、randomkey语法：randomkey作用：随机返回一个当前数据库存在的key。例如，randomkey]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、Redis安装与启动]]></title>
    <url>%2F2019%2F03%2F03%2FredisStart%2F</url>
    <content type="text"><![CDATA[一、Redis简介 Redis是一种基于键值对（key-value） 的NoSQL数据库， 与很多键值对数据库不同的是，Redis中的值可以是由string 、 hash 、list 、 set 、 zset 、 Bitmaps 、HyperLogLog、 GEO（地理信息定位）等多种数据结构和算法组成， 因此Redis可以满足很多的应用场景。因为Redis会将所有数据都存放在内存中， 所以它的读写性能很强。 不仅如此， Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上， 这样在发生类似断电或者机器故障的时候， 内存中的数据不会丢失。 除了上述功能以外， Redis还提供了键过期、 发布订阅、 事务、 流水线、 Lua脚本等附加功能。 二、安装与启动1、下载源码包 www.redis.io1wget http://download.redis.io/releases/redis-5.0.3.tar.gz 2、解压源码包1tar -zx -f redis.tar.gz 3、编译安装redis注意：编译需要gcc。123$ cd redis$ make //编译之后会在目录中产生src目录，内含可执行文件执行redis-server来开启redis。$ make install //执行该操作后，会讲src目录中的可执行文件加入到/usr/bin目录下，可直接启动。 4、启动redis123456//前台启动，退出命令行即退出redis./usr/redis/src/redis-server //后台启动./usr/redis/src/redis-server &amp; //使用配置文件进行启动，可将自定义配置写入配置文件，在redis启动时会自动读取配置文件。./usr/redis/src/redis-server /usr/local/redis/redis-conf &amp; 5、关闭redis12//正在执行的请求执行完毕后关闭./usr/redis/src/redis-cli shutdown 6、后台运行redis，日志输出到nohup.out12//nohup.out在当前目录下nohup ./usr/redis/src/redis-server &amp; 三、Redis客户端1、Redis命令行客户端 直接连接Redis（默认连接本机的Redis）1./redis-cli 默认的ip：127.0.0.1，port：6379。 指定IP与port连接Redis1./redis-cli -h hostname -p port 2、Redis远程客户端通过远程客户端来操作Redis数据库。类似于通过navicat工具操作MySQL数据库。 Redisclient.jar 注意：Redis远程客户端使用需要进行一定的配置。 配置redis.conf文件 12#bind 127.0.0.1 //注释绑定本机protected-mode no //默认为yes表示开启保护模式，需关闭 开启Redis需要加载配置文件 1./usr/redis/src/redis-server /usr/redis/redis.conf 3、Redis编程客户端通过某种语言的编程客户端来操作Redis。 jedis：是java语言操作Redis的编程客户端。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F03%2F01%2FBubbleSort%2F</url>
    <content type="text"><![CDATA[概述给定一组无序的数据，从第一个数据开始，依次向后比较，如果后面的数据小于该数据，就将两者调换，如果后面数据大于该数据，指针后移，继续进行这样的比较，经过一次循环比较后，该数据集中最大的数据就会移到最后，就像冒泡一样。 冒泡算法冒泡过程： 设置一个指针指向第一个元素。比较相邻的元素，如果第一个比第二个大，就交换他们两个，指针后移；否则，指针直接后移。 指针后移后，仍然进行（1）中的操作，直至指针到达数组末尾。 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。 持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。 实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BubbleSort &#123; public static void main(String[] args) &#123; int []arr=new int[]&#123;12,35,99,18,76&#125;; arr = bubbleSort2(arr); for (int a : arr) &#123; System.out.print(a+" "); &#125; &#125; //未优化版本 /*private static int[] bubbleSort(int[] arr) &#123; //控制冒泡次数 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //每一轮冒泡进行比较 for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125;*/ /** * 优化版本 */ private static int[] bubbleSort2(int []arr)&#123; int temp; //临时变量 int num = 0; //记录执行次数 int isChange; //表示循环中是否发生了交换 for (int i = 0; i &lt; arr.length-1; i++) &#123; isChange = 0; for (int j=0;j&lt;arr.length-i-1;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; isChange = 1; //为1标识进行了交换 &#125; &#125; // 如果这次排序期间没有发生交换，则表示当前顺序已经是有序 // 即后续的排序都不会发生交换，直接结束 if (isChange == 0) break; num++; &#125; return arr; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>八大排序</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F03%2F01%2FQuickSort%2F</url>
    <content type="text"><![CDATA[概述快速排序采用分治策略，分而治之。 分治法：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 快排原理 在数据集之中，选择一个元素作为 “基准”（pivot）。 所有小于”基准”的元素，都移到“基准”的左边；所有大于”基准”的元素，都移到“基准”的右边。这个操作称为“分区”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。即基准左边的都比基准小，右边都比基准大，所以无论左右怎么变化，基准都是有序的了。 对“基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。这样整个数据集都是有序的了。 实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class QuickSortTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;5,2,9,6,4,8,3,1,7,0&#125;; QuickSort(arr, 0, 9); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+" "); &#125; &#125; /** * 每进行一次该方法都是将基准数归位的过程 * @param arr 待排序数组 * @param start 数组的起始位置 * @param end 数组的终止位置 */ private static void QuickSort(int[] arr, int start, int end) &#123; //判断arr是否符合规则 if (start &gt; end) return; //设置标准数 int stand = arr[start]; int low = start; int high = end; //循环操作，将大于stand的数移至右侧，小于stand的数移至左边 while (low &lt; high) &#123; //low和high会动态变化，因此需添加判断条件low&lt;high //循环判断右边，找到第一个比基准数小的数 while (arr[high] &gt;= stand &amp;&amp; low &lt; high) &#123; high--; &#125; //循环判断左边，找到第一个比基准数大的数 while (arr[low] &lt;= stand &amp;&amp; low &lt; high) &#123; low++; &#125; //将找到的右边小于基准数的数和左边大于基准数的数调换 if (low &lt; high) &#123; int t = arr[low]; arr[low] = arr[high]; arr[high] = t; &#125; &#125; //循环完成后，最终low和high交点位置就是基准数的位置 arr[start] = arr[low]; arr[low] = stand; //递归处理基准数左边的数组 QuickSort(arr, start, low - 1); //递归处理基准数右边的数组 QuickSort(arr, low + 1, end); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>八大排序</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F03%2F01%2FjavaProxy%2F</url>
    <content type="text"><![CDATA[概述 代理模式是Java常见的设计模式之一。所谓代理模式是指客户端并不直接调用实际的对象，而是通过调用代理，来间接的调用实际的对象。 代理就是代替别人做别人不想做的事情的意思。 举例来说，歌神要开演唱会，如果他没有经纪人的话，唱歌前的租场地、签合同、买车票机票，唱歌后的收钱等工作全都得自己来做，但是歌神专职是唱歌的，其他的工作自己可以做但没必要，如果能只专注如何在演唱会唱好歌，如何在演唱会上调动气氛就最好了。 于是歌神签约了一个经纪人，唱歌前的工作和唱歌后的工作就不需要自己做了，经纪人会帮他处理，自己只需要专注于唱歌就完事了。 对于歌神来说，经济人就是代理对象，实际对象（歌神）不想做的事情，可以交由代理对象（经济人）来做。如果代理对象不能做的事情，比如到了唱歌时间了，代理对象（经纪人）不会唱，还是得由实际对象（歌神）来完成唱歌这个动作。 几种代理模式静态代理代理模式有三个角色，分别是抽象主题（一个接口）、代理对象、委托对象。 抽象主题：将代理对象和委托对象能做的事情抽象起来。代理对象和委托对象都要实现此接口。 委托对象：就是实际对象，对于实现接口中的方法，都可以交由代理对象处理。 代理对象：委托对象委托给自己的事情，能做的都会做，不能做的再让委托对象自己做。 当客户端需要找实际对象（歌神）办事时（开演唱会），实际上是直接找的代理对象（经纪人），是客户端是接触不到实际对象的，而对于代理对象无法完成的工作，代理对象会去找十几对象来完成。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 抽象接口interface Subject &#123; void buyTicket(); void SingSong(); void getMoney();&#125;//委托类public class RealSubject implements Subject &#123; @Override public void buyTicket() &#123; System.out.println("歌神买机票"); &#125; @Override public void SingSong() &#123; System.out.println("歌神唱歌"); &#125; @Override public void getMoney() &#123; System.out.println("歌神收出场费"); &#125;&#125;//代理类public class ProxySubject implements Subject &#123; private RealSubject realSubject; public ProxySubject(RealSubject realSubject) &#123; this.realSubject = realSubject; &#125; @Override public void buyTicket() &#123; System.out.println("给歌神买票"); &#125; @Override public void SingSong() &#123; System.out.println("经济公司不会唱歌，还得请歌神来唱歌"); realSubject.SingSong(); &#125; @Override public void getMoney() &#123; System.out.println("替歌神收出场费"); &#125;&#125; 1234567891011121314// 客户端联系经济人请歌神开演唱会public class Client &#123; public static void main(String[] args) &#123; // 实际对象（歌神） RealSubject realSubject = new RealSubject(); // 代理对象（经纪人） ProxySubject proxySubject = new ProxySubject(realSubject); proxySubject.buyTicket(); // 这里调用的是经济人唱歌，但是内部还是调用的歌神对象的唱歌方法 proxySubject.SingSong(); proxySubject.getMoney(); &#125;&#125; 12345678// 执行结果D:\java\jdk\bin\java.exe ...给歌神买票经济公司不会唱歌，还得请歌神来唱歌歌神唱歌替歌神收出场费Process finished with exit code 0 动态代理对于静态代理来说，我们需要为每个实际对象撰写特定的代理对象，显然这样做并不灵活，我们希望可以有一个公用的代理，可以动态的实现对不同实际对象的代理，这就是动态代理。动态代理时通过反射实现的。 举例来说，歌神（实际对象）签了环球唱片经济公司（代理中介），公司为歌神指定了一个经纪人（代理对象），而这个经济公司不止有歌神一个艺人，每签一个艺人就为这个艺人生成一个经纪人（代理对象）。 1. jdk动态代理需要的接口： java.lang.reflect.Proxy：动态生成代理类对象； java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对实际角色的代理访问。 每个代理中介（经纪公司）都需要实现InvocationHandler接口，并实现其中的invole方法，在方法中生成并返回实际对象（歌神）的代理对象（经纪人）. 代码示例： 123456789101112131415161718192021//抽象接口interface Subject &#123; void buyTicket(); void SingSong(); void getMoney();&#125;//委托类public class RealSubject implements Subject &#123; @Override public void buyTicket() &#123; System.out.println("歌神买机票"); &#125; @Override public void SingSong() &#123; System.out.println("歌神唱歌"); &#125; @Override public void getMoney() &#123; System.out.println("歌神收出场费"); &#125;&#125; 123456789101112131415161718192021222324252627282930//代理中介public class DynamicProxyHandler implements InvocationHandler &#123; //指明实际对象 private Object realSubject; public DynamicProxyHandler(Object realSubject) &#123; this.realSubject = realSubject; &#125; /** * 代理中介的处理器方法。该方法里面在再调用委托对象的具体方法。 * * @param proxy 代理类 * @param method 要调用的代理类的方法 * @param args 要调用的代理类方法的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //在唱歌方法前添加逻辑 if (method.getName().equals("SingSong"))&#123; System.out.println("歌神，演唱前来片润喉糖..."); method.invoke(realSubject,args); System.out.println("歌神，演唱完毕了，请您好好休息..."); &#125; else&#123; //对于其他方法，直接调用委托对象对应的方法 return method.invoke(realSubject, args); &#125; return null; &#125;&#125; 123456789101112131415//客户端public class DynamicClient &#123; public static void main(String[] args) &#123; //创建委托类对象 Subject realSubject = new RealSubject(); //创建代理中介（指定委托类对象） DynamicProxyHandler handler = new DynamicProxyHandler(realSubject); //生成代理对象 Subject proxyObject = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(), new Class[]&#123;Subject.class&#125;, handler); proxyObject.buyTicket(); proxyObject.SingSong(); proxyObject.getMoney(); &#125;&#125; 123456789//实验结果D:\java\jdk\bin\java.exe ...歌神买机票歌神，演唱前来片润喉糖...歌神唱歌歌神，演唱完毕了，请您好好休息...歌神出场费Process finished with exit code 0 解释生成代理对象方法： Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandle handler) ClassLoader：指定类加载器来生成代理对象，一般使用委托类对象的类加载器。 Class&lt;?&gt;[]：通过接口指定要生成哪个对象的代理对象（指定委托类实现的接口）。 InvlcationHandler：指定代理中介，代理对象调用的方法都会经过代理中介的invoke方法进行处理。对于指定的方法，可以在其执行前后加上自定义的逻辑处理代码。 实际上，代理对象调用每个方法，都会经过代理中介的invoke方法处理（Method method参数），最后实际还是调用的委托对象的方法。 不过我们可以在想要的方法前后添加一些逻辑，比如上面例子中在 SingSong 方法前添加了一些代码。 2. cglib动态代理对于上面的jdk动态代理来说，jdk动态代理只能为实现了接口的委托类来生成代理对象Proxy.newProxyInstance(.., Class&lt;?&gt;[] interfaces,..)，也就意味着**jdk动态代理是针对接口实现**的。 如果一个一个类没有实现接口，怎么生成代理对象呢？这就需要cglib动态代理了。 cglib动态代理 是 针对类实现的。原理是为目标类生成一个子类，覆盖其中的方法并在目标类方法的执行前后执行一些操作实现方法增强，但是因为采用的是继承关系，所以不能对final修饰的类实现代理（如String）。 实例代码： 123456789101112131415161718192021//拦截器类，用来拦截代理类的方法，并进行一些处理public class SongerMethodInterceptor implements MethodInterceptor &#123; /** * @param target 动态生成的代理类实例 * @param method 代理对象调用的方法 * @param objects 调用的方法参数 * @param methodProxy 代理类对方法的代理引用（引用的委托类的方法） */ @Override public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; if (method.getName().equals("SingSong")) &#123; System.out.println("歌神，演唱前来片润喉糖..."); methodProxy.invokeSuper(target, objects); System.out.println("歌神，演唱完毕了，请您好好休息..."); &#125; else &#123; return methodProxy.invokeSuper(target,objects); &#125; return null; &#125;&#125; 123456789101112131415161718//测试类public class Testcglib &#123; public static void main(String[] args) &#123; //cglib字节码增强器，可以对处理的委托类进行扩展 Enhancer enhancer = new Enhancer(); //继承委托类 enhancer.setSuperclass(Songer.class); //设置拦截器 enhancer.setCallback(new SongerMethodInterceptor()); //生成代理类对象 Songer songerProxy = (Songer) enhancer.create(); //在调用代理类中方法时会被我们实现的方法拦截器SongerMethodInterceptor拦截 //所以所有代理类的方法调用最终都会执行到interceptor()方法中 songerProxy.butTicket(); songerProxy.SingSong(); songerProxy.getMoney(); &#125;&#125; 123456789//实验结果D:\java\jdk\bin\java.exe ...买机票歌神，演唱前来片润喉糖...歌神唱歌歌神，演唱完毕了，请您好好休息...拿出场费Process finished with exit code 0 静态代理与动态代理 静态代理要自己编写代理类，并且代理类和委托类实现相同的接口。而动态代理的代理类是动态生成的。 动态代理生成代理对象只要指定接口参数，代理对象会默认实现接口中的全部方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联合索引的最左前缀匹配原则]]></title>
    <url>%2F2019%2F02%2F28%2FDBIndexLeft%2F</url>
    <content type="text"><![CDATA[表结构： 12345678CREATE TABLE `abcd` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`a`), KEY `inx_b_c_d` (`b`,`c`,`d`),) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 该表有 4 列，其中有一个联合索引由b,c,d三列联合。 一、联合索引索引可以是一个列(a)，而由多个列组成的索引(b,c,d)就称为联合索引（复合索引）。 联合索引的排序是由做到右排序的，首先根据b排序，之后对于b值相同的记录，再根据c排序，以此类推，所以c的顺序是建立在b等值的基础上的。 对于c来说，如果不考虑b的话，c 本身仍然是无序的。如下，对于相等的 b 来说，c 是有序的。 b c d 1 2 4 1 3 3 2 1 5 3 4 1 4 3 3 4 5 6 4 6 4 6 2 7 7 1 8 二、什么是最左前缀匹配 首先明确，最左前缀匹配原则是发生在联合索引上的。 最左前缀匹配就是根据建立的联合索引的顺序来匹配查询语句的条件。 对于一个联合索引，可以看做是多个索引的组合，例如前面的根据(b,c,d)建立的索引，就具有(b)、(b,c)、(b,c,d)这三个索引的作用。所以对于任何一个查询语句来说，只要有 b 条件就会使用索引查询，之后在看有没有 c ，d 而已。 对于上表的联合索引顺序(b,c,d) 当执行了一条查询语句时，查询的条件是根据 b,c,d 作为条件的，例如SELECT * FROM abcd WHERE b=2 and c=5 and d=1;这条语句会使用联合索引inx_b_c_d进行查询。 当执行了一条查询语句时，查询的条件是根据 b,c 作为条件的，如SELECT * FROM abcd WHERE b=2 and c=5;这条语句也会使用联合索引inx_b_c_d进行查询。 而对于以 c,d 作为查询条件是无法使用联合索引inx_b_c_d进行查询的，因为它不是以 b 开始的，上面说了，脱离了 b ，c 就是无序的，既然无序，索引页没有意义了，总不能对无序的数据列使用二分查找吧。 那如果查询条件是 b,d 呢？当然也会使用联合索引的，但是索引只匹配到了(b)，d 是无法使用索引查询的。 所以说，最左匹配就是从索引的左边开始匹配给定的条件项。如果没有最左边的那一列，那后面都是无序的了，也就不能使用索引了。 那如果查询条件和索引顺序不一致呢？ 即查询语句如果是 SELECT * FROM abcd WHERE c=5 and d=1 b=2 and; 呢？对于这个查询语句，最后执行的时候，条件的顺序会被mysql查询优化器转换成 b,c,d 的顺序的。 查询优化器会自动判断这条语句以什么形式执行起来效率会更高，最后将语句纠正为效率最高的形式。例如对于上面的语句来说，如果不纠正，就无法使用联合索引，就需要一个个记录的来查询搜索，效率肯定地，而如果调换查询条件顺序为 b,c,d 顺序的话，就可以使用联合索引了，效率会更高（拙见，不知道可不可以这么理解）。 当然最左匹配对于查询条件还是有要求的： 最左匹配向右依次匹配，如果遇到范围查询条件(&gt;、&lt;、between、like)就会停止匹配。例如b = 2 and c &gt; 3 and d = 4如果建立(b,c,d)顺序的索引，d是用不到索引的。 查询条件中 = 和 in 可以乱序，比如b = 1 and c = 2 and d = 3建立(b,c,d)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式。]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂设计模式（简单工厂、工厂方法、抽象工厂）]]></title>
    <url>%2F2019%2F02%2F28%2FjavaFactory%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式概述 简单工厂模式又叫做静态工厂方法（Static Factory Method）模式，但不属于GOF23种设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 举例来说，有一个汽车工厂，用来生产各种汽车（奔驰、奥迪、大众等等），当你需要什么车就告诉工厂我要什么品牌的车，工厂就会生产出对应品牌的车供你使用。 对应于代码中，工厂就是一个Factory对象，各种汽车就是一个Car接口，各种品牌的车就是Car的具体实现类，工厂生产车就是CreateCar(String Paizi)方法，通过用户指定的品牌作为参数，来生产对应的车，返回一个车对象Car c = new Audi(); 实例代码：123456789101112131415161718192021/** * 定义要生产的东西 *///汽车接口interface Car&#123; void run();&#125;//Car实现类Audi车class Audi implements Car&#123; public void run()&#123; System.out.println("奥迪在飞驰。"); &#125;&#125;//Car实现类QQ车public class QQ implements Car &#123; @Override public void run() &#123; System.out.println("奇瑞QQ在飞驰！"); &#125;&#125; 1234567891011//汽车工厂public class SimpleFactory &#123; public static Car createCar(String type)&#123; if ("奥迪".equals(type)) return new Audi(); else if("QQ".equals(type)) return new QQ(); else return null; &#125;&#125; 123456789//用户提车public class TestSimpleFactory&#123; public static void main(String[] args)&#123; //用户喜提奇瑞QQ车 Car c1 = SimpleFactory.createCar("QQ"); //用户喜提奥迪车 Car c2 = SimpleFactory.createCar("奥迪"); &#125;&#125; 总结 优点：简单工厂模式可以根据外界给定的信息，创建出对应的类的实例，明确区分了各自的职责。 缺点：如果工厂升级，可以创建更多牌子的车，那必须要在工厂的源码中进行添加修改的操作，就违反了“面向对象设计原则的开闭原则：对扩展开放，对修改关闭”。 二、工厂方法模式概述 工厂方法模式又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。工厂方法模式属于GOF23种设计模式。 举例来说，还是上面的车厂，随着车厂的规模越来越大，一个工厂显然不够用，于是就要有分厂，和平时的分厂不一样，他们的分厂是按照生产的车的品牌分的，而总厂是用来指导分厂应该有什么工作的，比如生产车、修车等。 对应于代码中，总厂就是一个Factory接口，分厂就是具体的工厂接口的实现类AudiFactory、QQFactory等类，是根据生产车的品牌划分。每种分厂只能生产一种品牌的车子。工厂的作用（生产车、修车等）也是根据总厂的指示实现对应的createCar()等方法。 实例代码1234567891011121314151617181920/** * 要生产的汽车同上面的代码（Car、Audi、QQ） *///汽车总厂interface CarFactory&#123; Car createCar();&#125;//奥迪分厂class AudiFactory implements CarFactory&#123; public Car createCar()&#123; return new Audi(); &#125;&#125;//奇瑞QQ分厂class QQFactory implements CarFactory&#123; public Car createCar()&#123; return new QQ(); &#125;&#125; 123456789//用户提车public class FactoryTest &#123; public static void main(String[] args) &#123; //用户喜提奇瑞QQ Car qq = new QQFactory().createCar(); //用户喜提Audi车 Car audi = new AudiFactory().createCar(); &#125;&#125; 总结优点： 完全符合开闭原则。如果工厂开拓业务，需要增加生产奔驰车，则只需要开设一个奔驰分厂（BenchiFactory implements CarFactory），而其他的代码不需要修改，实现了对扩展开放。 缺点： 实现起来比简单工厂复杂。比如结构较复杂（工厂较多，简单工厂只有一个工厂），代码较复杂，客户端编程复杂等。 理论上，工厂方法模式较好，但实际上，简单工厂使用的还是多一点。 三、抽象工厂模式概述 抽象工厂模式用来生产不同产品族的全部产品。（无法新增某个产品族的单个产品，只能增加产品族）。 抽象工厂模式是工厂方法模式的升级，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种很好的模式。 什么是产品族？举例来说，汽车由很多部件组成，例如发动机、轮胎、座椅等。而这些部件不同的工厂生产的又不一样，所以这三个部件对应一个产品族，不同的部件组合就是不同的产品族。 对于代码中，总厂（CarFactory）来指示分厂生产不同的产品族（高端汽车NBCarFactory、低端汽车LBCarFactory），而分厂又调用不同配件厂的高低端配件（高端发动机NBEngine、低端发动机LBEngine等等）来生产对应的产品族汽车。 实例代码123456789101112131415161718192021222324252627282930313233343536//发动机接口public interface Engine &#123; void info();&#125;//高端发动机实现类class NBEngine implements Engine &#123; @Override public void info() &#123; System.out.println("配备高端引擎"); &#125;&#125;//低端发动机实现类class LBEngine implements Engine &#123; @Override public void info() &#123; System.out.println("配备低端引擎"); &#125;&#125;//轮胎接口interface Luntai&#123; void info();&#125;//高端轮胎实现类class NBLuntai implements Luntai&#123; @Override public void info() &#123; System.out.println("配备高端轮胎"); &#125;&#125;//低端轮胎实现类class LBLunTai implements LunTai &#123; @Override public void info() &#123; System.out.println("配备低端轮胎"); &#125;&#125; 12345678910111213141516171819202122232425262728293031/** * CarFactory总工厂接口，可以有不同的分厂来生产不同的产品族 */public interface CarFactory &#123; Engine createEngine(); LunTai createLunTai();&#125;//高端汽车工厂实现类（高端分厂）class NBCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new NBEngine(); &#125; @Override public LunTai createLunTai() &#123; return new NBLunTai(); &#125;&#125;//低端汽车工厂实现类（低端分厂）public class LBCarFactory implements CarFactory&#123; @Override public Engine createEngine() &#123; return new LBEngine(); &#125; @Override public LunTai createLunTai() &#123; return new LBLunTai(); &#125;&#125; 123456789public class TestAbstractFactory&#123; public static void main(String[] args)&#123; //创建高端产品工厂 CarFactory NBFactory = new NBCarFactory(); //获得高端产品族组件 Engine NBengine = NBFactory.createEngine(); Luntai NBLuntai = NBFactory.createLuntai(); &#125;&#125; 总结对于抽象工厂模式来说，添加工厂只能添加一个整的产品族，比如增加中端工厂（高端发动机+低端轮胎），无法增加单个产品。 四、工厂模式应用场景 JDBC中Connection对象的获取 Mybatis中SessionFactory创建Session对象 Spring的IoC容器中创建管理 bean 反射中 Class 对象的newInstance()]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F02%2F28%2FjavaSingleton%2F</url>
    <content type="text"><![CDATA[作用在应用程序中保证最多只有一个实例对象。 应用场景 Spring 中，管理的每个Bean默认都是单例的。 Servlet 中，每个Servlet也都是单例的。 SpringMVC 中，控制器对象也都是单例的。 数据库连接池也是单例的，因为数据库资源只有一份，没必要每次都由新的对象加载。 项目中读取配置文件的类也是单例的，只有一个对象。配置文件只有一份，也没必要每次由新对象读取。 优点 单例模式只生成一个实例对象，效率较高。挡生成一个对象需要比较多的资源时（读取配置、产生其他依赖对象），就可以通过产生单例对象解决，然后该对象永久留在内存中。 单例模式可以在系统设置全局访问点，优化对共享资源的访问。例如设计一个单例类，负责所有数据表的映射。 实现方式1. 饿汉式 因为创建实例是在类初始化就创建的，不管是否使用它都会占用那一块内存，所以就没有了延时加载的优势。 实例代码： 12345678910111213141516package com.GOF.Singleton;public class SingletonDemo01 &#123; /** * 虚拟机加载类时，会立即加载该static变量，创建一个对象 * 因为类加载过程执行&lt;clinit&gt;()方法是加锁的，所以该例没有线程安全问题 */ private static SingletonDemo01 instance = new SingletonDemo01(); private SingletonDemo01() &#123; &#125; public static SingletonDemo01 getInstance() &#123; return instance; &#125;&#125; 2. 懒汉式 懒汉式采用延迟加载模式，每次需要使用时才去加载，不必在类初始化就创建对象，对资源利用率较高。 对于getInstance()方法由于每次调用都上锁，之后再进行判断是否已经有实例化对象，所以调用效率较低。 实例代码： 12345678910111213141516171819202122package com.GOF.Singleton;/** * 实现方式一：方法基础上的同步，调用效率低下 */public class SingletonDemo02 &#123; /** * 类初始化时，并没有初始化该对象，而是等到使用时才加载 */ private static SingletonDemo02 instance; private SingletonDemo02() &#123; &#125; /** * 方法进行同步，保证线程安全 */ public synchronized static SingletonDemo02 getInstance() &#123; if (instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 123456789101112131415161718192021222324252627282930package com.GOF.Singleton;/** * 实现方式二：双重检查锁改进 */public class SingletonDemo02 &#123; /** * 类初始化时，并没有初始化该对象，而是等到使用时才加载 * 如果不加volitale关键字，多线程环境下会出问题 */ private volitale static SingletonDemo02 instance; private SingletonDemo02() &#123; &#125; /** * 同步代码块实现同步，保证线程安全 */ public static SingletonDemo02 getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo02.class) &#123; if (instance == null) &#123; instance = new SingletonDemo02(); &#125; &#125; &#125; return instance; &#125;&#125;//在方法内部使用同步代码块，当已经创建实例对象时，多线程访问时，就不必再上锁，可以直接返回，调用效率自然也就高了。//同步代码块将第一次创建对象进行同步，来保证只会实例化一个对象。 两次null判断解释： 第一次null判断是同步代码块外的，用来判断是否已经有了实例对象。 第二次null判断是同步代码块中的。假若线程 A 第一次判断 null 成功，即将进行对象的实例化，此时CPU将其挂起，线程 B 进来了，此时判断也为空，也进行实例化，而线程 B 成功实例化了，退出了。之后线程 A 又被调度，开始从同步代码块执行（上锁），因为之前 B 已经实例化了一个对象，如果代码块中不进行 null 判断的话，线程 A 又会实例化一个新对象，就不符合单例模式了。 双重检查锁方法的问题（多线程环境）： 先上双重检查锁相关代码： 12345678910public static SingletonDemo02 getInstance() &#123; if (instance == null) &#123; //(1) synchronized (SingletonDemo02.class) &#123; if (instance == null) &#123; //(2) instance = new SingletonDemo02();//(3) &#125; &#125; &#125; return instance;&#125; 对于(3)处的代码，虽然源码中只有一句，但是对应的字节码文件中的字节码指令却有三条，分别是： 为对象分配内存空间 在内存空间中初始化对象 将引用instance指向对象在内存中的地址 对于上面的三条指令，其顺序并不是想象的那样是固定的，而是有可能发生重排序，即1-&gt;3-&gt;2的顺序，这样的后果是 instance 确实指向了给对象分配的地址，但是对象这时候还没有初始化啊，也就是还没有执行对象的构造方法，这样的对象是不完整的，对象中的变量值啊什么的都不是我们期望的值。 再比如，线程 A 执行到(3)指令重排序了，就发生了上面的结果，此时线程 B 在执行(1)时，判断的是 instance 非空（指向了一块内存地址），就返回了这个 instance，但是返回的这个对象还没有被初始化，是不完整的，就带来了一些列问题。 注意：刚开始看这个问题的时候，就很疑惑，明明线程 A 已经通过synchronized关键字加锁了，就算内部指令重排序了，其他线程也进不来，为什么其他线程还会访问到这个不完整的对象？ 后来发现原来是我的切入点错了，线程 A 对instance的修改是实时的，修改的过程中，其他线程在(1)处的判断也是可以访问到instance的。 解决办法： 可以使用 volatile 关键字来实现禁止指令重排序。这样顺序就会保证对象在内存中初始化之后，instance才会指向对象在内存中的地址，这样，其他线程判断instance仍然是null。 private static volatile SingletonDemo02 instance; 3. 静态内部类实现单例 由于外部类没有static变量和static{}代码块，所以不会立即加载对象（延迟加载）。 只有调用了getInstance()方法才会加载静态内部类，来实例化static变量（类加载机制&lt;clinit&gt;()方法只加载一次）。保证了线程安全。 调用效率也高，并且是延迟加载的。 实例代码： 1234567891011121314package com.GOF.Singleton;public class SingletonDemo03 &#123; private SingletonDemo03() &#123; &#125; //内部类被加载时，才会实例化static instance对象 private static class SingletonClassInstance &#123; private static SingletonDemo03 instance = new SingletonDemo03(); &#125; //该方法被调用时才会去加载内部类 private static SingletonDemo03 getInstance() &#123; return SingletonClassInstance.instance; &#125;&#125; 4. 枚举实现单例 枚举本身就是单例模式，基于jvm底层实现，可以避免通过反射和反序列化的漏洞。 实现过程相对简单。 由于枚举类一加载就会实例化单例对象，所以这种方式没有延迟加载。 实例代码： 123456789101112131415package com.GOF.Singleton;public enum SingletonDemo04 &#123; /** * 定义一个枚举元素，该元素就代表了SingletonDemo4的一个实例 */ INSTANCE; /** * 其他操作 */ public void singletonOperation() &#123; //功能处理 &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 类加载机制]]></title>
    <url>%2F2019%2F02%2F26%2FjvmClassLoad%2F</url>
    <content type="text"><![CDATA[一、概述​ 类的完整生命周期：加载、验证、准备、解析、初始化、使用、卸载。 ​ 类加载的周期：加载、连接（验证、准备、解析）、初始化。 ​ 其中加载、验证、准备、初始化、卸载这5个阶段的开始顺序是确定的，也就是，准备阶段不能再验证开始前开始，但是只是规定了开始有顺序，运行的过程却是可以交叉运行，即验证阶段开始后，还没验证结束，准备阶段就开始了，期间他们可以交叉运行。 ​ 而解析阶段的开始时间却是不确定的，一些情况下解析阶段可以在初始化之后才开始。 二、类加载过程1. 加载​ 对于一个类，什么时候开始加载？虚拟机并没有明确的规定一个类要在什么时候加载，虚拟机会在需要的时候自动进行加载，我们不用操心。 ​ 虽然不知道类会在什么时候加载，但是它确实会有这个阶段。虚拟机在类的加载阶段会有如下3个过程： 通过类的全限定名来获取定义此类的二进制字节流（例如找到类的class文件）。了解：对于获取二进制字节流来说，并不只有找到class文件这一种，还有从ZIP压缩文件中（jar,war）、从网络获取、运行时计算生成（动态代理）、其他文件生成（Jsp）、数据库读取等。 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。 在内存（方法区）中生成这个类对应的Class对象，作为方法区中这个类的各种数据的访问入口。 ​ 而通过类的全限定名获取二进制字节流是通过 “类加载器” 实现的，类加载器是用户可以编写的程序，也就是说，用户通过实现类加载器可以自己决定到哪去获得这个二进制流。关于类加载器在后面会讲。 ​ 对于非数组的类，可以使用类加载器（虚拟机自带或用户定义）进行加载来控制从哪如何获取二进制流。但是对于数组类来说，数组类不通过类加载器创建，是由虚拟机直接创建的，但是数组类中的元素类型还是由类加载器创建。 数组类创建过程： 若数组的组件类型是引用类型（组件类型就是数组去掉一个维度的类型），就递归采用“加载、验证、准备、解析、初始化”的过程加载组件类型。 若数组的组件类型不是引用类型（基础类型 int[]等），虚拟机将会把数组标记为与 “引导类加载器” 关联。 数组类可见性同其组件类型的可见类型，若组件是基本类型，默认可见类型为public。 加载阶段结束后，二进制字节流中的内容就会存到方法区中。然后在方法区中实例化一个Class类对象，作为方法区中数据访问的入口。 2. 验证 验证的目的是为了确保Class文件的字节流中的信息是否合法，要保证它的内容不会危害虚拟机。 ​ 但是编译阶段就会筛选信息是否正确，错误的信息直接编译失败，那为什么还有不合法的信息危害虚拟机呢？那是因为Class文件并不仅仅是java源文件编译来的，因为它是二进制字节流，我们自己甚至都可以编写它（如果你够牛P的话），所以，通过其他过程获得的字节流可能是不合法滴。 验证阶段大致分为下面 4 个检验动作： 1. 文件格式验证 该阶段要验证字节流是否符合Class文件格式的规范，是否能被虚拟机理解。 可验证的地方： 是否以魔数 0xCAFEBABE 开头？ 主次版本号是否有误？ 常量池中的常量是否是那些规定里面的常量类型（tag不对）？ 指向常量的索引是否有问题（瞎鸡儿指个错的）？ CONSTANT_utf8_info型的常量是否不符合UTF8编码数据？ Class文件是否被修改过（恶意添加、删除信息）？ 经过这个阶段验证过，字节流才会进入内存方法区存储，后面的 3 验证阶段都是对方法区中存储的数据进行验证，不会再操作字节流了。 2. 元数据验证 对字节码描述的信息进行语义分析。 可验证的地方： 这个类是否有父类？ 这个类父类是否继承了不可被继承的类？（如继承了String类） 如果该类不是抽象类，是否实现了父类（如抽象类）或接口中要求实现的方法？ 类中字段、方法是否合理？（例如覆盖了父类的final字段，方法重载有问题等都不合理） 3. 字节码验证 该阶段是对类中的方法体字节码进行分析，主要是通过数据流和控制流分析，来确定语义是否合法和逻辑。 可验证的地方： 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作，例如不能出现int数据入栈，最后写入到本地变量表中却变成long类型。 保证跳转指令不会瞎鸡儿跳，例如不能调到方法体外去了。 保证方法体中类型转换有效（显式或隐式），例如不能出现Dog d = new Cat()这种。 4. 符号引用验证 该阶段发生在虚拟机将符号引用转化为直接引用时，这个验证阶段在解析阶段之后发生。符号引用验证可以看做是对类自身以外的信息进行匹配性检验。 可校验的地方： 符号引用中通过字符串描述的全限定名是否能找到对应类。 指定类中是否存在符合方法的字段描述符以及简单名称描述的方法和字段。就是描述符和简单名称能否和指定类中的方法或字段对应上。 符号引用中的类、字段、方法的访问性是否可被当前类访问。例如访问了private修饰的类或字段或方法等就是不行的。 符号验证阶段目的是为了保证解析动作正常执行。 3. 准备​ 准备阶段是为类变量（static变量）分配内存并设置初始值的阶段，这些static变量的内存都将分配在方法区。 ​ 对static变量设置的初始值一般是数据类型的零值，例如int类型零值0，boolean类型零值为false，引用类型零值为null等。 ​ 而对于 final 修饰的常量，在编译时期，就会将常量值保存在字段对应的字段属性表的ConstantValue属性中，在准备阶段，变量就会被初始化为ConstantValue属性指定的值，而不是零值。举例，public static final int value = 123;在编译阶段，123 被保存在value的字段属性表的ConstantValue属性中，准备阶段，会根据ConstantValue属性设置value的值为 123。 4. 解析 解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用与直接引用： 符号引用： 啥是符号引用？书上的原话就不贴了。当我们的java源文件编译之后，会生成一个Class文件，文件中有常量池一块，里面就是保存的字面量和符号引用。常量池中的符号引用最终就是引用的字面量的内容。 编译后的Class文件中还有方法表，方法表中有Code属性用来保存方法体对应的字节码指令，这些都是编译期生成的，如果方法体重要引用另一个类的方法，这个类还没有被加载哎，那该怎么表示呢？ 所以符号引用就是用来表示这些的。例如字节码指令中需要调用另一个类的方法，而这个类还没有加载，就找不到具体的方法在哪里，但是我可以使用“字符串描述”先表示一下我要调用这个方法。这个表示方式就是使用符号引用。 直接引用：直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有直接引用，那引用的目标必须已经在内存中存在。 ​ 同样，虚拟机并没有说确定在哪一个时间对符号引用进行解析，但是在遇到anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic指令之前，会先对他们使用的符号引用进行解析。 ​ 对于上面的除invokedynamic之外的15个指令，虚拟机会对第一次解析结果进行缓存，后面再一个实体中，后续的引用解析请求就使用缓存的结果，成功或失败。 ​ 解析的动作主要针对 类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfactMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandler_info、CONSTANT_InvokeDynamicinfo 7 种常量类型。 1、类或接口解析 假如类 A 中有符号引用 N 需要解析为类 B 的直接引用，则具体解析步骤为： 类 B 不是数组类型，虚拟机就会把代表 N 的全限定名传给 A 的类加载器去加载 B。 类 B 是数组类型，那么它的描述符就是[Ljava/lang/Object形式，虚拟机就会按 1. 的方式去加载 B 的元素类型，接着虚拟机就会生成一个代表此数组维度和元素的数组对象。 如果上面解析成功，B在虚拟机中实际就已经是有效的了，解析结束之前，还需要进行上面验证阶段的符号引用验证，验证 A 是否对 B 有访问权限（如果B是private就没有访问权限）。 2、字段解析 要解析一个字段，首先解析它属于哪个类或接口（解析字段表中class_index对应的CONSTANT_Class_info常量字段），解析类或接口成功后，会进行如下步骤的解析： 如果所属类本身包含与之匹配的字段，就返回这个字段，查找结束。 如果类不包含该字段，但是所属类实现了一些接口，就按照实现顺序先去接口中查找是否有匹配的字段，如果有，就返回匹配的字段的直接引用，查找结束。 如果没有实现接口，但继承父类，就按照继承关系从上往下搜索父类是否有匹配字段，有则返回该字段的直接引用，查找结束。 以上都不符合的话，就找不到对应字段，抛出异常。 总结下来就是：先找自己类的，自己类没有，再找实现接口的，没有就继续找父类的，没有就真的没有了。 查找结束后，还需要进行权限验证，避免引用了不能引用的字段。 3、类方法解析 要解析一个类方法，首先也解析它属于哪个类（解析方法表中class_index对应的CONSTANT_Class_info常量字段），解析类或接口成功后，会进行如下步骤的解析： 如果解析class_index的结果是一个接口，就直接抛出异常。 如果没有异常，则在方法所属类中查找是否有对应的方法，有则返回直接引用，查找结束。 如果类中没有对应方法，就在父类中查找是否有对应方法，有则返回直接引用，查找结束。 如果父类中也没有，就去父类实现的接口中查找是否有对应方法，如果有则说明该方法所属类是抽象类（接口方法都是抽象方法），查找结束，抛出异常。 如果都没有对应方法，那就真的没有对应方法了，抛出NoSuchMethodError异常。 如果查找到了对应方法，进行权限验证，避免出现引用了不能引用的方法。 4、接口方法解析 要解析一个接口方法，首先也解析它属于哪个接口（解析接口方法表中class_index对应的CONSTANT_Class_info常量字段），解析接口成功后，会进行如下步骤的解析： 如果发现解析class_index是一个类，就直接抛出异常。 如果没有异常，则在方法所属接口中查找是否有对应的方法，有则返回直接引用，查找结束。 如果接口中没有对应方法，就在父接口中查找是否有对应方法，直到连Object类都查找完了，有则返回直接引用，查找结束。 如果都没有对应方法，那就真的没有对应方法了，抛出NoSuchMethodError异常。 接口中方法都是 public 的，所以不需要权限验证，找到了就可以直接用了。 5. 初始化 在准备阶段，变量已经复制过一次初始值（零值），而在初始化阶段，就是根据程序员的设置去初始化类变量或其他资源的值了。 ​ 对于一个类的初始化阶段，虚拟机会在下面 5 种情况下立即初始化，当然在初始化之前，加载、验证、准备等阶段已经开始过了。 5 种情况： 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时，会立即对该类初始化，当然前提是该类还没被初始化过。这四条指令对应源代码中的场景如下：new实例化对象、获取static变量、设置static变量、调用static方法。 使用java.lang.reflect包下的方法对类进行反射调用时，如果类没初始化，就先对其初始化，才能进行反射调用。例如反射中的 forName方法 获取类的Class对象。 初始化一个类时，如果父类还没被初始化，就先初始化其父类。所以Object是最先初始化的类。 虚拟机启动时，会先初始化用户指定的主类，即包含main方法的那个类。 当时用JDK1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则要对其进行初始化。 上面这 5 种情况都是对一个类进行主动引用，除这 5 种场景以外的其他引用（被动引用）都不会触发类的初始化。 被动引用举例： 实例一：通过子类引用父类的static字段，不会触发子类初始化 12345678910111213141516171819202122232425262728/** * 对于子类subClass来说，对其的引用是被动引用（不属于上述5种情况） */class superClass &#123; static &#123; System.out.println("SuperClass init..."); &#125; public static int value = 123;&#125;class subClass extends superClass &#123; static &#123; System.out.println("SubClass init..."); &#125;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(subClass.value); &#125;&#125;//实验结果SuperClass init...123 /** * 解释说明：对于static字段的调用，只有直接定义该static字段的类才会触发初始化。 * 子类调用父类的static字段，只会触发父类的初始化而不会触发子类初始化。 */ 实例二：通过数组定义来引用类，不会触发此类的初始化 12345678910111213141516171819202122package com.test;class superClass &#123; static &#123; System.out.println("SuperClass init..."); &#125; public static int value = 123;&#125;class subClass extends superClass &#123; static &#123; System.out.println("SubClass init..."); &#125;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; superClass[] sca = new superClass[10]; &#125;&#125;//实验结果为空，什么都没输出。/** * 解释说明：对数组的定义引用类，没有触发superClass类的初始化，但是触发了另一个类[com/test/superClass类的初始化，这个类是虚拟机自动生成的，直接继承自Object类，该类的创建是由newarray字节码指令触发的。 */ 实例三：引用类中定义的常量时，是不会触发定义该常量的类的初始化的。 1234567891011121314151617class ConstClass &#123; static &#123; System.out.println("ConstClass init..."); &#125; public static final String HELLOCONST = "Hello const";&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLOCONST); &#125;&#125;//实验结果：Hello const/** * 解释说明：常量在编译阶段会存入调用类的常量池中，本例中，常量HELLOCONST在编译时期就已经存到test类的常量池中，test类中对HELLOCONST常量的引用，实际上都是对本类常量池中的常量引用。所以是不会触发ConstClass类的初始化的。 */ 初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是编译期自动收集类中所有 static变量 和 static{}代码块组合而成的方法，收集顺序和源码中顺序一致，所以static{}中只能访问之前定义的static变量，对于static{}之后定义的变量，虽然可以赋值，但是不能访问。 类构造器&lt;clinit&gt;()方法与 实例构造器&lt;init&gt;()方法不同，它不会显示调用父类的类构造器，也就是可以保证在当前类的&lt;clinit&gt;()方法执行之前，其父类的&lt;clinit&gt;()方法已经执行过了。 因为父类的&lt;clinit&gt;()方法先执行，所以父类的static{}块中代码先执行，父类static变量也会先进行初始化操作。 如果一个类没有static变量和static{}代码块，那么这个类可以没有&lt;clinit&gt;()方法。 接口中没有static{}块，但仍然有变量初始化的赋值操作，所以接口中也有&lt;clinit&gt;()方法，但是接口执行&lt;clinit&gt;()方法并不需要先去执行父接口的&lt;clinit&gt;()方法。只有父接口中的变量使用时，才会调用父接口的&lt;clinit&gt;()方法初始化。接口实现类初始化时也不会先执行接口的&lt;clinit&gt;()方法。 一个类的&lt;clinit&gt;()方法会在多线程环境中进行同步，也就是如果多个线程都需要初始化该类，那么只会有一个线程执行该&lt;clinit&gt;()方法，其余线程阻塞等待，直到&lt;clinit&gt;()方法执行完毕。 三、类加载器1. 类加载器概述 类加载器只用于实现类的加载动作。 对于任意一个类，它的唯一性就是由这个类和加载它的类加载器确认的，每一个类加载器都有一个独立的类名称空间。比如对于同一个Class类文件，由两个不同的类加载器加载出来的两个类，就不是相等的，由一个类实例化出的对象，是不属于另一个类的。 对于两个类的“相等”比较，可以通过Class对象的equals()、isAssignableFrom()、isInstance()方法来比较，同样instanceof关键字也可以判定。 举例说明不同类加载器加载同一个类文件是不同的(instanceof方式)： 123456789101112131415161718192021222324252627282930313233package jvmTest01;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception &#123; //自定义加载类myLoader，通过覆写loadClass方法 ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; //使用自定义类加载器加载类并实例化对象 Object object = myLoader.loadClass("jvmTest01.ClassLoaderTest").newInstance(); System.out.println(object.getClass()); //将实例化对象判断是否属于系统默认的应用程序加载器加载的类 System.out.println(object instanceof ClassLoaderTest); &#125;&#125; 实验结果： 1234D:\java\jdk\bin\java.exe ...class jvmTest01.ClassLoaderTestfalseProcess finished with exit code 0 2. 双亲委派模型对虚拟机来说，只有两种类加载器： 启动类加载器：C++语言实现，是虚拟机的一部分。 其他类加载器：java语言实现，都继承自java.lang.ClassLoader类。 对程序员来说，有 4 种类加载器，其中有 3 种是系统提供的： 启动类加载器（Bootstrap ClassLoader）：也叫引导类加载器。该类加载器负责将&lt;JAVA_HOME&gt;\lib目录或被-Xbootclasspath参数指定的路径中的类库加载到虚拟机内存。开发者不能直接使用启动类加载器，自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：该类加载器负责加载&lt;JAVA_HOME&gt;\lib\ext目录或者被java.ext.dirs变量指定的路径的类库。开发者可直接使用扩展类加载器。 应用程序类加载器（Application Classloader）：一般也称为系统类加载器。负责加载用户类路径（ClassPath）上指定类库，开发者可直接使用该类加载器。该加载器是默认的类加载器。 自定义类加载器（UserClassLoader）：该类加载器是由用户自定义的。 上面的层次关系又成为双亲委派模型。双亲委派模型要求除了最顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器，然而这里的父类子类关系不是用继承实现的，而是用组合关系来复用父加载器的代码。 双亲委派模型工作过程： 如果一个类加载器收到了一个类加载请求，它暂时不会自己处理，而是先去委派给父类加载器处理，父类加载器也是这样委派给它的父类加载器…，这样到最后，这个请求会交由启动类加载器处理，因为他是顶层，没有父类加载器了。 如果父类加载器处理不了这个请求，子类加载器才会尝试自己处理这个请求去加载类。 为什么要这样工作呢？ 这种关系可以保证系统的稳定，并且一个类和它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object存放在rt.jar中，是由启动类加载器加载的。如果用户也编写了一个java.lang.Object，并放在程序 ClassPath 中，那么系统将会有多个不同的Object类，这样调用 Object 就不是最基础的那个Object类了。 而使用双亲委派机制，可以保证每个程序加载的 Object 都是启动类加载的那个。 双亲委派模型的实现： 先检查类是否已被加载，如果没有，则调用父类加载器的 loadClass()方法，如果父类加载器为空，则默认使用启动类记载器作为父类加载器。 如果父类加载失败，抛出ClassNotFoundException异常后，子类加载器再调用自己的findClass()方法加载。]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之TreeMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaTreeMap%2F</url>
    <content type="text"><![CDATA[一、TreeMap概述 因为TreeMap的通过多重继承 SortedMap 接口，所以有序 底层数据结构：红黑树。查询时间复杂度 log(n)。 TreeMap是 线程不安全 的。 TreeMap有两种方式对key进行比较，从而实现排序效果： 自然排序：通过key 实现Comparable接口，覆写compareTo方法进行比较。 比较器排序：通过Comparator对象来进行排序。 注意： 如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，使用key实现了Comparable接口的compareTo(T o)方法来比较。 如果使用的是compareTo(Object o)方法来比较，key一定是不能为null(空指针异常)，并且key得实现了Comparable接口的。 即使是传入了Comparator对象，不用compareTo(T o)方法来比较，key也是不能为null的。 TreeMap内部节点类： 1234567891011121314151617181920212223/** * 实现的Map的Entry接口 */static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; &#125; 二、TreeMap的属性12345678910111213141516171819/*** comparator变量决定使用什么排序方式，为null表示自然排序*/private final Comparator&lt;? super K&gt; comparator;/*** 红黑树的根节点root*/private transient Entry&lt;K,V&gt; root;/*** TreeMap元素个数*/private transient int size = 0;/*** 结构性修改次数，用于快速失败机制。*/private transient int modCount = 0; 三、构造方法1234567891011121314151617181920212223242526272829303132/*** 无参构造方法，设置排序方式为自然排序*/public TreeMap() &#123; comparator = null;&#125;/*** 指定排序方式的构造方法*/public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125;/*** 指定Map作为参数的构造方式，默认自然排序。putAll方法将参数Map中所有元素添加到TreeMap中*/public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;/*** 指定SortedMap作为参数的构造方式。*/public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; //使用SortedMap的比较方式 comparator = m.comparator(); try &#123; //该方法将SortedMap中元素添加到TreeMap中 buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125;catch (ClassNotFoundException cannotHappen) &#123;&#125;&#125; 四、常用方法1、put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 向TreeMap中添加元素*/public V put(K key, V value) &#123; //如果红黑树为空，就创建红黑树 Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); //检查key合法性（如key是否为空） //树为空，添将加的key作为根节点root root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; //临时父节点 Comparator&lt;? super K&gt; cpr = comparator; //比较器排序方式 if (cpr != null) &#123; //循环判断待插入节点key与当前遍历节点key大小，并选择左子树还是右子树 do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); //自然排序方式 &#125;else &#123; //判断key不能为null if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") //自然排序方式待排序的对象必须已经实现过Cpmparable接口 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //循环判断待插入节点key与当前遍历节点key大小，并选择左子树还是右子树 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; //调整红黑树，使其平衡 fixAfterInsertion(e); size++; modCount++; return null;&#125; 2、get方法12345678910111213141516171819202122232425262728293031/*** 根据key获取value，调用getEntry方法具体实现*/public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125;/*** 具体实现的get方法，来获取key对应的节点*/final Entry&lt;K,V&gt; getEntry(Object key) &#123; //比较器排序调用的是getEntryUsingComparator方法 if (comparator != null) return getEntryUsingComparator(key); //自然排序，获取key对应的Entry节点，如果没有，则返回null。 if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之LinkedHashMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaLinkedHashMap%2F</url>
    <content type="text"><![CDATA[一、LinkedHashMap概述底层数据结构：哈希表 + 双向链表 双向链表作用： 记录HashMap数据的顺序。而顺序又有两种： 维护插入顺序。 维护访问顺序。 注意： LinkedHashMap继承了HashMap类，所以它的大多数方法都使用的HashMap的方法，或者在其上进行拓展。 LinkedHashMap的多数方法都是需要增加额外的对双向链表的操作，如新增、删除等。 就连LinkedHashMap的内部节点类也是继承的HashMap.Node类。 节点内部类结构： 1234567891011121314/** * 继承父类HashMap的内部子类Node * 在Node基础上并添加了before，after两个节点，分别指向前一个节点和后一个节点 */static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;/** * LinkedHashMap给每个节点都设置了before指针和after指针 * 每次添加一个元素，除了将它添加进HashMap表中，还额外将它按照accessOrder指定的顺序添加进双向链表的表尾。 */ 上图： 解释：如果去掉了绿线和黄线，正好就是HashMap的结构了。而那些绿线和黄线就连接了节点，组成了双向链表。其中维护了一个头结点（右上角）。 二、LinkedHashMap属性12345678910111213//这里只列出了新添加的属性。此外还有很多从HashMap继承来的属性（loadFactory、threshold等）/** * 表示双向链表头节点元素 */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * 表示双向链表尾节点元素 */transient LinkedHashMap.Entry&lt;K,V&gt; tail;/** * 表示顺序标识，为true按照访问顺序迭代，为false按照插入顺序迭代，默认为false */final boolean accessOrder; 三、构造方法12345678/** * 共有5种构造方法，其中有四种和HashMap一样，而accessOrder使用的是默认false * 第 5种构造方法是指定accessOrder的构造方法 */public LinkedHashMap(int initicalCapacity,float loadFactor,boolean accessOrder)&#123; super(initicalCapacity,loadFactor); this.accessOrder = accessOrder;&#125; 注意：与HashMap一样，initicalCapacity和loadFactor两个属性都对LinkedHashMap有很大的影响。 四、常用方法1. reinitialize初始化方法1234567/*** 初始化LinkedHashMap，调用HashMap的该方法，初始化头结点尾节点*/void reinitialize() &#123; super.reinitialize(); head = tail = null;&#125; 2. newNode方法123456789/*** 添加新节点，为Entry节点。该方法覆写了HashMap中的newNode方法，并在其中添加了双向链表操作*/Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); //将新建的Entry插入到链表尾部 linkNodeLast(p); return p;&#125; 注意： LinkedHashMap的put方法是继承HashMap的方法，但是其中调用的newNode方法是新覆写的方法。所以在LinkedHashMap直接通过newNode中的操作来实现对双向链表顺序的操作，并不需要再在put方法中做其他修改。 3. get方法123456789101112131415161718192021222324252627282930313233343536373839404142/*** 根据key值的hashCode来获取节点，调用HashMap的getNode方法*/public V get(Object key) &#123; Node&lt;K,V&gt; e; //如果没有找到key对应节点，返回null if ((e = getNode(hash(key), key)) == null)&#123; return null; &#125; //如果是accessOrder是访问顺序，把节点插入到链表尾部 if (accessOrder)&#123; afterNodeAccess(e); &#125; return e.value;&#125;/*** 由于添加进哈希表后还需要维护进双向链表中，所以要将节点放到指定的顺序的尾部*/void afterNodeAccess(Node&lt;K,V&gt; e) &#123; Entry&lt;K,V&gt; last; //如果维护的顺序是访问顺序，并且双向链表的尾节点不是e,就将e添加到链表尾部 if (accessOrder &amp;&amp; (last = tail) != e) &#123; Entry&lt;K,V&gt; p = (Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else&#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之HashMap]]></title>
    <url>%2F2019%2F02%2F25%2FjavaHashMap%2F</url>
    <content type="text"><![CDATA[HashMap特点： 元素无序 key不允许重复，key只可以存在一个为null（因为不允许重复，所以不允许存在多个key为null） HashMap底层数据结构： 哈希表（链地址法的哈希表，数组 + 链表），jdk1.8增加了红黑树。 HashMap内部节点类：用来存储key-value对 123456789101112131415161718192021222324252627//实现的Map中的Entry接口static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 一、HashMap属性123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** HashMap的默认初始容量，16*/static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //移位操作效率高/*** HashMap的最大容量 2^30*/static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/*** 默认负载因子 0.75，用来判断何时对map进行扩容*/static final float DEFAULT_LOAD_FACTOR = 0.75f;/*** 标识添加元素时链表长度超过 8 就可以转换为红黑树*/static final int TREEIFY_THRESHOLD = 8;/*** 标识移除元素时，红黑树元素少于 6 就转换为链表（前提是红黑树）*/static final int UNTREEIFY_THRESHOLD = 6;/*** Map中的 key-value 对的个数*/transient int size;/*** HashMap的阈值，当table为空时，该阈值为初始容量16，当table被填充后，阈值变为* capacity * loadFactor（16 * 0.75），HashMap进行扩容时会参考阈值的值。当size* 超过阈值，容量就扩容为原来的2倍。*/int threshold;/*** 负载因子*/final float loadFactor;/*** 标识只有表元素个数大于该值64时，才符合转变为红黑树的条件*/static final int MIN_TREEIFY_CAPACITY = 64; 二、构造方法1234567891011121314151617181920212223242526272829303132333435/*** 指定初始化容量和负载因子的构造方法*/public HashMap(int initialCapacity, float loadFactor) &#123; /*验证参数是否合法的代码...(省略)*/ this.loadFactor = loadFactor; /*tableSizeFor返回的是大于参数initialCapacity且是2的整数次幂的值，此处将 * threshold赋值为2的整数次幂。这是一次初始化，创建哈希表会重新对threshold * 进行赋值。 */ this.threshold = tableSizeFor(initialCapacity);&#125;/*** 指定初始化容量的构造方法，负载因子为默认0.75*/public HashMap(int initialCapacity) &#123; //调用的第一个构造方法，传入的负载因子是默认的0.75 this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/*** 无参构造方法，默认初始容量16和负载因子0.75*/public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;/*** 以另一个Map作为参数的构造方法，默认的负载因子0.75，初始化容量为参数Map容量*/public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 注意：上面的构造方法中，对哈希表进行初始化时，实际上并没有为哈希表分配内存空间，在这里只是表示一下需要多少空间而已。而且内部节点数组暂时也只是为空。实际上在put方法第一次执行时，才会为哈希表分配内存空间。 三、常用方法1、put方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/*** 添加key-value键值对到HashMap中*/public V put(K key, V value) &#123; //实际put的具体操作是在putVal方法中 return putVal(hash(key), key, value, false, true);&#125;/*** 根据传入的key计算key的hash值*/static final int hash(Object key) &#123; int h; //如果key为null，则返回的hash值为 0 /* key不为null时，计算hash值时将key的hashCode低16位与高16位做异或运算，增加了 * hash值得随机性，减少哈希碰撞，散列更加均匀（让32位的hashcode的所有位都参与运算） */ return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/*** 实际将key-value键值对插入map中的方法*/final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; //临时表 Node&lt;K,V&gt; p; //临时节点 int n, i; //临时变量 //如果插入前哈希表为空，则调用resize方法初始化哈希表(第一次插入元素) if ((tab = table) == null || (n = tab.length) == 0)&#123; n = (tab = resize()).length; //n就是hashmap初始化后的容量 &#125; //通过hash值计算出来的数组下标位置元素为空，表示没有发生碰撞，就将该key-value插入到该位置 //计算下标位置是通过key的hash值和哈希表数组长度与运算得出（(n-1)&amp;hash） if ((p = tab[i = (n - 1) &amp; hash]) == null) &#123; tab[i] = newNode(hash, key, value, null); &#125; else &#123; //要插入的位置已有元素，发生了哈希碰撞 Node&lt;K,V&gt; e; K k; /** * 先判断数组上的元素与待插元素的关系，如果待插元素和数组上该位置元素的hash值和key相等， * 就表示应该对该位置的元素进行更新 */ if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; //这里只是暂时获取该元素，实际的更新操作在后面 no.61 行 e = p; &#125; //如果该位置上是红黑树结构，调用红黑树的插入元素方法 else if (p instanceof TreeNode)&#123; e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125; //该位置是链表结构 else &#123; //遍历链表，检查链表是否已存在该key for (int binCount = 0; ; ++binCount) &#123; //如果p.next==null则到达了尾部，进行插入操作，如果链表过长就转换为红黑树 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; //如果p.next!=null则对比该位置的key和待插key，如果相同就更新该位置的value if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; break; &#125; p = e; &#125; &#125; //判断结束后，上面返回的e都是找到了某个节点key和待插入key相同的 //如果表中已存在该key，则就将key的value进行更新为新值。并返回原来的value值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //如果表中元素个数超过阈值，就调用resize方法进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 2、resize方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * map的扩容方法。在map初始化的时候需要调用resize方法，元素个数超过阈值也需要调用resize方法。 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//原容量 int oldThr = threshold;//原阈值 int newCap, newThr = 0; //如果原表不为空，即oldCaoacity &gt; 0 if (oldCap &gt; 0) &#123; //判断原容量是否合法 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; /** * 判断扩容后的容量是否合法，如果合法，并且原容量超过了默认容量16 * 则容量扩充为原来的2倍，阈值也扩充为原来的2倍 */ else if((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123; newThr = oldThr &lt;&lt; 1; &#125; //如果原表为空，但原表阈值不为0，将容量设置为旧阈值的值（产生这种现象原因可能是将元素全部删除了） &#125;else if (oldThr &gt; 0)&#123; newCap = oldThr; &#125; //如果原表为空，且阈值为0，就表示这是新创建的表，就将容量和阈值都设置为默认值 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新阈值，并判断值是否合理 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //压制警告 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//创建容量为新容量的新表 table = newTab; //将旧表元素复制到新表中 if (oldTab != null) &#123; //遍历数组每个下标位置 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果该数组位置下没有链表或红黑树，就将其直接复制到新表中 if (e.next == null)&#123; newTab[e.hash &amp; (newCap - 1)] = e; &#125; //如果该下标位置还有红黑树 else if (e instanceof TreeNode) &#123; ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); &#125; /** * 如果该下标位置还有链表，由于表的容量扩大 2倍，所以(capaticy-1)&amp;hash 获得的 * 下标值就可能发生改变，注意这里只是可能发生改变。对于元素位置如果在新表位置和 * 旧表位置相同就直接插入，否则进行重哈希。 */ /** * 由于容量扩大为 2倍，所以(capacity-1)就比原来多了一位，例如原来capacity为 * 16时，就计算4位&amp;（1111），现在扩容后capacity为32，就要计算5位&amp;（11111）， * 所以就根据key的hash值多出的那一位来判断其下标有没有改变，若为0，位置就不变， * 若为1，就进行重哈希。 */ else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //元素插入到新表原位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //元素插入到新表的：原位置+oldCapacity if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 3、get方法123456789101112131415161718192021222324252627282930313233343536/*** 根据key查找map是否包含该键值对，包含则返回value，不包含则返回null*/public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/*** 获取key对应的node,没有就返回null*/final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //通过key计算hash值来确定key对应的数组下标，判断该位置的链表头结点是否符合 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return first; &#125; if ((e = first.next) != null) &#123; //如果是红黑树结构，通过红黑树来查找 if (first instanceof TreeNode)&#123; return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); &#125; //否则是链表结构，遍历链表，找出符合目标的key-value do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return e; &#125; &#125; while ((e = e.next) != null); &#125; &#125; //如果链表中没有对应的key-value对，最终返回null return null;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之LinkedList]]></title>
    <url>%2F2019%2F02%2F25%2FjavaLinkedList%2F</url>
    <content type="text"><![CDATA[注意：LinkedList底层数据结构是双向链表，还实现了Deque接口，可作为Queue和Stack使用。 12345678910111213/*** 内部节点类，作为双向链表的节点。*/private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 一、LinkedList属性123456789101112/*** 链表中元素节点的个数。*/transient int size = 0;/*** 双向链表的头节点*/transient Node&lt;E&gt; first;/*** 双向链表的尾节点*/transient Node&lt;E&gt; last; 二、LinkedList构造方法123456789101112/*** 无参构造方法，啥也没有*/public LinkedList() &#123;&#125;/*** 集合作为参数的构造方法*/public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 三、常用方法1. add方法1234567891011121314151617181920public boolean add(E e)&#123; linkLast(e); return true;&#125;/** * 操作双向链表，将元素插入到双向链表尾部 */void linkLast(E e)&#123; final Node&lt;E&gt; l = last; //构造新节点，值为e,上一个节点指向链表 last final Node&lt;E&gt; newNode = new Node&lt;&gt;(l,e,null); last = newNode; //如果链表为空，将这个节点作为链表头 fitst if(l == null) &#123; first = newNode; //链表不为空，设置链表的尾节点的next为插入的节点e &#125; esle &#123; l.next = newNode; &#125;&#125; 2、remove方法12345678910111213141516171819202122/** * remove:删除指定的节点方法 */public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; //即双向链表删除节点操作的具体实现。 unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 3、set方法1234567891011121314151617181920212223242526272829/** * 修改指定的下标index元素值，并返回该index的原来的元素值 */public E set(int index, E element) &#123; //检查index下标是否正确 checkElementIndex(index); //该node方法会返回index对应的节点。不过其内部会自动进行选择从表头遍历还是从表尾遍历的方式，实际就是判断index靠近表头还是靠近表尾。 Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;/*** node:返回index下标对应的节点*/Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架之ArrayList]]></title>
    <url>%2F2019%2F02%2F25%2FjavaArrayList%2F</url>
    <content type="text"><![CDATA[一、ArrayList属性1234567891011121314151617181920/*** 默认初始容量为 10，不过初始化的时候实际容量仍然为0。*/private static final int DEFAULT_CAPACITY = 10;/*** 标识一个空数组。ArrayList的底层数据结构就是数组。*/private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 标识一个默认容量10的数组（根据对象名可知），但初始化时仍然是空数组。*/private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** 该数组就是底层用来存放数据的数组。*/transient Object[] elementData; /*** 标识该集合中实际存储的元素个数，注意和容量区分开来*/private int size; 二、ArrayList的三种构造方法12345678910111213141516171819202122232425262728293031/*** 第一种指定容量的构造方法。数组初始化为指定的容量。如果初始化参数&gt;0，就初始化容量为initialCapacity的数组，如果初始化参数=0，就将数组初始化为空数组。如果容量 &lt; 0，就抛出异常。*/public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity); &#125;&#125;/*** 无指定容量的构造方法，默认是代表容量为10的空数组。但是ArrayList初始化时并非直接初始化为容量为10的数组，而是用一个空数组标记容量为10的数组。实际上初始化为容量10的数组是在列表天机第一个元素才开始的。*/public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/*** 指定集合作为元素的构造方法。将指定集合的元素添加进ArrayList中。*/public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; //如果指定集合为空，就将数组初始化为空数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 三、常用方法1. add方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** add:向集合中添加元素。注意，如果采用的无参构造方法，那么实际初始化是从这里开始的。*/public boolean add(E e) &#123; //确保添加一个元素后元素个数没有（数组容量是否能容纳元素，是否需要扩容）。 ensureCapacityInternal(size + 1); elementData[size++] = e;//添加元素，并将元素个数 加1 return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //如果数组elementData还是空数组，就表示第一次添加元素，需要取默认容量10和传入参数(添加元素后的容量)之间的较大值作为初始化容量。比如，第一次添加元素，传入的minCapacity为1，DEFAULT_CAPACITY为10，所以就将容量设为10。 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //判断是否需要扩容 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //如果初始化容量大于当前数组长度(即最大容量)，就需要进行扩容。比如，上面是第11次添加元素，传入的11和10比较，minCapacity设为11，此时元素个数大于容量，需要扩容之后才能装得下元素。 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/*** grow:扩容方法*/private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //新容量扩容为原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果扩容后的1.5倍容量仍然小于添加元素后的容量，则最终容量定为添加元素后的容量。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果扩容后的容量超过了数组限定的最大值，那就是用最大的容量（hugeCapacity源码就不分析了） if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制原数组的内容到扩容后的新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/*** 向集合中指定位置添加元素*/public void add(int index, E element) &#123; rangeCheckForAdd(index); //找到下标index ensureCapacityInternal(size + 1); //验证元素个数是否超过容量 System.arraycopy(elementData, index, elementData, index + 1,size - index); //下标后的元素后移 elementData[index] = element; //指定下标插入元素 size++;&#125; 2、get方法12345public E get(int index) &#123; rangeCheck(index); //检查下标是否符合要求 checkForComodification(); return ArrayList.this.elementData(offset + index); //返回对应下标的元素&#125; 四、注意 ArrayList是基于动态数组实现的，在增删时候（指定下标增删），需要对数组进行复制移动arrayCopy（下标元素后移前移等）。 ArrayList的默认初始化容量是10，每次扩容时先扩容为原容量的1.5倍。 删除元素时不会减少容量（只删除元素），若同时需要减少容量则调用trimToSize()。 ArrayList不是线程安全的。比如遍历元素时不能进行添加操作。 ArrayList可以存放null值。 五、ArrayList与Vector的区别 Vector线程安全，方法都是用synchronized修饰。ArrayList实现同步可使用Collections类的List list = Collections.synchronizedList(new ArrayList(...));方法。 ArrayList底层数组扩容一般为原容量的1.5倍，Vector扩容为原容量的2倍。]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm Class类文件结构]]></title>
    <url>%2F2019%2F02%2F23%2FjvmClassFile%2F</url>
    <content type="text"><![CDATA[一、概述​ Class文件存储的都是二进制流(0和1)，每8 位为一组，每个数据项严格按照顺序进行排列，数据项之间没有添加任何分隔符，所以整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。通俗来讲，Class文件中有哪些东西，哪个位置存放哪些东西，以及数据项的顺序都是规定好的。 Class文件数据类型：无符号数和表。 无符号数：是基本的数据类型，无符号数用 u 表示：u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节长度的无符号数。这些无符号数数可以用来描述数字、索引引用、数量值或按照UTF-8编码构成的字符串值（注意这个）。 表：由多个无符号数或其他表作为数据项构成的复合数据类型，一般以”_info”结尾。整个class文件就是一张表，里面由无符号数+其他表组成 类型 名称 数量 u4 magic 魔数 1 u2 minor_version 小版本 1 u2 major_version 大版本 1 u2 constant_pool_count 常量池长度 1 cp_info constant_pool 常量池 constant_pool_count-1 常量个数 u2 access_flag 访问标志 1 u2 this_class 类索引 1 u2 super_class 父类索引 1 u2 interfaces_count 接口表长度 1 u2 interfaces 接口索引集合 interfaces_count 接口个数 u2 fields_count 字段表长度 1 field_info fields 字段表集合 fields_count 字段个数 u2 methods_count 方法表长度 1 method_info methods 方法表集合 methods_count 方法个数 u2 attributes_count 属性表长度 1 attribute_info attributes 属性表集合 attributes_count 属性个数 ​ 由以上可知，Class文件结构包含的内容就有：魔数、版本、常量池、访问标志、类索引、父类索引、接口索引集合、字段表、方法表、属性表，且顺序是固定的（暂且这么说）。 二、具体结构1. magic 魔数​ Class文件的最初的 4 字节是魔数（值为0xCAFEBABE），唯一作用是来指明这个文件可以被 jvm 识别，换句话说，jvm只认识开头 4 字节为上述魔数的文件。 ​ java 使用魔数识别文件，不使用文件扩展名(.class)识别文件。 2. xx_version 版本​ 紧接着魔数的 4 个字节表示class文件的版本号，5,6 字节表示次版本号，7,8 字节表示主版本号。 ​ 例如，主版本是从45 开始，JDK1.0对应 Class文件的主版本号为 45，JDK1.7主版本号为51。 注意： 高版本JDK可向上兼容低版本的Class文件，但不支持高版本的Class文件。如，一个class文件的版本号为50，则该文件只能被JDK1.6以上的虚拟机加载。 3. constant_pool 常量池（重要）​ 因为每个程序中常量池中的常量数量都是不固定的，所以有必要用一个无符号数来表示常量池中常量的个数，这个无符号数就是constant_pool_count（u2），在这个数之后的就是常量池。 ​ 常量池中的常量索引从 1 开始，例如，constant_pool_count值换算为十进制为 24 ，这表示常量池有 23 个常量，常量索引为 1~23。因为索引 0 来表示”不引用任何一个常量池项目”。 ​ 注意：常量池中的常量是在编译期就生成的，编译期根据源码生成的各种字面量和符号引用就保存在常量池中。 常量池中的内容：字面量 与 符号引用。 字面量：可认为 java 中的常量，如字符串常量、final声明的常量等。 符号引用：主要有以下三种 类和接口的全限定名：就是将源码中全限定名中的 . 改成了 / ,例如java.lang.Object在class文件中全限定名就是 java/lang/Object 字段名称和描述符（后文字段表有讲） 方法的名称和描述符（后文字段表有讲） ​ 常量池中每一个常量都是表的结构，常量类型一共有 11 中，列表如下： 类型 标志 tag 描述 CONSTANT_Utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整型字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的部分符号引用 因为 11 中常量都是表类型，所以各自的结构也都不同。下面简单介绍几种常量的具体结构（其余的请自行Google吧）， CONSTANT_Utf8_info 项目 类型 描述 tag u1 标志位 length u2 表示utf-8字符串的长度多少字节 bytes u1 表示长度为length字节的数据就是实际的字串 CONSTANT_Integer_info（字面量） 项目 类型 描述 tag u1 标志位 bytes u4 表示接下来的4字节长度表示的就是int值 CONSTANT_CLASS_info（符号引用） 项目 类型 描述 tag u1 标志位 index u2 表示接下来2字节表示的值就是指向该池中的第index个常量 CONSTANT_Methodref_info（符号引用） 项目 类型 描述 tag u1 标志位 u2 指向方法属于的类常量的索引（指向CONSTANT_Class_info） index u2 指向方法的名称和类型描述符（指向CONSTANT_NameAndType_info） CONSTANT_Fieldref_info 项目 类型 描述 tag u1 标志位 index u2 指向字段属于的类常量的索引（指向CONSTANT_Class_info） index u2 指向字段的名称和类型描述符（指向CONSTANT_NameAndType_info） 举例分析，现有一个class文件如下，其中4个连续为 2字节。 1234567891011121314151617//cafe babe 魔数，0000 0034 为版本号（0000次+0034主）//001f (u2)表示constant_pool_count，十进制为31，表示常量池中有30个常量。接下来的就是常量池，因为每个常量都是以tag开头，后面再加常量信息。//0a 十进制为 10,tag为10，属于CONSTANT_Methodref_info类型常量//接下来的u2 0006 十进制 6,表示指向常量池中的第6个常量（表示方法属于的类）//再接下来的u2 0011 十进制17，表示指向常量池中的第17个常量（表示方法的名称和类型）。至此，第一个常量分析完毕。cafe babe 0000 0034 001f 0a00 0600 11 09//09 十进制为 9,tag为9，属于CONSTANT_Fieldref_info类型常量//接下来的u2 0012 十进制18,表示指向常量池第18个常量（表示字段属于的类）//再接下来的u2 0013 十进制19,表示指向常量池第19个常量（表示字段的名称和类型）。至此第二个常量分析完毕。0012 0013 0a00 1400 150a 0005 0016 07001707 0018 0100 063c 696e 6974 3e01 00032829 5601 0004 436f 6465 0100 0f4c 696e654e 756d 6265 7254 6162 6c65 0100 03616464 0100 0528 4949 2949 0100 046d 61696e01 0016 285b 4c6a 6176 612f 6c61 6e672f53 7472 696e 673b 2956 0100 0a53 6f75//按上面的方法分析，最后分析出来全部的30个常量（我萎了）,要么表示具体的字串，要么表示指向其他常量的索引。 使用javap -v Hello可以得出Hello.class的字节码常量池内容，如下 1234567891011121314151617181920212223242526272829303132333435public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#17 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #18.#19 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #20.#21 // java/io/PrintStream.print:(J)V #4 = Methodref #5.#22 // Hello.add:(II)I #5 = Class #23 // Hello #6 = Class #24 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 add #12 = Utf8 (II)I #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 SourceFile #16 = Utf8 Hello.java #17 = NameAndType #7:#8 // "&lt;init&gt;":()V #18 = Class #25 // java/lang/System #19 = NameAndType #26:#27 // out:Ljava/io/PrintStream; #20 = Class #28 // java/io/PrintStream #21 = NameAndType #29:#30 // print:(J)V #22 = NameAndType #11:#12 // add:(II)I #23 = Utf8 Hello #24 = Utf8 java/lang/Object #25 = Utf8 java/lang/System #26 = Utf8 out #27 = Utf8 Ljava/io/PrintStream; #28 = Utf8 java/io/PrintStream #29 = Utf8 print #30 = Utf8 (J)V 对比我刚刚分析的1、2号常量看下： #1：分析得出CONSTANT_Methodref_info类型常量，有两个引用，分别是第 6 和第 17个常量。 javap 结果：#1 = Methodref #6.#17 #2：分析得出CONSTANT_Fieldref_info类型变量，有凉个引用，分别是第 18和第 19个常量。 javap 结果：#2 = Fieldref #18.#19 分析成功！ 4. 访问标志​ 常量池所有的常量分析完毕之后，接下来的 2 字节（u2）代表访问标志，用来识别一些类或接口层次的访问信息，包括：该Class是类还是接口、是否是public、是否是abstract、是否是final类等，具体如下： 标志名称 标志值(16进制) 含义 ACC_PUBLIC 0001 是否public类型 ACC_FINAL 0010 是否final类型（只表示类，接口没有） ACC_SUPER 0020 是否允许invokespecital字节码指令，默认为true ACC_INTERFACE 0200 标识是接口 ACC_ABSTRACT 0400 是否abstract类型，如果该值为true，则其他都为false，因为不共存 ACC_SYNTHETIC 1000 标识该类不是用户代码产生 ACC_ANNOTATION 2000 标识是注释 ACC_ENUM 4000 标识是枚举 ​ 例如，一个class文件的访问标志是0x0021,则表示它是public类型的类 0020 | 0001 = 0021。 5. this_class 类索引​ 类索引 用于确定类的全限定名。 ​ 类索引 是 u2 类型，引用的是常量池中的 CONSTANT_Class_info 类型常量。然后根据Class_info 常量中的NameAndTye的索引值，可以获得 CONSTANT_Utf8_info 变量表示的类全限定名。 6. super_class 父类索引​ 父类索引 用于确定父类的全限定名，由于单继承限制，所以父类索引只有一个（不像接口，有个集合），除了Object类外，每个java类都有父类（如果类没直接extends某个类的话，则其父类就是Object），所以出Object外，每个类的类索引都不为 0。 ​ 父类索引和类索引一样，也是 u2 类型，也是引用的常量池中的 CONSTANT_Class_info 类型常量。 7. interfaces 接口索引集合​ 接口索引集合 用来描述该类 implements 了哪些接口，这些接口在集合中的顺序与 implements顺序相同。 ​ 对于接口集合，入口的第一个 u2 数据（十进制）表示接口的个数，如果没接口，则该项 u2 为0000，索引表就为空，表示在Class表中没有接口集合。 ​ 接口索引集合中的每个接口都是 u2 类型的数据，都表示指向常量池中CONSTANT_Class_info 类型常量。 8. 字段表集合​ 接口索引集合之后，紧接着的 u2 类型数据表示类中字段的个数，之后就是具体的字段表。一个字段表集合中的每个字段都是一张表。 ​ 字段表 用于描述接口或类中声明的变量，包括static变量和实例变量，不包括方法中声明的局部变量。 ​ 字段表中的每个字段都包含有很多信息，例如字段访问修饰符(public,private等)，字段是否static，字段是否final，字段类型，字段名、字段是否有初始化等。前面的修饰符要么为true要么为false，可以使用访问标志来修饰，而字段类型、字段名都不是固定的，因此只能引用常量池中的常量描述。 字段表结构（每个字段都是这结构）： 类型 名称 数量 u2 access_flags 字段修饰符 u2 name_index 字段简单名称 u2 description_index 1 u2 attributes_count 1 attribute_info attributes attrubutes_count 个 access_flags：字段修饰符，就是字段的访问修饰符，public，private，static，final等等啥的。 标志名称 标志值（16进制） 描述 ACC_PUBLIC 0001 字段是否public ACC_PRIVATE 0002 字段是否private ACC_PROTECTED 0004 字段是否protected ACC_STATIC 0008 字段是否static ACC_FINAL 0010 字段是否final ACC_VOLATILE 0040 字段是否volatile ACC_TRANSIENT 0080 字段是否transient ACC_SYNTHETIC 1000 字段是否由编译期自动产生 ACC_ENUM 4000 字段是否enum name_index：对常量池的引用，代表字段的简单名称。 简单名称就是没有类型和参数修饰的方法或字段名称，例如字段int i;简单名称就是 i，方法int add(){}简单名称就是 add。 description_index：对常量池的引用，代表字段和方法的描述符 描述符是用来描述字段的数据类型、方法的参数列表（参数数量、类型、顺序）和方法返回值。 描述符规则（字段）： 八大基本类型和void类型：由一个大写字母表示。 类型 描述符 byte B char C double D float F int I long J short S boolean Z void v 对象类型：用 L加对象全限定名表示。如 Ljava/lang/Object 数组类型：几维数组前面就加几个[，例如String[][],描述符就是[[Ljava/lang/String，int[]描述符就是[I 描述符规则（方法）：先参数列表后返回值的规则。 方法的参数列表由()表示，如果方法没有参数，参数描述符就只有一个()，如果方法有参数，参数描述符就是()里面包含参数类型。参数描述符后再加上返回类型描述符就是方法的全部描述符。 例如，方法Object index(char[] a,int b,int c,String[][] strs)的描述符为([cII[[Ljava/lang/String)Ljava/lang/Object。 attributes_count + attributes：字段的属性集合 并不是每个字段都有属性的，一般只进行声明的字段（未初始化），其属性表集合为空，如果进行初始化了，字段属性表就会有内容。例如，final static int i = 123;字段其attributes_count就为1，attributes就会有一个属性ConstantValue指向常量 123 。 ​ 注意：字段表中不包含从父类或接口中继承的字段。 9. 方法表集合​ 毋庸置疑，方法表集合包含了很多方法表，每个方法都是一张表。每个方法的表的结构都和字段表结构有很大的相似之处。 方法表结构（每个方法都是这结构）： 类型 名称 描述 u2 access_flags 方法修饰符 u2 name_index 方法简单名称 u2 description_index 字段和方法的描述符 u2 attributes_count 方法属性数量 attribute_info attributes 方法属性集合 access_flags：方法修饰符，这个与字段有一点点区别。 标志名称 标志值（16进制） 描述 ACC_PUBLIC 0001 方法是否public ACC_PRIVATE 0002 方法是否private ACC_PROTECTED 0004 方法是否protected ACC_STATIC 0008 方法是否static ACC_FINAL 0010 方法是否final ACC_SYNCHRONIZED 0020 方法是否synchronized ACC_BRIDGE 0040 方法是否是编译期产生的桥接方法 ACC_VARARGS 0080 方法是否接受不定参数 ACC_NATIVE 0100 方法是否是native方法 ACC_ABSTRACT 0400 方法是否为 abstract ACC_STRICT 0800 方法是否为 strictfp ACC_SYNTHETIC 1000 字段是否由编译期自动产生 name_index：对常量池的引用，代表方法的简单名称。（参照字段表） description_index：对常量池的引用，代表方法的描述符。（参照字段表） attributes_count + attributes：方法的属性集合 方法的方法体是由很多代码的，而这些代码都保存在attributes属性集中的Code属性中。 ​ 注意：方法表中不包含从父类继承的方法，对于父类方法，只会包含重写的父类方法。 10. 属性表集合​ 属性表示包含在字段或方法中(其他)的，单独拿出来讲，大概是因为它太大了… ​ 因为属性不是单独存在的，需要有依附。且属性表的长度不同，不同属性结构也不一样 属性表结构： 类型 名称 u2 attribute_name_index 属性的名称索引 u2 attribute_length 该属性在文件中的长度 u1 info 属性的具体信息（不同属性该值不同） 虚拟机规范中定义了很多属性（不一一列举了），举一个 1. Code属性​ java程序编译后，方法中的代码最终变为字节码指令存储在Code属性中。Code属性主要存在于方法表中的属性集合中（用来保存方法体中的代码），当然没有方法体的方法就没有Code属性了（接口方法、抽象方法）。 Code属性具体表结构： 类型 名称 描述 u2 attribute_name_index 属性名索引，指向常量池中常量 u4 attribute_length 属性长度 u2 max_stack 操作栈深度最大值 u2 max_locals 局部变量表所需空间 u4 code_length 字节码指令个数 u1 code 字节码指令 u2 exception_table_length 显示异常处理表长度 exception_info exception_table 显示异常处理表（可不存在） u2 attributes_count 属性个数 attribute_info attributes 属性表 参考： 《深入理解java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm内存区域]]></title>
    <url>%2F2019%2F02%2F22%2FjvmMemoryArea%2F</url>
    <content type="text"><![CDATA[一、运行时数据区概述： jvm执行程序时，会把它占有的内存分为一块块的区域，每个区域有不同的功能。就类似于国家分你一块地你用来造房子（我们从我们的16G 内存分几百MB给JVM），房子又分成了卧室（休息），客厅（..），洗手间（洗漱），厨房（做饭）等等区域。 而jvm内存区域具体分为： 线程独占区：每个线程都有各自的区域，区域的生命周期与线程相同 程序计数器 虚拟机栈 本地方法栈 线程共享区域：程序所有线程共享的一块区域 堆 方法区 1. 程序计数器 当前线程所执行的字节码的行号指示器。 ​ 啥是字节码？ jvm就是通过执行字节码指令来运行程序的（不知道可以这么理解吗），比如表示 + 的add指令，表示跳转的 goto 指令等。其中每个指令占一行，程序计数器就是指示运行的字节码指令的行号。比如 if语句，从15行跳转到19行，程序计数器就会从15变为19。 ​ 再试想，如果没有程序计数器记录字节码行号，一个CPU执行多线程程序，CPU对多个线程之间进行快速调度，如果当前线程执行到15行字节码，突然转换到另一个线程，等再次调度回来的时候，就接不上啦，GG。 作用： 字节码解释器通过改变程序计数器来依次读取指令，来实现代码的流程控制，如：顺序、选择、循环等。 在多线程下，程序计数器用于记录当前线程执行的位置，当线程被切换回来的时候能够知道上次运行的字节码位置。 注意： 如果执行的是 java 方法，程序计数器就指向字节码指令的地址。 如果执行的是 Native 方法，计数器为空（Undefined）。 程序计数器不会出现 OutOfMemoryError异常。 2. 虚拟机栈 虚拟机描述的是Java方法执行的内存模型。我们平常说的堆栈的栈就可以认为是虚拟机栈（中的局部变量表）。 ​ 每个方法被执行的时候都会创建一个栈帧，里面包含局部变量表、操作栈、动态链接、方法出口等。方法开始执行就对应栈帧入栈，执行完毕，对应栈帧出栈。 局部变量表： ​ 局部变量表存放了编译期可知的八种基本数据类型、对象引用和returnAddress类型（指向字节码指令的地址）。局部变量表的单位是slot(局部变量表空间)，除了 64位的 long和double会占用两个slot，其他类型都只占用一个slot。 注意： 局部变量表需要的空间在编译时期分配，不是运行期。运行期间不会改变局部变量表大小。 异常信息： StackOverflowError：线程请求栈深度大于虚拟机允许的深度。 OutOfMemoryError：虚拟机栈不够了，要申请额外内存，但是上头不分配了。 3. 本地方法栈 与虚拟机栈类似，不过本地方法栈是为 Native 方法服务的。也有栈帧啥的，也是栈帧入栈出栈。 4. 堆 最大的一块内存，在虚拟机启动时就创建好了堆，是所有线程共享的区域。仅用来存放对象实例，“几乎”所有的对象实例（包括数组对象）都在堆中创建。 ​ 由于堆用来存放对象实例的，如果对象死了，就要给它清理掉，释放堆中空间，所以堆还要经常进行GC（垃圾收集）。 ​ 又因为对象的生存时间不一样，有的死得快，有的老不死，所以有分为新生代（死得快）和老年代（老不死），分开来保存对象，这样GC时效率高一点，新生代需要经常GC，老年代偶尔GC，所以分代是为了更好地GC。 ​ 新生代又分为Eden 和两个Survivor区，空间大小比例 8:1:1，为什么需要这么划分请参考《jvm内存分配和垃圾收集》中的复制算法。为什么两个Survivor区请参考 新生代为什么分为一个Eden和两个Survivor 。 ​ java堆可以是物理上不连续的内存空间，但逻辑上要连续。java堆可动态扩展，通过 -Xmx和-Xms参数控制。 异常信息； OutOfMemoryError：堆中内存不够分配给对象，且堆的内存无法扩展增加时。 5. 方法区 方法区用于存储已被虚拟机加载的类信息、常量、static变量、即时编译期编译的代码等。 ​ 方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池： ​ 运行时常量池属于方法区。Class类文件结构中有一项常量池，用于存放编译期生成的各种字面量和符号引用，常量池的内容将在类加载后存放到方法区的运行时常量池中。 ​ 了解：Class文件中常量池还具有动态性，常量除了编译期产生外，还有可能在运行期间产生常量放入池中，例如String类的intern()方法。 异常信息： OutOfMemoryError：方法区内存不够，没法分配时。 二、直接内存（了解） 直接内存不属于上面说的运行时数据区，jvm规范中也没有对直接内存到底是哪块区域进行定义。 ​ NIO（New Input/Output）是一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接在堆外分配内存，java堆中有一个DirectByteBuffer对象引用了这块内存，所以可以通过该对象操作这块内存，可以避免在Java堆 和Native堆来回复制对象，提高效率。 ​ 因为也是内存，所以受本机总内存限制，如果仅仅设置了 -Xmx 参数来控制堆内存大小，而忽略了直接内存的设置，可能会导致直接内存+运行时数据区内存总和超过屋里内存限制，这样在动态扩展内存时因为超过物理内存限制发生 OutOfMemoryError 异常。 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生代为何分为一个Eden区和两个Survivor区]]></title>
    <url>%2F2019%2F02%2F21%2FjvmYoungGenerationEdenAndDoubleSurvivor%2F</url>
    <content type="text"><![CDATA[问题：为什么新生代还要分为Eden区和两个Survivor区? 注意：新生代GC是对所有存放对象的区域进行垃圾收集，并不只是Eden区，因为Survivor区保留的存活对象 1、为什么要新生代要分区？ 新生代采用复制算法进行垃圾收集，复制算法是需要分区的，原本是 1:1 分，进行垃圾收集时，A区中的存活对象复制到B区中，并将A区格式化，下次存对象就存到B区，收集时也是从B区复制到A区，循环往复… 2、为什么分Eden区和Survivor区比例不同？ 新生代中的对象是比较多的，如果每次使用一半，空闲一半，浪费太严重，所以比例不同。 80% 的空间分给Eden区域，10%+10% 分别分给from Survivor和to Survivor区，Eden区用来给新对象分配空间，Survivor用来保留存活对象。 具体的 8:1:1 的比例是实验得出来的最优（当然不是我实验的）。 3、为什么不是一个Eden + 一个Survivor？ 如果只有Eden和一个Survivor空间的话，收集操作会产生碎片化。 举例：假设条件是Eden 80% + Survivor20%。新分配对象到Eden区，Eden满后，需要GC，将Eden区存活对象复制到Survivor，之后清理Eden区。接着又存对象到Eden区，再次满了需要GC，这次GC会将Eden区存活对象复制到Survivor区，但是Survivor也有死亡的对象需要回收，Survivor区存活的对象仍然保持原位置，Survivor中回收剩下的区域就变成碎片，因为复制算法不会自动整理空间。久而久之，内存碎片增多，造成资源浪费。 为什么每次GC完事不把Survivor区存活的对象再复制到Eden区？ 似乎挺有道理，但是一是再次复制效率比较低，二来就没法判断哪些对象什么时候可以晋升至老年代了。 4、一个80%的Eden加两个10%的Survivor试试？ 将新生代分为 Eden(80%) + From Survivor(10%) + To Survivor(10%)，注意：这里的From和To不是和某一块Survivor区绑定的，即这次From是第一块Survivor，下次From就变成了第二块Survivor了。 每次分配新对象还是分配到Eden区中，但是每次GC仍只使用Eden区和一块Survivor区。 第一次GC：首先分配内存给Eden区，Eden满后需要GC，将存活对象复制到一块Survivor中，然后清理Eden区域。 第二次GC：将Eden和上次使用的Survivor区中的存活对象复制到另一块空闲的Survivor区中，再统一清理Eden区和上次使用的Survivor区。咦，这次又变成一块空闲的Survivor区和一块正在使用的Survivor区了，似乎碎片的问题也解决了（因为复制的对象顺序排列） 第 3、4 … n 次GC：GC过程都和第二次一样。在Survivor中的对象每度过一次GC，对象的Age+1，等到了年龄阈值（默认15，可设置）就可晋升至老年代，当然还有其他方式晋升老年代（不阐述了，参考《jvm内存分配和垃圾收集》）。 问题似乎就这么不完美的讲通了…]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 内存分配与垃圾收集]]></title>
    <url>%2F2019%2F02%2F20%2FjvmGC%2F</url>
    <content type="text"><![CDATA[一、垃圾收集概述回收区域： 栈：栈中的栈帧根据方法的开始和结束来执行入栈和出栈的操作，而每个栈帧要分配的内存在类结构确定下来就可以确定了。方法或线程结束，栈帧内存就回收。 堆和方法区：堆中一个接口的多个实现类需要的内存可能不同，方法区中一个方法的多个分支需要的内存也不一样，程序运行期才知道创建哪些对象，所以堆和方法区的内存分配不是开始就确定的(动态的)，回收也是动态的。 二、判断对象是否存活 堆中几乎存放着java所有对象，垃圾收集器在回收前要先判断对象是否存活。 1. 引用计数算法 给对象添加一个引用计数器，每当有一个地方引用该对象，计数器加 1，解除引用，计数器减 1。任一时刻，只要计数器为 0 ，则认为该对象不再存活。 带来的问题： 对象之间循环引用问题。 例如， 123456789101112131415161718public class Test&#123; public Object instance = null; public static void main(String[] args)&#123; //通过new在堆中创建一个对象，暂且称为实例1,test1引用了实例1对象，则实例1的引用加 1。 Test test1 = new Test(); //又通过new在堆中创建一个对象，称为实例2,test2引用了实例2对象，则实例2的引用加 1。 Test test2 = new Test(); //test1的instance属性引用了test2，实际上引用的是test2指向的堆中的实例2对象，实例2的引用又加 1，此时实例2引用数为 2. test1.instance = test2; //test2的instance属性引用了test1，实际上引用的是test1指向的堆中的实例1对象，实例1的引用又加 1，此时实例1引用数为 2. test2.instance = test1; //test1引用置为空，即不指向实例1，实例1引用数减1，为 1. test1 = null; //test2同test1. test2 = null; &#125;&#125;//最终实例1 和实例2 的引用数都为1(instance属性对其的引用)，所以这两个实例对象都不会被回收。 2. 根搜索算法 通过一系列的名为”GC Roots”的对象作为起始点，从这些节点向下搜索，经过的路径称为引用链，若一个对象到GC Roots没有引用链(即从GC Roots开始无法到达该对象)，则对象不可用。 可作为GC Roots的对象： 虚拟机栈中引用的对象。 方法区中类静态属性(static)引用的对象。 方法区中常量(final)引用的对象。 本地方法栈(native方法)中引用的对象。 3. 引用的分类： 强引用：可理解为直接引用，Object obj = new Object();，对于这类引用，垃圾收集器永远不会回收new Object()创造出的实例对象。 软引用：描述一些还有用，但不是必须要的对象。如果系统将要发生内存溢出，这些被软引用关联的对象就会被列进回收范围等待被回收，如果回收之后还是内存溢出，就抛出异常。 弱引用：也是描述非必须要的对象，比软引用更弱。弱引用关联的对象只能生存到下一次垃圾收集之前，下次垃圾收集开始时，内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：没啥实际引用意义。虚引用唯一目的就是关联对象被垃圾收集之前能收到个”报信”。 4. 根搜索算法判定对象存活处死一个对象的过程： 两次标记 一次标记：从GC Roots节点无法到达该对象。进行第一次标记和一次筛选，筛选是通过该对象是否有必要执行finalize()方法进行筛选。如果对象没有finalize方法或finalize方法之前被jvm调用过了，则没必要执行finalize方法，对象GG。 二次标记：如果对象有必要执行finalize方法，则该对象就会被放在F-Queue队列（押往刑场的牢笼）中，jvm会建立一个Finalizer线程来执行对象的finalize方法。Finalizer线程执行而不是对象自己执行finalize方法的目的是：防止对象以各种借口延缓被执行死刑（死循环），而Finalizer线程不会等待对象finalize方法结束。在这短短的finalize方法执行期间，如果对象成功收买法官（将该对象自身this赋值给GC Roots引用链上的对象），则该对象就逃出牢笼，完成自救。 注意： 待处死的对象完成自救后，如果继续犯事被押赴刑场，那就必须被处决了，因为它无法在finalize方法中再次收买法官（任何一个对象的finalize方法都只会被执行一次）。 示例： 12345678910111213141516171819202122232425262728293031323334353637package jvmTest01;public class KillObject &#123; public static KillObject SAVE_HIMSELF = null; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("死刑对象被押赴刑场..."); //收买法官，完成自救(和GC Roots引用链上的对象绑定) KillObject.SAVE_HIMSELF = this; &#125; public static void main(String[] args) throws Throwable&#123; //new实例化的KillObject对象在 GC Roots引用链中 SAVE_HIMSELF = new KillObject(); //KillObject对象犯事，不在引用链中，要被处死 SAVE_HIMSELF = null; //gc方法执行包含对象标记的过程，也包含对象的finalize方法执行 System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; //KillObject对象屡教不改，再次犯事 SAVE_HIMSELF = null; System.gc(); Thread.sleep(500); if (SAVE_HIMSELF != null) &#123; System.out.println("死刑对象完成自救"); &#125; else &#123; System.out.println("死刑对象被处死(被回收)"); &#125; &#125;&#125; 运行结果： 123456D:\java\jdk\bin\java.exe 死刑对象被押赴刑场...死刑对象完成自救死刑对象被处死(被回收)Process finished with exit code 0 结果表明： 对象再次犯事，没有完成自救被回收。因为他无法再次通过执行finalize方法收买法官（finalize方法一个对象只能执行一次）。 三、垃圾收集算法1. 标记 - 清除算法 最基本的垃圾收集算法。 算法思想： 标记：标记出要回收的对象。就是标记出上一节中那些最终押赴刑场执行处死的对象。 清除：统一回收掉被标记对象。对要处死对象统一枪毙。 问题： 标记 - 清除效率低下。 清除后的对象产生小碎片，如果要分配大对象，还需要再次进行垃圾收集整合小碎片为大空间。 2. 复制算法 将可用内存划分为容量相等的两块，每次使用一块，使用的这块用完了，进行垃圾回收时，就将这块上的存活对象复制到另一块保留区域上，再将这块内存区域一次清理变成保留区域。 代价就是内存缩小为原来的一半。 回收新生代采用复制算法，并做了改进： 新生代的对象 98% 都是短命鬼，由于回收时存活对象很少，所以划分区域时，就不用按照1:1划分了，划分一小块区域暂存存活对象即可。 新生代划分对象是划分为一块大空间（Eden）和两块小空间（Survivor），每次使用Eden和一块Survivor空间。进行回收，只需要把Eden和Survivor空间上的存活对象复制到另一块Survivor空间，最后清理掉Eden和Survivor空间。默认Eden:Survivor:Survivor=8:1:1。所以浪费的空间只有 10%。 如果进行回收时，存活对象比Survivor空间大，复制过去装不下，则就需要向其他内存（例如老年代）进行暂借空间，这种机制称为分配担保（后续讲解）。 3. 标记 - 整理算法算法思想： 标记：标记出要回收的对象。标记方法同标记 - 清除算法。 整理：让所有存活对象向内存区域的一端移动，聚一堆。然后将这一堆以外的其他空间直接清理，腾出空间。 4. 分代收集算法 根据对象存活周期的差异将内存划为几块。一般堆划分为新生代和老年代，根据年代特点选择不同的收集算法。 例如， 新生代：对象比较短命，存活的少，采用 8:1:1 的复制算法。 老年代：对象比较能活（老不死），采用标记 - 清理或者标记 - 整理算法。 四、垃圾收集器 说明： 图片上部Young generation表示新生代，Tenured generation表示老年代，收集器之间的连线表示两者可以配套使用。 1. Serial收集器（新生代、单线程）收集算法：复制算法。 单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在进行收集时，必须暂停其他所有的工作线程（包括用户正常的工作线程），直到收集完成。 应用： 目前是jvm运行在Client模式下的默认的新生代收集器，单线程没有线程交互，专心收垃圾，效率很高。 2. ParNew收集器（新生代，多线程）收集算法：复制算法。 可认为是Serial的多线程版本，除了增加了垃圾回收线程外，其他与Serial基本一致。 随着CPU数量增加，ParNew对于系统资源的利用越来越强。默认开启的GC线程数与CPU数量相同，可以使用 -XX:ParallelGCThreads 参数来限制GC线程数量。 3. Parallel Scavenge收集器（新生代、多线程）收集算法：复制算法。 与其他收集器如CMS收集器尽量缩短垃圾收集时用户线程的停顿时间不同，Parallel Scavenge收集器目标是达到一个可控制的吞吐量，吞吐量就是CPU运行用户代码时间占CPU运行总时间（包含垃圾收集时间）的比重。 停顿时间和吞吐量： 首先应明确吞吐量是用户代码执行时间占总时间比例，总时间中垃圾收集并不是一次执行，而是许多次垃圾收集时间总和，用户代码和垃圾收集交替。而停顿时间是表示每次垃圾收集占有的时间，缩短停顿时间可能会导致垃圾收集次数变多。 停顿时间：停顿时间短，响应时间就快，适合与用户交互的程序。 吞吐量：吞吐量大，CPU执行用户代码时间长，程序的运算效率高，适合后台运算任务。 4. Serial Old收集器（老年代、单线程）收集算法：标记 - 整理算法。 Serial收集器老年代版本。单线程收集器。 5. Parallel Old收集器（老年代、多线程）收集算法：标记 - 整理。 Parallel Scavenge收集器老年代版本。多线程收集器。Parallel Scavenge + Parallel Old收集器组成纯 “吞吐量” 优先收集器。 6. CMS收集器（老年代、多线程）收集算法：标记 - 清除算法。 CMS收集器是一种为了获取最短停顿时间的收集器。 CMS运行过程： 初始标记：标记一下GC Roots直接关联的对象，速度快。需要暂停其他线程。 并发标记：从上阶段标记的直接关联对象触发，标记所有从GC Roots可达的对象（GC Roots间接关联的对象），该阶段是和用户线程并发执行的。该阶段耗时最长。 重新标记：为了修正并发标记阶段，因用户程序运行导致标记变动的对象的标记记录。速度比初始标记慢一点，但仍然很快。需要暂停其他线程。 并发清除：垃圾清除的过程。和用户线程并发执行。耗时较长。 扫尾：因为CMS运行有四个过程，其中有单线程（初始标记、重新标记），有多线程（并发标记、并发清除），而单线程耗时极短，大部分时间都消耗在多线程的并发阶段，所以可以认为是多线程的。 缺点： CMS收集器对资源敏感。并发执行，垃圾收集线程会占用部分CPU资源，默认GC线程数是（CPU数量+3）/4，当CPU数量小于 4时（例如 2个），就会分出 50%的资源用来GC。 增量式并发收集器：用来解决CPU数量小于 4的情况。做法就是在并发阶段（并发标记、并发清理），让GC线程和用户线程交互执行（并行），减少GC线程占用资源时间。 无法处理浮动垃圾。因为清除阶段是和用户线程并发执行的，所以清除阶段还可能产生新的垃圾而无法被清除，只能等下一次Full GC清除。也正因为用户线程还在运行，所以要留取一部分空间给用户线程，默认老年代使用 68%就会激活CMS进行回收。 -XX:CMSInitiatingOccupancyFraction参数设置可以来提高触发GC的百分比。 但如果CMS运行时预留给用户线程的内存不够，会出现一次 “Concurrent Mode Failure” 失败，导致CMS失效，使用预备的Serial Old收集器重新进行Full GC（老年代垃圾回收），停顿时间大大增加。 所以提高百分比有风险，设置需谨慎。 收集结束会产生大量空间碎片。CMS基于标记 - 清除算法，产生小碎片后，下次分配大对象会塞不进去，从而又触发一次Full GC。 -XX:+UseCMSCompactAtFullCollection 参数设置CMS收集结束后自动进行碎片整理（会暂停用户线程），不过停顿时间会延长。 -XX:CMSFullGCsBeforeCompaction 参数设置执行 n 次不压缩的Full GC后就执行一次压缩碎片的Full GC。 7. G1收集器（全堆、多线程）收集算法：标记 - 整理。 G1特点： 并行与并发：利用多CPU的优势，使用多个CPU来尽可能缩短停顿时间，来达到原本需要暂停用户线程的操作现在不暂停的效果。 分代收集：G1中仍然将内存空间进行分代。G1能够以不同的方式处理各种对象（新对象、存活一段时间对象、讲过几次GC仍存活的对象），来独立管理整个堆（包括新生代和老年代）。 空间整合：基于标记 - 整理算法，不产生内存碎片，收集后的空间连续、完整，可保存大对象。 可预测的停顿：除了降低停顿时间，G1还可以建立可预测的停顿时间模型。可以让使用者指定一个时间段，GC消耗的时间不能超过指定的时间。 管理整个堆内存： G 1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 建立可预测的时间模型： G1对整个堆进行垃圾收集是有计划的，其内部有一个回收优先级列表，列表中的待回收的Region顺序是根据每个Region回收性价比进行排序（回收的空间越大，时间越短，性价比越高），每次回收优先回收性价比高的Region，这样在一定的收集时间内收集效率就很高。 避免全堆扫描对象： G1将堆分为多个Region，逻辑上相互独立，实际上Region中的对象可能与其他任意一个Region中的对象有引用关系。使用全堆扫描，才能保证GC的准确性，但GC效率会大大下降。 解决办法：G1为每个Region维护一个Remembered Set，如果程序对引用类型数据进行写操作，虚拟机会产生一个Write Barrier中断写操作，然后检查引用的对象是否是其他Region中的，如果是，就将引用信息写到被引用对象所在的Region的Remembered Set表中。进行内存回收时，GC Roots枚举范围也参照Remembered Set表内容来扫描对象，可以实现不全堆扫描也能保证准确。 G1运行流程： 初始标记：同CMS收集器。 并发标记：同CMS收集器。 最终标记：类似CMS的重新标记，也是为了找到并发标记情况下因程序运行收到变动的对象，然后将变化记录到线程的Remembered Set Logs中，之后再将Logs中的数据合并到Remembered Set中。 筛选回收：先根据回收性价比在优先级列表中排序，根据用户指定的停顿时间制定回收计划。制定停顿时间内根据优先级堆Region进行回收。 五、内存分配与回收 对象在堆中分配内存，主要分配在新生代的Eden去榆中，如果启动了TLAB，将按线程优先在TLAB上分配，少数情况直接分配在老年代。具体分配要参照收集器组合和设置的参数。 1. 对象优先在Eden分配 多数情况下，对象在Eden区分配，E的呢空间不够，则进行一次Minor GC（新生代GC），如果空间仍然不够，则根据分配担保机制，将Eden区中占空对象提前转移到老年代。 2. 大对象直接进入老年代 大对象需要占用大量的连续空间（如长字符串、数组等），虚拟机提供了一个参数用来指定大对象 -XX:PretenureSizeThreshold ，大于参数值的大对象直接扔进老年代。 注意：只有Serial和ParNew能识别该参数。可以考虑使用ParNew+CMS收集器组合来实现该参数相同的功能。 3. 长期存活的对象将进入老年代 虚拟机有分代收集思想，所以会识别对象是属于哪个年代。 识别对象年代方式：每个对象都有Age计数器代表年龄，对象从Eden出生并且度过了第一次Minor GC并能被Survivor容纳且成功转移到Survivor中，该对象Age为 1。以后对象每经过一次Minor GC且每被回收，Age就 +1，直到对象成年（默认Age为15）后，就晋升到老年代。对象成年Age值可通过 -XX:MaxTenuringThreshold 设置。 4. 对象成年Age动态判定 并不是一定到达参数指定Age才可扔到老年代。如果Survivor中相同Age所有对象大小总和大于Survivor空间的 50%，则Survivor中Age大于等于该Age的对象都可以直接进入老年代，而不用等到参数要求的Age。 例如，Survivor中有20MB空间，有一个4MB的对象Age为6，有六个2MB的对象Age为3，剩下四个1MB的对象Age为2，由于六个Age为3 的对象总空间12MB大于Survivor的 50%，所以此时Age为6和3的 7 个对象可以直接进入老年代。 5. 空间分配担保 新生代采用复制算法，GC时如果Survivor空间暂时不够保存存活的对象，就需要老年代进行分配担保，让Survivor无法容纳的对象进入老年代。但是老年代的剩余空间还得保证能够容纳这些对象，由于这次回收进入老年代的对象需要的空间是未知的，所以需要参考以往需要的容量的平均大小，来看是否能够容纳。如果不能容纳，即担保失败，就需要进行一次老年代的Full GC。 通过查看HandlePromotionFailure设置值是否支持担保失败，如果允许担保失败，则只进行Minor GC即可，如果不允许失败，也需要进行一次Full GC。 六、常见面试题 GC的常见算法 CMS及G1的垃圾回收过程，CMS的各个阶段那两个是Stop The World（暂停其他线程）的？CMS会不会产生空间碎片？ G1的优势 标记清除和标记整理算法的理解及优缺点 Eden Survivor区的比例，为什么是这个比例，Eden Survivor的工作过程 JVM如何判断一个对象是否应该被GC？有哪些类型的对象可被作为GC Roots？ 强、软、弱、虚引用的区别，及GC对他们执行怎么样的操作？ 参考： 《深入理解Java虚拟机 - 周志明》]]></content>
      <categories>
        <category>java</category>
        <category>java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F02%2F18%2FStartMyBlog%2F</url>
    <content type="text"><![CDATA[GitPages Hexo搭建GitHub博客1、下载安装node.jsNode.js官网下载注意： 可以选择自定义安装位置。 2、安装 Sublime text 3Sublime Text 3下载地址下载速度较慢，不过安装包较小。安装位置可自己选择。 3、注册GitHub账号 GitHub注册地址 注册用户名 邮箱 密码 添加新的仓库(new repository)： Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、安装GitGit下载地址下载安装Git，安装位置可自由选择。 5、配置GitHubSSH6、初始化配置Hexo简介： Hexo详细说明参考Hexo官网，Hexo就是一个用Node.js编写的静态网站生成器(所以需要安装Node.js)，可以用来做博客框架，恰好它还可以将静态网站部署到GitHub，所以你编写的博客通过Hexo生成静态页面，然后在部署到GitHub中，通过访问GitHub中的页面也都是静态页面。 在写博客的地方创建文件夹例如，我在D盘创建Hexo文件夹。 在D:/Hexo文件夹按住shift点击鼠标右键选择在此处打开Powershell窗口 输入npm install hexo-cli -g命令，等待 等待完成后输入 hexo -v查看是否安装。 打开D:/hexo文件夹，鼠标右键选择git bash here,输入hexo init blog命令来初始化blog目录，该目录用来存放博客相关。 git bash窗口中输入以下命令： cd blog npm install hexo s 浏览器输入 localhost:4000,看能否打开Hexo默认主题。 至此，博客系统搭建完成，需要手动配置博客主题(为了好看)。 7、Next主题使用在Hexo官网 上方有主题栏，可供选择。这里采用使用比较多的主题：NexT主题。 仓库下载地址：NexT仓库，可选择git clone或下载压缩包形式下载。 解压缩压缩包，并将文件夹更名为next，移动到blog/themes目录中。 修改Hexo配置文件_config.yml 修改配置文件详情即接下来的步骤，请参考NexT文档 或者博客末尾的第二个视频，文档和视频都非常详细。 参考视频教程(B站)：GitHub+hexo搭建博客使用Next主题优化博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
